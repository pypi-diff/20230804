# Comparing `tmp/atoti_core-0.8.2-0_80138c9-py3-none-any.whl.zip` & `tmp/atoti_core-0.8.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,85 +1,85 @@
-Zip file size: 70851 bytes, number of entries: 83
--rw-r--r--  2.0 unx    23472 b- defN 23-Jul-03 17:49 atoti_core/LICENSE
--rw-r--r--  2.0 unx     2490 b- defN 23-Jul-03 17:39 atoti_core/__init__.py
--rw-r--r--  2.0 unx     1679 b- defN 23-Jul-03 17:39 atoti_core/_get_endpoint_path.py
--rw-r--r--  2.0 unx     1565 b- defN 23-Jul-03 17:39 atoti_core/_link.py
--rw-r--r--  2.0 unx      145 b- defN 23-Jul-03 17:39 atoti_core/_other_identifier.py
--rw-r--r--  2.0 unx      384 b- defN 23-Jul-03 17:39 atoti_core/_server_versions.py
--rw-r--r--  2.0 unx     8797 b- defN 23-Jul-03 17:39 atoti_core/activeviam_client.py
--rw-r--r--  2.0 unx      128 b- defN 23-Jul-03 17:39 atoti_core/arithmetic_operator.py
--rw-r--r--  2.0 unx     2437 b- defN 23-Jul-03 17:39 atoti_core/base_cube.py
--rw-r--r--  2.0 unx      561 b- defN 23-Jul-03 17:39 atoti_core/base_cubes.py
--rw-r--r--  2.0 unx     2273 b- defN 23-Jul-03 17:39 atoti_core/base_hierarchies.py
--rw-r--r--  2.0 unx     5672 b- defN 23-Jul-03 17:39 atoti_core/base_hierarchy.py
--rw-r--r--  2.0 unx     4989 b- defN 23-Jul-03 17:39 atoti_core/base_level.py
--rw-r--r--  2.0 unx     3961 b- defN 23-Jul-03 17:39 atoti_core/base_levels.py
--rw-r--r--  2.0 unx     2551 b- defN 23-Jul-03 17:39 atoti_core/base_measure.py
--rw-r--r--  2.0 unx     1365 b- defN 23-Jul-03 17:39 atoti_core/base_measures.py
--rw-r--r--  2.0 unx    11005 b- defN 23-Jul-03 17:39 atoti_core/base_session.py
--rw-r--r--  2.0 unx      221 b- defN 23-Jul-03 17:39 atoti_core/boolean_operator.py
--rw-r--r--  2.0 unx      494 b- defN 23-Jul-03 17:39 atoti_core/column_identifier.py
--rw-r--r--  2.0 unx     3537 b- defN 23-Jul-03 17:39 atoti_core/combine_conditions.py
--rw-r--r--  2.0 unx      732 b- defN 23-Jul-03 17:39 atoti_core/comparison_operator.py
--rw-r--r--  2.0 unx      764 b- defN 23-Jul-03 17:39 atoti_core/condition_to_dict.py
--rw-r--r--  2.0 unx      913 b- defN 23-Jul-03 17:39 atoti_core/condition_to_pairs.py
--rw-r--r--  2.0 unx     5240 b- defN 23-Jul-03 17:39 atoti_core/constant.py
--rw-r--r--  2.0 unx       88 b- defN 23-Jul-03 17:39 atoti_core/context.py
--rw-r--r--  2.0 unx     3313 b- defN 23-Jul-03 17:39 atoti_core/convert_series.py
--rw-r--r--  2.0 unx     1720 b- defN 23-Jul-03 17:39 atoti_core/create_dataframe.py
--rw-r--r--  2.0 unx     3946 b- defN 23-Jul-03 17:39 atoti_core/data_type.py
--rw-r--r--  2.0 unx     9596 b- defN 23-Jul-03 17:39 atoti_core/decombine_condition.py
--rw-r--r--  2.0 unx       78 b- defN 23-Jul-03 17:39 atoti_core/default_query_timeout.py
--rw-r--r--  2.0 unx     3191 b- defN 23-Jul-03 17:39 atoti_core/delegate_mutable_mapping.py
--rw-r--r--  2.0 unx     1325 b- defN 23-Jul-03 17:39 atoti_core/delegate_mutable_set.py
--rw-r--r--  2.0 unx      553 b- defN 23-Jul-03 17:39 atoti_core/deprecated.py
--rw-r--r--  2.0 unx     1900 b- defN 23-Jul-03 17:39 atoti_core/doc.py
--rw-r--r--  2.0 unx      165 b- defN 23-Jul-03 17:39 atoti_core/empty_mapping.py
--rw-r--r--  2.0 unx     3471 b- defN 23-Jul-03 17:39 atoti_core/fetch_json.py
--rw-r--r--  2.0 unx      590 b- defN 23-Jul-03 17:39 atoti_core/find_corresponding_top_level_variable_name.py
--rw-r--r--  2.0 unx      326 b- defN 23-Jul-03 17:39 atoti_core/get_env_flag.py
--rw-r--r--  2.0 unx      318 b- defN 23-Jul-03 17:39 atoti_core/get_identifier.py
--rw-r--r--  2.0 unx     1613 b- defN 23-Jul-03 17:39 atoti_core/get_installed_plugins.py
--rw-r--r--  2.0 unx     1008 b- defN 23-Jul-03 17:39 atoti_core/get_ipython.py
--rw-r--r--  2.0 unx     2145 b- defN 23-Jul-03 17:39 atoti_core/get_literal_args.py
--rw-r--r--  2.0 unx      358 b- defN 23-Jul-03 17:39 atoti_core/get_package_version.py
--rw-r--r--  2.0 unx      265 b- defN 23-Jul-03 17:39 atoti_core/get_top_level_package_name.py
--rw-r--r--  2.0 unx      367 b- defN 23-Jul-03 17:39 atoti_core/has_identifier.py
--rw-r--r--  2.0 unx      642 b- defN 23-Jul-03 17:39 atoti_core/hierarchy_identifier.py
--rw-r--r--  2.0 unx     3954 b- defN 23-Jul-03 17:39 atoti_core/hierarchy_isin_condition.py
--rw-r--r--  2.0 unx       69 b- defN 23-Jul-03 17:39 atoti_core/hierarchy_key.py
--rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 17:39 atoti_core/http_method.py
--rw-r--r--  2.0 unx      144 b- defN 23-Jul-03 17:39 atoti_core/identifiable.py
--rw-r--r--  2.0 unx      348 b- defN 23-Jul-03 17:39 atoti_core/identifier.py
--rw-r--r--  2.0 unx      146 b- defN 23-Jul-03 17:39 atoti_core/identifier_like.py
--rw-r--r--  2.0 unx      312 b- defN 23-Jul-03 17:39 atoti_core/identify.py
--rw-r--r--  2.0 unx      886 b- defN 23-Jul-03 17:39 atoti_core/immutable_mapping.py
--rw-r--r--  2.0 unx      404 b- defN 23-Jul-03 17:39 atoti_core/ipython_key_completions.py
--rw-r--r--  2.0 unx     3407 b- defN 23-Jul-03 17:39 atoti_core/isin_condition.py
--rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 17:39 atoti_core/java_max_int.py
--rw-r--r--  2.0 unx     1055 b- defN 23-Jul-03 17:39 atoti_core/keyword_only_dataclass.py
--rw-r--r--  2.0 unx      767 b- defN 23-Jul-03 17:39 atoti_core/level_identifier.py
--rw-r--r--  2.0 unx      102 b- defN 23-Jul-03 17:39 atoti_core/level_key.py
--rw-r--r--  2.0 unx      637 b- defN 23-Jul-03 17:39 atoti_core/license_key.py
--rw-r--r--  2.0 unx      777 b- defN 23-Jul-03 17:39 atoti_core/measure_identifier.py
--rw-r--r--  2.0 unx      295 b- defN 23-Jul-03 17:39 atoti_core/mime_type.py
--rw-r--r--  2.0 unx      282 b- defN 23-Jul-03 17:39 atoti_core/missing_plugin_error.py
--rw-r--r--  2.0 unx     9041 b- defN 23-Jul-03 17:39 atoti_core/operand_convertible_with_identifier.py
--rw-r--r--  2.0 unx    25370 b- defN 23-Jul-03 17:39 atoti_core/operation.py
--rw-r--r--  2.0 unx      315 b- defN 23-Jul-03 17:39 atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py
--rw-r--r--  2.0 unx      180 b- defN 23-Jul-03 17:39 atoti_core/path.py
--rw-r--r--  2.0 unx      738 b- defN 23-Jul-03 17:39 atoti_core/plugin.py
--rw-r--r--  2.0 unx      866 b- defN 23-Jul-03 17:39 atoti_core/plugins.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jul-03 17:39 atoti_core/py.typed
--rw-r--r--  2.0 unx     9949 b- defN 23-Jul-03 17:39 atoti_core/query_doc.py
--rw-r--r--  2.0 unx      399 b- defN 23-Jul-03 17:39 atoti_core/query_filter.py
--rw-r--r--  2.0 unx      785 b- defN 23-Jul-03 17:39 atoti_core/raise_multiple_levels_with_same_name_error.py
--rw-r--r--  2.0 unx     2270 b- defN 23-Jul-03 17:39 atoti_core/reactive_mutable_set.py
--rw-r--r--  2.0 unx     2202 b- defN 23-Jul-03 17:39 atoti_core/repr_json.py
--rw-r--r--  2.0 unx       28 b- defN 23-Jul-03 17:39 atoti_core/scenario.py
--rw-r--r--  2.0 unx      563 b- defN 23-Jul-03 17:39 atoti_core/str_to_bool.py
--rw-r--r--  2.0 unx      352 b- defN 23-Jul-03 17:39 atoti_core/table_identifier.py
--rw-r--r--  2.0 unx      855 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/METADATA
--rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     7056 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/RECORD
-83 files, 197245 bytes uncompressed, 59659 bytes compressed:  69.8%
+Zip file size: 70882 bytes, number of entries: 83
+-rw-r--r--  2.0 unx    23472 b- defN 23-Aug-03 23:51 atoti_core/LICENSE
+-rw-r--r--  2.0 unx     2490 b- defN 23-Aug-03 23:41 atoti_core/__init__.py
+-rw-r--r--  2.0 unx     1679 b- defN 23-Aug-03 23:41 atoti_core/_get_endpoint_path.py
+-rw-r--r--  2.0 unx     1564 b- defN 23-Aug-03 23:41 atoti_core/_link.py
+-rw-r--r--  2.0 unx      151 b- defN 23-Aug-03 23:41 atoti_core/_other_identifier.py
+-rw-r--r--  2.0 unx      384 b- defN 23-Aug-03 23:41 atoti_core/_server_versions.py
+-rw-r--r--  2.0 unx     8797 b- defN 23-Aug-03 23:41 atoti_core/activeviam_client.py
+-rw-r--r--  2.0 unx      128 b- defN 23-Aug-03 23:41 atoti_core/arithmetic_operator.py
+-rw-r--r--  2.0 unx     2476 b- defN 23-Aug-03 23:41 atoti_core/base_cube.py
+-rw-r--r--  2.0 unx      570 b- defN 23-Aug-03 23:41 atoti_core/base_cubes.py
+-rw-r--r--  2.0 unx     2327 b- defN 23-Aug-03 23:41 atoti_core/base_hierarchies.py
+-rw-r--r--  2.0 unx     5690 b- defN 23-Aug-03 23:41 atoti_core/base_hierarchy.py
+-rw-r--r--  2.0 unx     4989 b- defN 23-Aug-03 23:41 atoti_core/base_level.py
+-rw-r--r--  2.0 unx     3994 b- defN 23-Aug-03 23:41 atoti_core/base_levels.py
+-rw-r--r--  2.0 unx     2551 b- defN 23-Aug-03 23:41 atoti_core/base_measure.py
+-rw-r--r--  2.0 unx     1410 b- defN 23-Aug-03 23:41 atoti_core/base_measures.py
+-rw-r--r--  2.0 unx    11028 b- defN 23-Aug-03 23:41 atoti_core/base_session.py
+-rw-r--r--  2.0 unx      221 b- defN 23-Aug-03 23:41 atoti_core/boolean_operator.py
+-rw-r--r--  2.0 unx      494 b- defN 23-Aug-03 23:41 atoti_core/column_identifier.py
+-rw-r--r--  2.0 unx     3657 b- defN 23-Aug-03 23:41 atoti_core/combine_conditions.py
+-rw-r--r--  2.0 unx      732 b- defN 23-Aug-03 23:41 atoti_core/comparison_operator.py
+-rw-r--r--  2.0 unx      790 b- defN 23-Aug-03 23:41 atoti_core/condition_to_dict.py
+-rw-r--r--  2.0 unx      980 b- defN 23-Aug-03 23:41 atoti_core/condition_to_pairs.py
+-rw-r--r--  2.0 unx     5240 b- defN 23-Aug-03 23:41 atoti_core/constant.py
+-rw-r--r--  2.0 unx       88 b- defN 23-Aug-03 23:41 atoti_core/context.py
+-rw-r--r--  2.0 unx     3313 b- defN 23-Aug-03 23:41 atoti_core/convert_series.py
+-rw-r--r--  2.0 unx     1720 b- defN 23-Aug-03 23:41 atoti_core/create_dataframe.py
+-rw-r--r--  2.0 unx     3946 b- defN 23-Aug-03 23:41 atoti_core/data_type.py
+-rw-r--r--  2.0 unx     9906 b- defN 23-Aug-03 23:41 atoti_core/decombine_condition.py
+-rw-r--r--  2.0 unx       78 b- defN 23-Aug-03 23:41 atoti_core/default_query_timeout.py
+-rw-r--r--  2.0 unx     3191 b- defN 23-Aug-03 23:41 atoti_core/delegate_mutable_mapping.py
+-rw-r--r--  2.0 unx     1325 b- defN 23-Aug-03 23:41 atoti_core/delegate_mutable_set.py
+-rw-r--r--  2.0 unx      553 b- defN 23-Aug-03 23:41 atoti_core/deprecated.py
+-rw-r--r--  2.0 unx     1293 b- defN 23-Aug-03 23:41 atoti_core/doc.py
+-rw-r--r--  2.0 unx      165 b- defN 23-Aug-03 23:41 atoti_core/empty_mapping.py
+-rw-r--r--  2.0 unx     3471 b- defN 23-Aug-03 23:41 atoti_core/fetch_json.py
+-rw-r--r--  2.0 unx      590 b- defN 23-Aug-03 23:41 atoti_core/find_corresponding_top_level_variable_name.py
+-rw-r--r--  2.0 unx      326 b- defN 23-Aug-03 23:41 atoti_core/get_env_flag.py
+-rw-r--r--  2.0 unx      330 b- defN 23-Aug-03 23:41 atoti_core/get_identifier.py
+-rw-r--r--  2.0 unx     1613 b- defN 23-Aug-03 23:41 atoti_core/get_installed_plugins.py
+-rw-r--r--  2.0 unx     1008 b- defN 23-Aug-03 23:41 atoti_core/get_ipython.py
+-rw-r--r--  2.0 unx     2145 b- defN 23-Aug-03 23:41 atoti_core/get_literal_args.py
+-rw-r--r--  2.0 unx      358 b- defN 23-Aug-03 23:41 atoti_core/get_package_version.py
+-rw-r--r--  2.0 unx      265 b- defN 23-Aug-03 23:41 atoti_core/get_top_level_package_name.py
+-rw-r--r--  2.0 unx      379 b- defN 23-Aug-03 23:41 atoti_core/has_identifier.py
+-rw-r--r--  2.0 unx      792 b- defN 23-Aug-03 23:41 atoti_core/hierarchy_identifier.py
+-rw-r--r--  2.0 unx     3954 b- defN 23-Aug-03 23:41 atoti_core/hierarchy_isin_condition.py
+-rw-r--r--  2.0 unx       69 b- defN 23-Aug-03 23:41 atoti_core/hierarchy_key.py
+-rw-r--r--  2.0 unx      109 b- defN 23-Aug-03 23:41 atoti_core/http_method.py
+-rw-r--r--  2.0 unx      153 b- defN 23-Aug-03 23:41 atoti_core/identifiable.py
+-rw-r--r--  2.0 unx      181 b- defN 23-Aug-03 23:41 atoti_core/identifier.py
+-rw-r--r--  2.0 unx      155 b- defN 23-Aug-03 23:41 atoti_core/identifier_like.py
+-rw-r--r--  2.0 unx      324 b- defN 23-Aug-03 23:41 atoti_core/identify.py
+-rw-r--r--  2.0 unx      886 b- defN 23-Aug-03 23:41 atoti_core/immutable_mapping.py
+-rw-r--r--  2.0 unx      404 b- defN 23-Aug-03 23:41 atoti_core/ipython_key_completions.py
+-rw-r--r--  2.0 unx     3505 b- defN 23-Aug-03 23:41 atoti_core/isin_condition.py
+-rw-r--r--  2.0 unx      109 b- defN 23-Aug-03 23:41 atoti_core/java_max_int.py
+-rw-r--r--  2.0 unx     1057 b- defN 23-Aug-03 23:41 atoti_core/keyword_only_dataclass.py
+-rw-r--r--  2.0 unx      917 b- defN 23-Aug-03 23:41 atoti_core/level_identifier.py
+-rw-r--r--  2.0 unx      102 b- defN 23-Aug-03 23:41 atoti_core/level_key.py
+-rw-r--r--  2.0 unx      637 b- defN 23-Aug-03 23:41 atoti_core/license_key.py
+-rw-r--r--  2.0 unx      693 b- defN 23-Aug-03 23:41 atoti_core/measure_identifier.py
+-rw-r--r--  2.0 unx      295 b- defN 23-Aug-03 23:41 atoti_core/mime_type.py
+-rw-r--r--  2.0 unx      282 b- defN 23-Aug-03 23:41 atoti_core/missing_plugin_error.py
+-rw-r--r--  2.0 unx     9311 b- defN 23-Aug-03 23:41 atoti_core/operand_convertible_with_identifier.py
+-rw-r--r--  2.0 unx    25967 b- defN 23-Aug-03 23:41 atoti_core/operation.py
+-rw-r--r--  2.0 unx      315 b- defN 23-Aug-03 23:41 atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py
+-rw-r--r--  2.0 unx      180 b- defN 23-Aug-03 23:41 atoti_core/path.py
+-rw-r--r--  2.0 unx     1076 b- defN 23-Aug-03 23:41 atoti_core/plugin.py
+-rw-r--r--  2.0 unx      866 b- defN 23-Aug-03 23:41 atoti_core/plugins.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-03 23:41 atoti_core/py.typed
+-rw-r--r--  2.0 unx     9949 b- defN 23-Aug-03 23:41 atoti_core/query_doc.py
+-rw-r--r--  2.0 unx      399 b- defN 23-Aug-03 23:41 atoti_core/query_filter.py
+-rw-r--r--  2.0 unx      785 b- defN 23-Aug-03 23:41 atoti_core/raise_multiple_levels_with_same_name_error.py
+-rw-r--r--  2.0 unx     2270 b- defN 23-Aug-03 23:41 atoti_core/reactive_mutable_set.py
+-rw-r--r--  2.0 unx     2202 b- defN 23-Aug-03 23:41 atoti_core/repr_json.py
+-rw-r--r--  2.0 unx       28 b- defN 23-Aug-03 23:41 atoti_core/scenario.py
+-rw-r--r--  2.0 unx      563 b- defN 23-Aug-03 23:41 atoti_core/str_to_bool.py
+-rw-r--r--  2.0 unx      352 b- defN 23-Aug-03 23:41 atoti_core/table_identifier.py
+-rw-r--r--  2.0 unx      855 b- defN 23-Aug-03 23:51 atoti_core-0.8.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-03 23:51 atoti_core-0.8.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Aug-03 23:51 atoti_core-0.8.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7056 b- defN 23-Aug-03 23:51 atoti_core-0.8.3.dist-info/RECORD
+83 files, 198778 bytes uncompressed, 59690 bytes compressed:  70.0%
```

## zipnote {}

```diff
@@ -231,20 +231,20 @@
 
 Filename: atoti_core/str_to_bool.py
 Comment: 
 
 Filename: atoti_core/table_identifier.py
 Comment: 
 
-Filename: atoti_core-0.8.2.dist-info/METADATA
+Filename: atoti_core-0.8.3.dist-info/METADATA
 Comment: 
 
-Filename: atoti_core-0.8.2.dist-info/WHEEL
+Filename: atoti_core-0.8.3.dist-info/WHEEL
 Comment: 
 
-Filename: atoti_core-0.8.2.dist-info/top_level.txt
+Filename: atoti_core-0.8.3.dist-info/top_level.txt
 Comment: 
 
-Filename: atoti_core-0.8.2.dist-info/RECORD
+Filename: atoti_core-0.8.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## atoti_core/LICENSE

```diff
@@ -1,8 +1,8 @@
-This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.2, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
+This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.3, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
 
 By requesting to have access to the Software, downloading or using the Software, End User acknowledges that he/she and End Customer has understood and agreed with the terms of this EULA.
 If End Customer does not accept these terms, End User must not use the Software.
 
 End Customer and ActiveViam are hereinafter individually or collectively referred to as the "PARTY (IES)".
 
 1. Purpose & description of the Software
```

## atoti_core/_link.py

```diff
@@ -38,15 +38,15 @@
                 "sessionLocation": self._session_location,
             }
         }
 
         is_local = urlparse(url).hostname == "localhost"
 
         if is_local:
-            note = "This is the session's local URL: it may not be reachable if Atoti is running on a remote machine."
+            note = "This is the session's local URL: it may not be reachable if Atoti is running on another machine."
 
             bundle[MARKDOWN_MIME_TYPE] = dedent(
                 f"""\
                 {url}
 
                 _Note_: {note}
                 """
```

## atoti_core/_other_identifier.py

```diff
@@ -1,5 +1,5 @@
 from typing import TypeVar
 
 from .identifier import Identifier
 
-OtherIdentifierT = TypeVar("OtherIdentifierT", bound=Identifier, covariant=True)
+OtherIdentifierT_co = TypeVar("OtherIdentifierT_co", bound=Identifier, covariant=True)
```

## atoti_core/base_cube.py

```diff
@@ -5,58 +5,58 @@
 from datetime import timedelta
 from typing import Any, Generic, Literal, Optional, TypeVar
 
 import pandas as pd
 
 from .base_hierarchies import BaseHierarchiesBound
 from .base_level import BaseLevel
-from .base_levels import BaseLevelsBound, HierarchiesT
+from .base_levels import BaseLevelsBound, HierarchiesT_co
 from .base_measure import BaseMeasure
 from .base_measures import BaseMeasuresBound
 from .context import Context
 from .default_query_timeout import DEFAULT_QUERY_TIMEOUT
 from .empty_mapping import EMPTY_MAPPING
 from .query_filter import QueryFilter
 from .repr_json import ReprJson, ReprJsonable
 from .scenario import BASE_SCENARIO_NAME
 
-LevelsT = TypeVar("LevelsT", bound=BaseLevelsBound, covariant=True)
-MeasuresT = TypeVar("MeasuresT", bound=BaseMeasuresBound, covariant=True)
+LevelsT_co = TypeVar("LevelsT_co", bound=BaseLevelsBound, covariant=True)
+MeasuresT_co = TypeVar("MeasuresT_co", bound=BaseMeasuresBound, covariant=True)
 
 
 class BaseCube(
-    Generic[HierarchiesT, LevelsT, MeasuresT],
+    Generic[HierarchiesT_co, LevelsT_co, MeasuresT_co],
     ReprJsonable,
 ):
     def __init__(
-        self, name: str, /, *, hierarchies: HierarchiesT, measures: MeasuresT
+        self, name: str, /, *, hierarchies: HierarchiesT_co, measures: MeasuresT_co
     ) -> None:
         super().__init__()
 
         self._hierarchies = hierarchies
         self._measures = measures
         self._name = name
 
     @property
     def name(self) -> str:
         """Name of the cube."""
         return self._name
 
     @property
     @abstractmethod
-    def levels(self) -> LevelsT:
+    def levels(self) -> LevelsT_co:
         """Levels of the cube."""
 
     @property
-    def measures(self) -> MeasuresT:
+    def measures(self) -> MeasuresT_co:
         """Measures of the cube."""
         return self._measures
 
     @property
-    def hierarchies(self) -> HierarchiesT:
+    def hierarchies(self) -> HierarchiesT_co:
         """Hierarchies of the cube."""
         return self._hierarchies
 
     @abstractmethod
     def query(
         self,
         *measures: BaseMeasure,
```

## atoti_core/base_cubes.py

```diff
@@ -1,17 +1,17 @@
 from collections.abc import Mapping
 from typing import TypeVar
 
 from .base_cube import BaseCubeBound
 from .repr_json import ReprJson, ReprJsonable
 
-CubeT = TypeVar("CubeT", bound=BaseCubeBound, covariant=True)
+CubeT_co = TypeVar("CubeT_co", bound=BaseCubeBound, covariant=True)
 
 
-class BaseCubes(Mapping[str, CubeT], ReprJsonable):
+class BaseCubes(Mapping[str, CubeT_co], ReprJsonable):
     def _repr_json_(self) -> ReprJson:
         """Return the JSON representation of cubes."""
         return (
             {name: cube._repr_json_()[0] for name, cube in sorted(self.items())},
             {"expanded": False, "root": "Cubes"},
         )
```

## atoti_core/base_hierarchies.py

```diff
@@ -1,33 +1,34 @@
 from __future__ import annotations
 
 from abc import abstractmethod
+from collections import defaultdict
 from collections.abc import Iterable, Mapping
 from typing import Optional, TypeVar, Union
 
 from .base_hierarchy import BaseHierarchyBound
 from .hierarchy_identifier import HierarchyIdentifier
 from .hierarchy_key import HierarchyKey
 from .repr_json import ReprJson, ReprJsonable
 
-HierarchyT = TypeVar("HierarchyT", bound=BaseHierarchyBound, covariant=True)
+HierarchyT_co = TypeVar("HierarchyT_co", bound=BaseHierarchyBound, covariant=True)
 
 
-class BaseHierarchies(Mapping[tuple[str, str], HierarchyT], ReprJsonable):
+class BaseHierarchies(Mapping[tuple[str, str], HierarchyT_co], ReprJsonable):
     """Manage the base hierarchies."""
 
     @abstractmethod
-    def __getitem__(self, key: HierarchyKey, /) -> HierarchyT:
+    def __getitem__(self, key: HierarchyKey, /) -> HierarchyT_co:
         """Return the hierarchy with the given name."""
 
     def _repr_json_(self) -> ReprJson:
         """Return the JSON representation of hierarchies."""
-        dimensions: dict[str, list[HierarchyT]] = {}
+        dimensions: dict[str, list[HierarchyT_co]] = defaultdict(list)
         for hierarchy in self.values():
-            dimensions.setdefault(hierarchy.dimension, []).append(hierarchy)
+            dimensions[hierarchy.dimension].append(hierarchy)
         json = {
             dimension: dict(
                 sorted(
                     {
                         hierarchy._repr_json_()[1]["root"]: hierarchy._repr_json_()[0]
                         for hierarchy in dimension_hierarchies
                     }.items()
@@ -44,15 +45,15 @@
             return (None, key)
 
         return key
 
     @staticmethod
     def _multiple_hierarchies_error(
         key: HierarchyKey,
-        hierarchies: Union[Iterable[HierarchyT], Iterable[HierarchyIdentifier]],
+        hierarchies: Union[Iterable[HierarchyT_co], Iterable[HierarchyIdentifier]],
     ) -> KeyError:
         return KeyError(
             f"""Multiple hierarchies with name {key}. Specify the dimension: {", ".join([
             f'cube.hierarchies["{hierarchy.dimension_name}", "{hierarchy.dimension_name}"]'if isinstance(hierarchy, HierarchyIdentifier) else f'cube.hierarchies["{hierarchy.dimension}", "{hierarchy.name}"]'
             for hierarchy in hierarchies
         ])}"""
         )
```

## atoti_core/base_hierarchy.py

```diff
@@ -8,18 +8,20 @@
 from .constant import Constant, ConstantValue
 from .has_identifier import HasIdentifier
 from .hierarchy_identifier import HierarchyIdentifier
 from .hierarchy_isin_condition import HierarchyIsinCondition
 from .operation import Condition
 from .repr_json import ReprJson, ReprJsonable
 
-LevelT = TypeVar("LevelT", bound=BaseLevel, covariant=True)
+LevelT_co = TypeVar("LevelT_co", bound=BaseLevel, covariant=True)
 
 
-class BaseHierarchy(Generic[LevelT], HasIdentifier[HierarchyIdentifier], ReprJsonable):
+class BaseHierarchy(
+    Generic[LevelT_co], HasIdentifier[HierarchyIdentifier], ReprJsonable
+):
     def __init__(self, identifier: HierarchyIdentifier, /) -> None:
         super().__init__()
 
         self.__identifier = identifier
 
     @property
     def name(self) -> str:
@@ -33,15 +35,15 @@
         A dimension is a logical group of attributes (e.g. :guilabel:`Geography`).
         It can be thought of as a folder containing hierarchies.
         """
         return self._identifier.dimension_name
 
     @property
     @abstractmethod
-    def levels(self) -> Mapping[str, LevelT]:
+    def levels(self) -> Mapping[str, LevelT_co]:
         """Levels of the hierarchy."""
 
     @property
     @abstractmethod
     def slicing(self) -> bool:
         """Whether the hierarchy is slicing or not.
```

## atoti_core/base_levels.py

```diff
@@ -3,50 +3,50 @@
 import operator
 from abc import abstractmethod
 from collections.abc import Iterator, Mapping
 from itertools import chain
 from typing import Generic, Optional, TypeVar, cast
 
 from .base_hierarchies import BaseHierarchiesBound
-from .base_hierarchy import LevelT
+from .base_hierarchy import LevelT_co
 from .base_level import BaseLevel
 from .ipython_key_completions import (
     IPythonKeyCompletions,
     get_ipython_key_completions_for_mapping,
 )
 from .level_key import LevelKey
 from .repr_json import ReprJson, ReprJsonable
 
-HierarchiesT = TypeVar("HierarchiesT", bound=BaseHierarchiesBound, covariant=True)
+HierarchiesT_co = TypeVar("HierarchiesT_co", bound=BaseHierarchiesBound, covariant=True)
 
 
 class BaseLevels(
-    Generic[HierarchiesT, LevelT], Mapping[LevelKey, LevelT], ReprJsonable
+    Generic[HierarchiesT_co, LevelT_co], Mapping[LevelKey, LevelT_co], ReprJsonable
 ):
     """Base class to manipulate flattened levels."""
 
-    def __init__(self, *, hierarchies: HierarchiesT) -> None:
+    def __init__(self, *, hierarchies: HierarchiesT_co) -> None:
         super().__init__()
 
         self._hierarchies = hierarchies
 
-    def _flatten(self) -> dict[str, Optional[LevelT]]:
-        flat_levels: dict[str, Optional[LevelT]] = {}
+    def _flatten(self) -> dict[str, Optional[LevelT_co]]:
+        flat_levels: dict[str, Optional[LevelT_co]] = {}
         for hierarchy in self._hierarchies.values():
             for level in hierarchy.levels.values():
                 if level.name in flat_levels:
                     # None is used as a flag to mark levels appearing in multiple hierarchies.
                     # When it happens, the user must use a tuple to retrieve the level.
                     # Like that: (hierarchy name, level name).
                     flat_levels[level.name] = None
                 else:
                     flat_levels[level.name] = level  # type: ignore[assignment] # pyright: ignore[reportGeneralTypeIssues]
         return flat_levels
 
-    def __getitem__(self, key: LevelKey, /) -> LevelT:
+    def __getitem__(self, key: LevelKey, /) -> LevelT_co:
         """Return the level with the given key."""
         if isinstance(key, str):
             return self._find_level(key)
 
         if len(key) == 2:  # noqa: PLR2004
             return self._find_level(key[1], hierarchy_name=key[0])
 
@@ -58,15 +58,15 @@
     @abstractmethod
     def _find_level(
         self,
         level_name: str,
         *,
         dimension_name: Optional[str] = None,
         hierarchy_name: Optional[str] = None,
-    ) -> LevelT:
+    ) -> LevelT_co:
         """Get a level from the hierarchy name and level name."""
 
     def __iter__(
         self,
     ) -> Iterator[LevelKey]:
         """Return the iterator on all the levels."""
         return chain(
```

## atoti_core/base_measures.py

```diff
@@ -1,32 +1,33 @@
+from collections import defaultdict
 from collections.abc import Mapping
 from typing import Any, TypeVar
 
 from .base_measure import BaseMeasure
 from .repr_json import ReprJson, ReprJsonable
 
-MeasureT = TypeVar("MeasureT", bound=BaseMeasure, covariant=True)
+MeasureT_co = TypeVar("MeasureT_co", bound=BaseMeasure, covariant=True)
 
 
-class BaseMeasures(Mapping[str, MeasureT], ReprJsonable):
+class BaseMeasures(Mapping[str, MeasureT_co], ReprJsonable):
     def _repr_json_(self) -> ReprJson:
         """Return the JSON representation of measures."""
-        measures_json: dict[str, dict[str, Any]] = {}
+        measures_json: dict[str, dict[str, Any]] = defaultdict(dict)
         no_folder = {}
         for measure in self.values():
             if measure.visible:
                 json = {"formatter": measure.formatter}
                 if measure.description is not None:
                     json["description"] = measure.description
                 if measure.folder is None:
                     # We store them into another dict to insert them after the folders
                     no_folder[measure.name] = json
                 else:
                     folder = f"ðŸ“ {measure.folder}"
-                    measures_json.setdefault(folder, {})[measure.name] = json
+                    measures_json[folder][measure.name] = json
         for folder, measures_in_folder in measures_json.items():
             measures_json[folder] = dict(sorted(measures_in_folder.items()))
         return (
             {**measures_json, **dict(sorted(no_folder.items()))},
             {"expanded": False, "root": "Measures"},
         )
```

## atoti_core/base_session.py

```diff
@@ -20,27 +20,27 @@
 from .find_corresponding_top_level_variable_name import (
     find_corresponding_top_level_variable_name,
 )
 from .missing_plugin_error import MissingPluginError
 from .query_doc import QUERY_ARGS_DOC
 from .repr_json import ReprJson, ReprJsonable
 
-CubesT = TypeVar("CubesT", bound=BaseCubesBound, covariant=True)
-_SecurityT = TypeVar("_SecurityT", covariant=True)
+CubesT_co = TypeVar("CubesT_co", bound=BaseCubesBound, covariant=True)
+_SecurityT_co = TypeVar("_SecurityT_co", covariant=True)
 
 
 def _generate_session_id() -> str:
     random_string = "".join(
         # No cryptographic security required.
         random.choices(string.ascii_uppercase + string.digits, k=6)  # noqa: S311
     )
     return f"{int(time())}_{random_string}"
 
 
-class BaseSession(Generic[CubesT, _SecurityT], ReprJsonable):
+class BaseSession(Generic[CubesT_co, _SecurityT_co], ReprJsonable):
     """Base class for session."""
 
     def __init__(self) -> None:
         self.__id = _generate_session_id()
 
         def visualize(
             session: BaseSessionBound,  # noqa: ARG001
@@ -67,15 +67,15 @@
         *,
         path: str = "",
     ) -> object:
         """Display a link to this session.
 
         If the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin is:
 
-        * not enabled, the session's local URL will be used so the link may not be reachable if Atoti is running on a remote machine.
+        * not enabled, the session's local URL will be used so the link may not be reachable if Atoti is running on another machine.
           In that situation, the session may be reached from ``f{public_ip_or_domain_of_machine_hosting_atoti}:{session.port}`` (see :meth:`atoti.Session.port`).
         * enabled, the JupyterLab extension will try to access the session through (in this order):
 
             #. `Jupyter Server Proxy <https://jupyter-server-proxy.readthedocs.io/>`__ if it is enabled.
             #. ``f"{session_protocol}//{jupyter_server_hostname}:{session.port}"`` for :class:`~atoti.Session` and ``session.url`` for :class:`~atoti_query.QuerySession`.
 
         Args:
@@ -94,20 +94,20 @@
             path=path,
             session_local_url=self._local_url,
             session_location=self._location,
         )
 
     @property
     @abstractmethod
-    def cubes(self) -> CubesT:
+    def cubes(self) -> CubesT_co:
         """Cubes of the session."""
 
     @property
     @abstractmethod
-    def _security(self) -> _SecurityT:
+    def _security(self) -> _SecurityT_co:
         ...
 
     @property
     @abstractmethod
     def _local_url(self) -> str:
         """URL that can be used to access the session on the host machine's network."""
```

## atoti_core/combine_conditions.py

```diff
@@ -2,36 +2,36 @@
 from typing import Literal, TypeVar, Union, overload
 
 from .boolean_operator import BooleanOperator
 from .operation import (
     CombinedCondition,
     Condition,
     ConditionCombinationOperatorBound,
-    ConditionCombinationOperatorT,
-    ConditionComparisonOperatorT,
-    ConditionSubjectT,
-    ConditionTargetT,
+    ConditionCombinationOperatorT_co,
+    ConditionComparisonOperatorT_co,
+    ConditionSubjectT_co,
+    ConditionTargetT_co,
 )
 
 _BooleanOperatorT = TypeVar("_BooleanOperatorT", bound=BooleanOperator)
 
 
 def _combine_conditions(
     *conditions: Condition[
-        ConditionSubjectT,
-        ConditionComparisonOperatorT,
-        ConditionTargetT,
-        ConditionCombinationOperatorT,
+        ConditionSubjectT_co,
+        ConditionComparisonOperatorT_co,
+        ConditionTargetT_co,
+        ConditionCombinationOperatorT_co,
     ],
     operator: _BooleanOperatorT,
 ) -> Condition[
-    ConditionSubjectT,
-    ConditionComparisonOperatorT,
-    ConditionTargetT,
-    Union[ConditionCombinationOperatorT, _BooleanOperatorT],
+    ConditionSubjectT_co,
+    ConditionComparisonOperatorT_co,
+    ConditionTargetT_co,
+    Union[ConditionCombinationOperatorT_co, _BooleanOperatorT],
 ]:
     if not conditions:
         raise ValueError("No conditions to combine.")
 
     iterator = iter(conditions)
     condition = next(iterator)
 
@@ -49,92 +49,92 @@
 
 @overload
 # If the top level collection has a single element, the operator `or` will not be used, only `and`.
 def combine_conditions(
     conditions: tuple[
         Collection[
             Condition[
-                ConditionSubjectT,
-                ConditionComparisonOperatorT,
-                ConditionTargetT,
-                ConditionCombinationOperatorT,
+                ConditionSubjectT_co,
+                ConditionComparisonOperatorT_co,
+                ConditionTargetT_co,
+                ConditionCombinationOperatorT_co,
             ]
         ]
     ],
     /,
 ) -> Condition[
-    ConditionSubjectT,
-    ConditionComparisonOperatorT,
-    ConditionTargetT,
-    Union[ConditionCombinationOperatorT, Literal["and"]],
+    ConditionSubjectT_co,
+    ConditionComparisonOperatorT_co,
+    ConditionTargetT_co,
+    Union[ConditionCombinationOperatorT_co, Literal["and"]],
 ]:
     ...
 
 
 @overload
 # If all the bottom level collections have a single element, the operator `and` will not be used, only `or`.
 def combine_conditions(
     conditions: Collection[
         tuple[
             Condition[
-                ConditionSubjectT,
-                ConditionComparisonOperatorT,
-                ConditionTargetT,
-                ConditionCombinationOperatorT,
+                ConditionSubjectT_co,
+                ConditionComparisonOperatorT_co,
+                ConditionTargetT_co,
+                ConditionCombinationOperatorT_co,
             ]
         ]
     ],
     /,
 ) -> Condition[
-    ConditionSubjectT,
-    ConditionComparisonOperatorT,
-    ConditionTargetT,
-    Union[ConditionCombinationOperatorT, Literal["or"]],
+    ConditionSubjectT_co,
+    ConditionComparisonOperatorT_co,
+    ConditionTargetT_co,
+    Union[ConditionCombinationOperatorT_co, Literal["or"]],
 ]:
     ...
 
 
 @overload
 def combine_conditions(
     conditions: Collection[
         Collection[
             Condition[
-                ConditionSubjectT,
-                ConditionComparisonOperatorT,
-                ConditionTargetT,
+                ConditionSubjectT_co,
+                ConditionComparisonOperatorT_co,
+                ConditionTargetT_co,
                 ConditionCombinationOperatorBound,
             ]
         ]
     ],
     /,
 ) -> Condition[
-    ConditionSubjectT,
-    ConditionComparisonOperatorT,
-    ConditionTargetT,
+    ConditionSubjectT_co,
+    ConditionComparisonOperatorT_co,
+    ConditionTargetT_co,
     ConditionCombinationOperatorBound,
 ]:
     ...
 
 
 def combine_conditions(
     conditions: Collection[
         Collection[
             Condition[
-                ConditionSubjectT,
-                ConditionComparisonOperatorT,
-                ConditionTargetT,
+                ConditionSubjectT_co,
+                ConditionComparisonOperatorT_co,
+                ConditionTargetT_co,
                 ConditionCombinationOperatorBound,
             ]
         ]
     ],
     /,
 ) -> Condition[
-    ConditionSubjectT,
-    ConditionComparisonOperatorT,
-    ConditionTargetT,
+    ConditionSubjectT_co,
+    ConditionComparisonOperatorT_co,
+    ConditionTargetT_co,
     ConditionCombinationOperatorBound,
 ]:
     """Take conditions structured in disjunctive normal form and return a single combined condition."""
     return _combine_conditions(
         *(
             _combine_conditions(*conjunct_conditions, operator="and")
             for conjunct_conditions in conditions
```

## atoti_core/condition_to_dict.py

```diff
@@ -1,28 +1,28 @@
 from typing import Literal, Optional
 
 from .condition_to_pairs import condition_to_pairs
-from .has_identifier import IdentifierT
-from .operation import Condition, ConditionTargetT
+from .has_identifier import IdentifierT_co
+from .operation import Condition, ConditionTargetT_co
 
 
 def condition_to_dict(
     condition: Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["eq"],
-        ConditionTargetT,
+        ConditionTargetT_co,
         Optional[Literal["and"]],
     ],
     /,
-) -> dict[IdentifierT, ConditionTargetT]:
+) -> dict[IdentifierT_co, ConditionTargetT_co]:
     pairs = condition_to_pairs(condition)
-    result: dict[IdentifierT, ConditionTargetT] = {}
+    result: dict[IdentifierT_co, ConditionTargetT_co] = {}
 
     for identifier, target in pairs:
         if identifier in result:
             raise ValueError(
-                f"Expected the combined condition to have distinct subjects but got `{identifier}` twice."
+                f"Expected the combined condition to have distinct subjects but got `{identifier!r}` twice."
             )
 
         result[identifier] = target
 
     return result
```

## atoti_core/condition_to_pairs.py

```diff
@@ -1,30 +1,33 @@
 from typing import Literal, Optional, cast
 
 from .decombine_condition import decombine_condition
 from .operation import (
     ComparisonCondition,
     Condition,
-    ConditionSubjectT,
-    ConditionTargetT,
+    ConditionSubjectT_co,
+    ConditionTargetT_co,
 )
 
 
 def condition_to_pairs(
     condition: Condition[
-        ConditionSubjectT,
+        ConditionSubjectT_co,
         Literal["eq"],
-        ConditionTargetT,
+        ConditionTargetT_co,
         Optional[Literal["and"]],
     ],
     /,
-) -> list[tuple[ConditionSubjectT, ConditionTargetT]]:
+) -> list[tuple[ConditionSubjectT_co, ConditionTargetT_co]]:
     comparison_conditions = cast(
         tuple[
-            ComparisonCondition[ConditionSubjectT, Literal["eq"], ConditionTargetT], ...
+            ComparisonCondition[
+                ConditionSubjectT_co, Literal["eq"], ConditionTargetT_co
+            ],
+            ...,
         ],
         decombine_condition(
             condition,
             allowed_comparison_operators=("eq",),
             allowed_combination_operators=("and",),
             allowed_isin_element_types=(),
         )[0][0],
```

## atoti_core/decombine_condition.py

```diff
@@ -1,100 +1,101 @@
+from collections import defaultdict
 from itertools import chain, product
 from typing import TypeVar, cast
 
 from .boolean_operator import ALL_BOOLEAN_OPERATORS, BooleanOperator
 from .comparison_operator import ALL_COMPARISON_OPERATORS, ComparisonOperator
 from .constant import Constant
 from .hierarchy_isin_condition import HierarchyIsinCondition
 from .identifier import Identifier
-from .isin_condition import IsinCondition, IsinConditionElementT
+from .isin_condition import IsinCondition, IsinConditionElementT_co
 from .operation import (
     CombinedCondition,
     ComparisonCondition,
     ConditionBound,
     ConditionSubjectBound,
-    ConditionSubjectT,
-    ConditionTargetT,
+    ConditionSubjectT_co,
+    ConditionTargetT_co,
     Operation,
 )
 
 _CombinationOperatorT = TypeVar("_CombinationOperatorT", bound=BooleanOperator)
 
 
-_ComparisonOperatorT = TypeVar(
-    "_ComparisonOperatorT", bound=ComparisonOperator, covariant=True
+_ComparisonOperatorT_co = TypeVar(
+    "_ComparisonOperatorT_co", bound=ComparisonOperator, covariant=True
 )
 
 
 def _check_subject(
     subject: ConditionSubjectBound,
     /,
     *,
-    allowed_types: tuple[type[ConditionSubjectT], ...],
-) -> ConditionSubjectT:
+    allowed_types: tuple[type[ConditionSubjectT_co], ...],
+) -> ConditionSubjectT_co:
     if not isinstance(subject, allowed_types):
         raise TypeError(
             f"Expected the type of the condition's subject to be one of `{tuple(allowed_type.__name__ for allowed_type in allowed_types)}` but got `{type(subject).__name__}`."
         )
-    # If the `isinstance()` above returned `True`, thanks to the type of `allowed_types`, `subject` is guaranteed to be a `ConditionSubjectT`.
+    # If the `isinstance()` above returned `True`, thanks to the type of `allowed_types`, `subject` is guaranteed to be a `ConditionSubjectT_co`.
     return subject  # type: ignore[return-value]
 
 
 _NONE_TYPE = type(None)
 
 
 def decombine_condition(  # noqa: C901, PLR0912
     condition: ConditionBound,
     /,
     *,
     allowed_subject_types: tuple[
-        type[ConditionSubjectT],
+        type[ConditionSubjectT_co],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
         Identifier,
         Operation,
     ),
     allowed_comparison_operators: tuple[
-        _ComparisonOperatorT,
+        _ComparisonOperatorT_co,
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = ALL_COMPARISON_OPERATORS,  # type: ignore[assignment]
     allowed_target_types: tuple[
-        type[ConditionTargetT],
+        type[ConditionTargetT_co],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
         _NONE_TYPE,
         Constant,
         Identifier,
         Operation,
     ),
     allowed_combination_operators: tuple[
         _CombinationOperatorT,
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = ALL_BOOLEAN_OPERATORS,  # type: ignore[assignment]
     allowed_isin_element_types: tuple[
-        type[IsinConditionElementT],
+        type[IsinConditionElementT_co],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
         _NONE_TYPE,
         Constant,
     ),
 ) -> tuple[
     tuple[
         tuple[
             ComparisonCondition[
-                ConditionSubjectT, _ComparisonOperatorT, ConditionTargetT
+                ConditionSubjectT_co, _ComparisonOperatorT_co, ConditionTargetT_co
             ],
             ...,
         ],
-        tuple[IsinCondition[ConditionSubjectT, IsinConditionElementT], ...],
+        tuple[IsinCondition[ConditionSubjectT_co, IsinConditionElementT_co], ...],
         tuple[HierarchyIsinCondition, ...],
     ],
     ...,
 ]:
     """Return the conditions in disjunctive normal form.
 
     For example: ``c1 & (c2 | c3)`` will return ``((c_1, c_2), (c_1, c_3))``.
@@ -107,15 +108,15 @@
         subject = _check_subject(condition.subject, allowed_types=allowed_subject_types)
 
         operator = condition.operator
         if operator not in allowed_comparison_operators:
             raise ValueError(
                 f"Expected `{ComparisonCondition.__name__}`'s operator to be one of `{allowed_comparison_operators}` but got `{operator}`."
             )
-        operator = cast(_ComparisonOperatorT, operator)
+        operator = cast(_ComparisonOperatorT_co, operator)
 
         target = condition.target
         if not isinstance(target, allowed_target_types):
             raise TypeError(
                 f"Expected the type of `{ComparisonCondition.__name__}`'s target to be one of `{tuple(allowed_type.__name__ for allowed_type in allowed_target_types)}` but got `{type(target).__name__}`."
             )
 
@@ -141,15 +142,15 @@
 
         elements = condition.elements
         for element in elements:
             if not isinstance(element, allowed_isin_element_types):
                 raise TypeError(
                     f"Expected the type of the `{IsinCondition.__name__}`'s elements to be one of `{tuple(allowed_type.__name__ for allowed_type in allowed_isin_element_types)}` but got `{type(element).__name__}`."
                 )
-        elements = cast(tuple[IsinConditionElementT, ...], elements)
+        elements = cast(tuple[IsinConditionElementT_co, ...], elements)
 
         return (((), (IsinCondition(subject=subject, elements=elements),), ()),)
 
     if isinstance(condition, HierarchyIsinCondition):
         if not allowed_isin_element_types:
             raise TypeError(
                 f"Expected no `isin` condition but got a `{type(condition).__name__}`."
@@ -196,54 +197,62 @@
             ]
         )
 
         decombined_conditions: list[
             tuple[
                 tuple[
                     ComparisonCondition[
-                        ConditionSubjectT, _ComparisonOperatorT, ConditionTargetT
+                        ConditionSubjectT_co,
+                        _ComparisonOperatorT_co,
+                        ConditionTargetT_co,
                     ],
                     ...,
                 ],
-                tuple[IsinCondition[ConditionSubjectT, IsinConditionElementT], ...],
+                tuple[
+                    IsinCondition[ConditionSubjectT_co, IsinConditionElementT_co], ...
+                ],
                 tuple[HierarchyIsinCondition, ...],
             ],
         ] = []
 
         for normalized_conditions in (
             chain(*mixed_decombined_conditions)
             for mixed_decombined_conditions in product(
                 mixed_first_decombined_conditions, mixed_second_decombined_conditions
             )
         ):
-            type_to_conditions: dict[type[ConditionBound], list[ConditionBound]] = {}
+            type_to_conditions: dict[
+                type[ConditionBound], list[ConditionBound]
+            ] = defaultdict(list)
 
             for normalized_condition in normalized_conditions:
-                type_to_conditions.setdefault(type(normalized_condition), []).append(
+                type_to_conditions[type(normalized_condition)].append(
                     normalized_condition
                 )
 
             decombined_conditions.append(
                 (
                     tuple(
                         cast(
                             list[
                                 ComparisonCondition[
-                                    ConditionSubjectT,
-                                    _ComparisonOperatorT,
-                                    ConditionTargetT,
+                                    ConditionSubjectT_co,
+                                    _ComparisonOperatorT_co,
+                                    ConditionTargetT_co,
                                 ],
                             ],
                             type_to_conditions.get(ComparisonCondition, []),
                         )
                     ),
                     tuple(
                         cast(
                             list[
-                                IsinCondition[ConditionSubjectT, IsinConditionElementT]
+                                IsinCondition[
+                                    ConditionSubjectT_co, IsinConditionElementT_co
+                                ]
                             ],
                             type_to_conditions.get(IsinCondition, []),
                         )
                     ),
                     tuple(
                         cast(
                             list[HierarchyIsinCondition],
```

## atoti_core/doc.py

```diff
@@ -1,11 +1,10 @@
 from __future__ import annotations
 
 from collections.abc import Callable
-from functools import wraps
 from textwrap import dedent
 from typing import Any, TypeVar, Union, cast
 
 from typing_extensions import ParamSpec
 
 _P = ParamSpec("_P")
 _R = TypeVar("_R")
@@ -15,43 +14,29 @@
 # https://github.com/pandas-dev/pandas/blame/8aa707298428801199280b2b994632080591700a/pandas/util/_decorators.py#L332
 def doc(
     *args: Union[str, Callable[..., Any]], **kwargs: str
 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]:
     """Take docstring templates, concatenate them and perform string substitution."""
 
     def decorator(function: Callable[_P, _R]) -> Callable[_P, _R]:
-        @wraps(function)
-        def wrapper(*args: _P.args, **kwargs: _P.kwargs) -> Any:
-            return function(*args, **kwargs)
-
-        # Collecting docstring and docstring templates
         docstring_components: list[Union[str, Callable[..., Any]]] = []
 
         if function.__doc__:
             docstring_components.append(dedent(function.__doc__))
 
-        for arg in cast(Any, args):
-            if hasattr(arg, "_docstring_components"):
-                docstring_components.extend(
-                    cast(
-                        Any,
-                        arg,
-                    )._docstring_components
-                )
-            elif isinstance(arg, str) or arg.__doc__:
-                docstring_components.append(arg)
+        docstring_components.extend(
+            arg for arg in cast(Any, args) if isinstance(arg, str) or arg.__doc__
+        )
 
         # Formatting templates and concatenating docstring
-        wrapper.__doc__ = "".join(
+        function.__doc__ = "".join(
             [
                 arg.format(**kwargs)
                 if isinstance(arg, str)
                 else dedent(arg.__doc__ or "")
                 for arg in docstring_components
             ]
         )
 
-        wrapper._docstring_components = docstring_components  # type: ignore[attr-defined] # pyright: ignore[reportGeneralTypeIssues]
-
-        return wrapper
+        return function
 
     return decorator
```

## atoti_core/get_identifier.py

```diff
@@ -1,13 +1,13 @@
 from typing import Union
 
-from .has_identifier import HasIdentifier, IdentifierT
+from .has_identifier import HasIdentifier, IdentifierT_co
 
 
 def get_identifier(
-    identifiable: Union[HasIdentifier[IdentifierT], IdentifierT], /
-) -> IdentifierT:
+    identifiable: Union[HasIdentifier[IdentifierT_co], IdentifierT_co], /
+) -> IdentifierT_co:
     return (
         identifiable._identifier
         if isinstance(identifiable, HasIdentifier)
         else identifiable
     )
```

## atoti_core/has_identifier.py

```diff
@@ -1,16 +1,16 @@
 from abc import ABC, abstractmethod
 from typing import Generic, TypeVar
 
 from .identifier import Identifier
 
-IdentifierT = TypeVar("IdentifierT", bound=Identifier, covariant=True)
+IdentifierT_co = TypeVar("IdentifierT_co", bound=Identifier, covariant=True)
 
 
-class HasIdentifier(Generic[IdentifierT], ABC):
+class HasIdentifier(Generic[IdentifierT_co], ABC):
     @property
     @abstractmethod
-    def _identifier(self) -> IdentifierT:
+    def _identifier(self) -> IdentifierT_co:
         ...
 
 
 HasIdentifierBound = HasIdentifier[Identifier]
```

## atoti_core/hierarchy_identifier.py

```diff
@@ -1,8 +1,9 @@
 from dataclasses import dataclass
+from functools import cached_property
 
 from typing_extensions import Self
 
 from .identifier import Identifier
 
 
 @dataclass(frozen=True)
@@ -11,13 +12,17 @@
     hierarchy_name: str
 
     @classmethod
     def from_java_description(cls, java_description: str, /) -> Self:
         hierarchy_name, dimension_name = java_description.split("@")
         return cls(dimension_name, hierarchy_name)
 
-    @property
+    @cached_property
+    def java_description(self) -> str:
+        return "@".join(reversed(self.key))
+
+    @cached_property
     def key(self) -> tuple[str, str]:
         return self.dimension_name, self.hierarchy_name
 
     def __repr__(self) -> str:
         return f"h[{self.key}]"
```

## atoti_core/identifiable.py

```diff
@@ -1,5 +1,5 @@
 from typing import Union
 
-from .has_identifier import HasIdentifier, IdentifierT
+from .has_identifier import HasIdentifier, IdentifierT_co
 
-Identifiable = Union[HasIdentifier[IdentifierT], IdentifierT]
+Identifiable = Union[HasIdentifier[IdentifierT_co], IdentifierT_co]
```

## atoti_core/identifier.py

```diff
@@ -1,16 +1,10 @@
 from abc import ABC, abstractmethod
-from functools import cached_property
 
 
 class Identifier(ABC):
-    @property
     @abstractmethod
-    def key(self) -> tuple[str, ...]:
+    def __repr__(self) -> str:
         ...
 
-    @cached_property
-    def java_description(self) -> str:
-        return "@".join(reversed(self.key))
-
     def __str__(self) -> str:
-        return str(self.key)
+        return repr(self)
```

## atoti_core/identifier_like.py

```diff
@@ -1,5 +1,5 @@
 from typing import Union
 
-from .has_identifier import HasIdentifier, IdentifierT
+from .has_identifier import HasIdentifier, IdentifierT_co
 
-IdentifierLike = Union[HasIdentifier[IdentifierT], IdentifierT]
+IdentifierLike = Union[HasIdentifier[IdentifierT_co], IdentifierT_co]
```

## atoti_core/identify.py

```diff
@@ -1,13 +1,13 @@
 from typing import Union
 
-from .has_identifier import HasIdentifier, IdentifierT
+from .has_identifier import HasIdentifier, IdentifierT_co
 
 
 def identify(
-    identifiable: Union[HasIdentifier[IdentifierT], IdentifierT], /
-) -> IdentifierT:
+    identifiable: Union[HasIdentifier[IdentifierT_co], IdentifierT_co], /
+) -> IdentifierT_co:
     return (
         identifiable._identifier
         if isinstance(identifiable, HasIdentifier)
         else identifiable
     )
```

## atoti_core/isin_condition.py

```diff
@@ -8,73 +8,79 @@
 from .hierarchy_identifier import HierarchyIdentifier
 from .identifier import Identifier
 from .operation import (
     ComparisonCondition,
     Condition,
     ConditionCombinationOperatorBound,
     ConditionComparisonOperatorBound,
-    ConditionSubjectT,
+    ConditionSubjectT_co,
 )
 
-IsinConditionElementT = TypeVar(
-    "IsinConditionElementT", bound=Optional[Constant], covariant=True
+IsinConditionElementT_co = TypeVar(
+    "IsinConditionElementT_co", bound=Optional[Constant], covariant=True
 )
 
 
 @dataclass(frozen=True)
 class IsinCondition(
-    Condition[ConditionSubjectT, Literal["isin"], IsinConditionElementT, None]
+    Condition[ConditionSubjectT_co, Literal["isin"], IsinConditionElementT_co, None]
 ):
-    subject: ConditionSubjectT
-    _elements: frozenset[IsinConditionElementT]
+    subject: ConditionSubjectT_co
+    _elements: frozenset[IsinConditionElementT_co]
 
     def __init__(
-        self, *, subject: ConditionSubjectT, elements: Iterable[IsinConditionElementT]
+        self,
+        *,
+        subject: ConditionSubjectT_co,
+        elements: Iterable[IsinConditionElementT_co],
     ) -> None:
         assert not isinstance(
             subject, HierarchyIdentifier
         ), "Conditions on hierarchies must use `HierarchyIsinCondition`."
 
         if not elements:
             raise ValueError(
                 "No passed elements, the condition will always evaluate to `False`."
             )
 
         self.__dict__["subject"] = subject
         self.__dict__["_elements"] = frozenset(elements)
 
     @cached_property
-    def elements(self) -> tuple[IsinConditionElementT, ...]:
+    def elements(self) -> tuple[IsinConditionElementT_co, ...]:
         # The elements are sorted to ensure predictability.
         return (
             # Collections containing `None` cannot be sorted.
             # If `None` is in the elements it's added at the head of the tuple.
             # The remaining non-`None` elements are sorted and inserted after.
             *([None] if None in self._elements else []),  # type: ignore[arg-type] # pyright: ignore[reportGeneralTypeIssues]
             *sorted(element for element in self._elements if element is not None),  # type: ignore[type-var]
         )
 
     @cached_property
     def normalized(
         self,
     ) -> Condition[
-        ConditionSubjectT, Literal["eq", "isin"], IsinConditionElementT, None
+        ConditionSubjectT_co, Literal["eq", "isin"], IsinConditionElementT_co, None
     ]:
         if len(self.elements) != 1:
             return self
 
         return ComparisonCondition(
             subject=self.subject, operator="eq", target=self.elements[0]
         )
 
     @property
     def combined_comparison_condition(
         self,
     ) -> Condition[
-        ConditionSubjectT, Literal["eq"], IsinConditionElementT, Optional[Literal["or"]]
+        ConditionSubjectT_co,
+        Literal["eq"],
+        IsinConditionElementT_co,
+        Optional[Literal["or"]],
     ]:
         return combine_conditions(
             [
                 (
                     ComparisonCondition(
                         subject=self.subject, operator="eq", target=element
                     ),
@@ -86,17 +92,17 @@
     @property
     def _identifier_types(self) -> frozenset[type[Identifier]]:
         return self._get_identifier_types(self.subject)
 
     def __invert__(
         self,
     ) -> Condition[
-        ConditionSubjectT,
+        ConditionSubjectT_co,
         ConditionComparisonOperatorBound,
-        IsinConditionElementT,
+        IsinConditionElementT_co,
         ConditionCombinationOperatorBound,
     ]:
         return ~self.combined_comparison_condition
 
     def __repr__(self) -> str:
         return f"{self.subject!r}.isin{tuple(element.value if isinstance(element, Constant) else element for element in self.elements)!r}"
```

## atoti_core/keyword_only_dataclass.py

```diff
@@ -1,28 +1,31 @@
+from __future__ import annotations
+
 from dataclasses import is_dataclass
 from functools import wraps
+from inspect import isclass
 from typing import Any, TypeVar
 
 _T = TypeVar("_T")
 
 
-def keyword_only_dataclass(cls: type[_T]) -> type[_T]:
+def keyword_only_dataclass(cls: _T) -> _T:
     """Decorate a dataclass to force its construction to be done with keyword-only parameters.
 
     Replace with func:`dataclasses.dataclass`'s *kw_only* when bumping minimum supported version of Python to 3.10.
     """
     assert is_dataclass(cls), f"Expected a dataclass but received {cls}."
+    assert isclass(cls)
     init = cls.__init__
 
     @wraps(init)
     def init_enforcing_keyword_only_arguments(
         self: _T, *args: Any, **kwargs: Any
     ) -> None:
         assert (
             len(args) == 0
         ), f"{cls.__name__} expects keyword-only arguments but the following positional arguments were passed: {args}."
-        init(self, **kwargs)  # pyright: ignore[reportGeneralTypeIssues]
+        init(self, **kwargs)
 
     setattr(cls, "__init__", init_enforcing_keyword_only_arguments)  # noqa: B010
 
-    # Mypy reports `got "Type[DataclassInstance]", expected "Type[_T]"`.
-    return cls  # type: ignore[return-value]
+    return cls  # type: ignore[return-value] # pyright: ignore[reportGeneralTypeIssues]
```

## atoti_core/level_identifier.py

```diff
@@ -1,8 +1,9 @@
 from dataclasses import dataclass
+from functools import cached_property
 
 from typing_extensions import Self
 
 from .hierarchy_identifier import HierarchyIdentifier
 from .identifier import Identifier
 
 
@@ -12,13 +13,17 @@
     level_name: str
 
     @classmethod
     def from_java_description(cls, java_description: str, /) -> Self:
         level_name, hierarchy_name, dimension_name = java_description.split("@")
         return cls(HierarchyIdentifier(dimension_name, hierarchy_name), level_name)
 
-    @property
+    @cached_property
+    def java_description(self) -> str:
+        return "@".join(reversed(self.key))
+
+    @cached_property
     def key(self) -> tuple[str, str, str]:
         return *self.hierarchy_identifier.key, self.level_name
 
     def __repr__(self) -> str:
         return f"l[{self.key}]"
```

## atoti_core/measure_identifier.py

```diff
@@ -13,13 +13,9 @@
                 f"Invalid measure name `{self.measure_name}`: `,` is not allowed."
             )
         if self.measure_name != self.measure_name.strip():
             raise ValueError(
                 f"Invalid measure name `{self.measure_name}`: leading or trailing whitespaces are not allowed."
             )
 
-    @property
-    def key(self) -> tuple[str]:
-        return (self.measure_name,)
-
     def __repr__(self) -> str:
         return f"""m["{self.measure_name}"]"""
```

## atoti_core/operand_convertible_with_identifier.py

```diff
@@ -1,340 +1,340 @@
 from __future__ import annotations
 
 from typing import Literal, Union, overload
 
-from ._other_identifier import OtherIdentifierT
+from ._other_identifier import OtherIdentifierT_co
 from .constant import Constant, ConstantValue
-from .has_identifier import HasIdentifier, IdentifierT
+from .has_identifier import HasIdentifier, IdentifierT_co
 from .operation import (
     ComparisonCondition,
     Condition,
     OperandConvertible,
     Operation,
     convert_to_operand,
 )
 
 
 class OperandConvertibleWithIdentifier(
-    OperandConvertible[IdentifierT],
-    HasIdentifier[IdentifierT],
+    OperandConvertible[IdentifierT_co],
+    HasIdentifier[IdentifierT_co],
 ):
     """This class overrides `OperandConvertible`'s `Condition`-creating methods so that the type of the returned `Condition`'s `subject` is narrowed down to an instance of `Identifier` instead of a `Union[Identifier, Operation]`.
 
     The returned `Condition`'s `target` is also kept as narrow as possible thanks to `@overload`s.
     """
 
     # Without this, the classes inheriting from this class are considered unhashable.
     def __hash__(self) -> int:
         return super().__hash__()
 
     def isnull(
         self,
-    ) -> Condition[IdentifierT, Literal["eq"], None, None]:
+    ) -> Condition[IdentifierT_co, Literal["eq"], None, None]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="eq",
             target=None,
         )
 
     @property
-    def _operation_operand(self) -> IdentifierT:
+    def _operation_operand(self) -> IdentifierT_co:
         return self._identifier
 
     # The signature is not compatible with `object.__eq__()` on purpose.
     @overload  # type: ignore[override]
     def __eq__(
         self, other: ConstantValue, /
-    ) -> Condition[IdentifierT, Literal["eq"], Constant, None]:
+    ) -> Condition[IdentifierT_co, Literal["eq"], Constant, None]:
         ...
 
     @overload
     def __eq__(
-        self, other: HasIdentifier[OtherIdentifierT], /
-    ) -> Condition[IdentifierT, Literal["eq"], OtherIdentifierT, None]:
+        self, other: HasIdentifier[OtherIdentifierT_co], /
+    ) -> Condition[IdentifierT_co, Literal["eq"], OtherIdentifierT_co, None]:
         ...
 
     @overload
     def __eq__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["eq"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         ...
 
     # The signature is not compatible with `object.__eq__()` on purpose.
     def __eq__(  # pyright: ignore[reportIncompatibleMethodOverride]
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["eq"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         assert other is not None, "Use `isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             target=convert_to_operand(other),
             operator="eq",
         )
 
     @overload
     def __ge__(
         self, other: ConstantValue, /
-    ) -> Condition[IdentifierT, Literal["ge"], Constant, None]:
+    ) -> Condition[IdentifierT_co, Literal["ge"], Constant, None]:
         ...
 
     @overload
     def __ge__(
-        self, other: HasIdentifier[OtherIdentifierT], /
-    ) -> Condition[IdentifierT, Literal["ge"], OtherIdentifierT, None]:
+        self, other: HasIdentifier[OtherIdentifierT_co], /
+    ) -> Condition[IdentifierT_co, Literal["ge"], OtherIdentifierT_co, None]:
         ...
 
     @overload
     def __ge__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["ge"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         ...
 
     def __ge__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["ge"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ge",
             target=convert_to_operand(other),
         )
 
     @overload
     def __gt__(
         self, other: ConstantValue, /
-    ) -> Condition[IdentifierT, Literal["gt"], Constant, None]:
+    ) -> Condition[IdentifierT_co, Literal["gt"], Constant, None]:
         ...
 
     @overload
     def __gt__(
-        self, other: HasIdentifier[OtherIdentifierT], /
-    ) -> Condition[IdentifierT, Literal["gt"], OtherIdentifierT, None]:
+        self, other: HasIdentifier[OtherIdentifierT_co], /
+    ) -> Condition[IdentifierT_co, Literal["gt"], OtherIdentifierT_co, None]:
         ...
 
     @overload
     def __gt__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["gt"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         ...
 
     def __gt__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["gt"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="gt",
             target=convert_to_operand(other),
         )
 
     @overload
     def __le__(
         self, other: ConstantValue, /
-    ) -> Condition[IdentifierT, Literal["le"], Constant, None]:
+    ) -> Condition[IdentifierT_co, Literal["le"], Constant, None]:
         ...
 
     @overload
     def __le__(
-        self, other: HasIdentifier[OtherIdentifierT], /
-    ) -> Condition[IdentifierT, Literal["le"], OtherIdentifierT, None]:
+        self, other: HasIdentifier[OtherIdentifierT_co], /
+    ) -> Condition[IdentifierT_co, Literal["le"], OtherIdentifierT_co, None]:
         ...
 
     @overload
     def __le__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["le"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         ...
 
     def __le__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["le"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="le",
             target=convert_to_operand(other),
         )
 
     @overload
     def __lt__(
         self, other: ConstantValue, /
-    ) -> Condition[IdentifierT, Literal["lt"], Constant, None]:
+    ) -> Condition[IdentifierT_co, Literal["lt"], Constant, None]:
         ...
 
     @overload
     def __lt__(
-        self, other: HasIdentifier[OtherIdentifierT], /
-    ) -> Condition[IdentifierT, Literal["lt"], OtherIdentifierT, None]:
+        self, other: HasIdentifier[OtherIdentifierT_co], /
+    ) -> Condition[IdentifierT_co, Literal["lt"], OtherIdentifierT_co, None]:
         ...
 
     @overload
     def __lt__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["lt"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         ...
 
     def __lt__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["lt"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="lt",
             target=convert_to_operand(other),
         )
 
     # The signature is not compatible with `object.__ne__()` on purpose.
     @overload  # type: ignore[override]
     def __ne__(
         self, other: ConstantValue, /
-    ) -> Condition[IdentifierT, Literal["ne"], Constant, None]:
+    ) -> Condition[IdentifierT_co, Literal["ne"], Constant, None]:
         ...
 
     @overload
     def __ne__(
-        self, other: HasIdentifier[OtherIdentifierT], /
-    ) -> Condition[IdentifierT, Literal["ne"], OtherIdentifierT, None]:
+        self, other: HasIdentifier[OtherIdentifierT_co], /
+    ) -> Condition[IdentifierT_co, Literal["ne"], OtherIdentifierT_co, None]:
         ...
 
     @overload
     def __ne__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["ne"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         ...
 
     # The signature is not compatible with `object.__ne__()` on purpose.
     def __ne__(  # pyright: ignore[reportIncompatibleMethodOverride]
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        IdentifierT,
+        IdentifierT_co,
         Literal["ne"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         assert other is not None, "Use `~isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ne",
             target=convert_to_operand(other),
```

## atoti_core/operation.py

```diff
@@ -11,21 +11,21 @@
     NoReturn,
     Optional,
     TypeVar,
     Union,
     overload,
 )
 
-from ._other_identifier import OtherIdentifierT
+from ._other_identifier import OtherIdentifierT_co
 from .arithmetic_operator import ArithmeticOperator
 from .boolean_operator import BooleanOperator
 from .comparison_operator import OPERATOR_TO_INVERSE_OPERATOR, ComparisonOperator
 from .constant import Constant, ConstantValue
 from .data_type import DataType
-from .has_identifier import HasIdentifier, IdentifierT
+from .has_identifier import HasIdentifier, IdentifierT_co
 from .hierarchy_identifier import HierarchyIdentifier
 from .identifier import Identifier
 from .keyword_only_dataclass import keyword_only_dataclass
 
 
 @overload
 def convert_to_operand(value: None, /) -> None:
@@ -34,59 +34,61 @@
 
 @overload
 def convert_to_operand(value: ConstantValue, /) -> Constant:
     ...
 
 
 @overload
-def convert_to_operand(value: HasIdentifier[IdentifierT], /) -> IdentifierT:
+def convert_to_operand(value: HasIdentifier[IdentifierT_co], /) -> IdentifierT_co:
     ...
 
 
 @overload
 def convert_to_operand(
-    value: OperandCondition[IdentifierT],
+    value: OperandCondition[IdentifierT_co],
     /,
-) -> OperandCondition[IdentifierT]:
+) -> OperandCondition[IdentifierT_co]:
     ...
 
 
 @overload
-def convert_to_operand(value: Operation[IdentifierT], /) -> Operation[IdentifierT]:
+def convert_to_operand(
+    value: Operation[IdentifierT_co], /
+) -> Operation[IdentifierT_co]:
     ...
 
 
 def convert_to_operand(
     value: Optional[
         Union[
-            OperandCondition[IdentifierT],
+            OperandCondition[IdentifierT_co],
             ConstantValue,
-            HasIdentifier[IdentifierT],
-            Operation[IdentifierT],
+            HasIdentifier[IdentifierT_co],
+            Operation[IdentifierT_co],
         ]
     ],
     /,
-) -> Optional[Operand[IdentifierT]]:
+) -> Optional[Operand[IdentifierT_co]]:
     if value is None or isinstance(value, (Condition, Operation)):
         return value
     if isinstance(value, HasIdentifier):
         return value._identifier
     return Constant(value)
 
 
-class OperandConvertible(Generic[IdentifierT], ABC):
+class OperandConvertible(Generic[IdentifierT_co], ABC):
     @property
     @abstractmethod
-    def _operation_operand(self) -> NonConstantNonConditionOperand[IdentifierT]:
+    def _operation_operand(self) -> NonConstantNonConditionOperand[IdentifierT_co]:
         ...
 
     def isnull(
         self,
     ) -> Condition[
-        NonConstantNonConditionOperand[IdentifierT], Literal["eq"], None, None
+        NonConstantNonConditionOperand[IdentifierT_co], Literal["eq"], None, None
     ]:
         """Return a condition evaluating to ``True`` when the element evaluates to ``None`` and ``False`` otherwise.
 
         Use `~obj.isnull()` for the opposite behavior.
         """
         return ComparisonCondition(
             subject=self._operation_operand,
@@ -107,19 +109,19 @@
 
     def __getitem__(
         self,
         index: Union[
             slice,
             int,
             tuple[int, ...],
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return IndexingOperation(
             operand=self._operation_operand,
             index=index._identifier
             if isinstance(index, HasIdentifier)
             else (
                 index
                 if isinstance(index, (slice, Operation))
@@ -128,329 +130,329 @@
         )
 
     # The signature is not compatible with `object.__eq__()` on purpose.
     def __eq__(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[IdentifierT],
+        NonConstantNonConditionOperand[IdentifierT_co],
         Literal["eq"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         assert other is not None, "Use `isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             target=convert_to_operand(other),
             operator="eq",
         )
 
     def __ge__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[IdentifierT],
+        NonConstantNonConditionOperand[IdentifierT_co],
         Literal["ge"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ge",
             target=convert_to_operand(other),
         )
 
     def __gt__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[IdentifierT],
+        NonConstantNonConditionOperand[IdentifierT_co],
         Literal["gt"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="gt",
             target=convert_to_operand(other),
         )
 
     def __le__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[IdentifierT],
+        NonConstantNonConditionOperand[IdentifierT_co],
         Literal["le"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="le",
             target=convert_to_operand(other),
         )
 
     def __lt__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[IdentifierT],
+        NonConstantNonConditionOperand[IdentifierT_co],
         Literal["lt"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="lt",
             target=convert_to_operand(other),
         )
 
     # The signature is not compatible with `object.__ne__()` on purpose.
     def __ne__(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[IdentifierT],
+        NonConstantNonConditionOperand[IdentifierT_co],
         Literal["ne"],
-        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
+        Union[Constant, OtherIdentifierT_co, Operation[OtherIdentifierT_co]],
         None,
     ]:
         assert other is not None, "Use `~isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ne",
             target=convert_to_operand(other),
         )
 
     def __add__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="add",
         )
 
     def __radd__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="add",
         )
 
     def __floordiv__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="floordiv",
         )
 
     def __rfloordiv__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="floordiv",
         )
 
     def __mod__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="mod",
         )
 
     def __rmod__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="mod",
         )
 
     def __mul__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="mul",
         )
 
     def __rmul__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="mul",
         )
 
     def __neg__(
         self,
-    ) -> Operation[IdentifierT]:
+    ) -> Operation[IdentifierT_co]:
         return ArithmeticOperation(operands=(self._operation_operand,), operator="neg")
 
     def __pow__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="pow",
         )
 
     def __rpow__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="pow",
         )
 
     def __sub__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="sub",
         )
 
     def __rsub__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="sub",
         )
 
     def __truediv__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="truediv",
         )
 
     def __rtruediv__(
         self,
         other: Union[
             ConstantValue,
-            HasIdentifier[OtherIdentifierT],
-            Operation[OtherIdentifierT],
+            HasIdentifier[OtherIdentifierT_co],
+            Operation[OtherIdentifierT_co],
         ],
         /,
-    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
+    ) -> Operation[Union[IdentifierT_co, OtherIdentifierT_co]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="truediv",
         )
 
 
 OperandConvertibleBound = OperandConvertible[Identifier]
@@ -483,145 +485,145 @@
             return frozenset()
         if isinstance(operand, Identifier):
             return frozenset([type(operand)])
         return operand._identifier_types
 
 
 class Operation(
-    OperandConvertible[IdentifierT],
+    OperandConvertible[IdentifierT_co],
     _BaseOperation,
 ):
     @property
-    def _operation_operand(self) -> Operation[IdentifierT]:
+    def _operation_operand(self) -> Operation[IdentifierT_co]:
         return self
 
 
 OperationBound = Operation[Identifier]
 
 # The following classes can be constructed from any `OperandConvertible` using Python's built-in operators.
 # Because overriding these operators requires to implement methods on `OperandConvertible` instantiating the classes below, they all have to be declared in the same file to avoid circular imports.
 
 
 ConditionSubjectBound = Union[Identifier, OperationBound]
-ConditionSubjectT = TypeVar(
-    "ConditionSubjectT", bound=ConditionSubjectBound, covariant=True
+ConditionSubjectT_co = TypeVar(
+    "ConditionSubjectT_co", bound=ConditionSubjectBound, covariant=True
 )
 
 ConditionComparisonOperatorBound = Literal[ComparisonOperator, "isin"]
-ConditionComparisonOperatorT = TypeVar(
-    "ConditionComparisonOperatorT",
+ConditionComparisonOperatorT_co = TypeVar(
+    "ConditionComparisonOperatorT_co",
     bound=ConditionComparisonOperatorBound,
     covariant=True,
 )
 
 ConditionTargetBound = Optional[Union[Constant, Identifier, OperationBound]]
-ConditionTargetT = TypeVar(
-    "ConditionTargetT", bound=ConditionTargetBound, covariant=True
+ConditionTargetT_co = TypeVar(
+    "ConditionTargetT_co", bound=ConditionTargetBound, covariant=True
 )
 
 ConditionCombinationOperatorBound = Optional[BooleanOperator]
-ConditionCombinationOperatorT = TypeVar(
-    "ConditionCombinationOperatorT",
+ConditionCombinationOperatorT_co = TypeVar(
+    "ConditionCombinationOperatorT_co",
     bound=ConditionCombinationOperatorBound,
     covariant=True,
 )
 
-_OtherConditionSubjectT = TypeVar(
-    "_OtherConditionSubjectT", bound=ConditionSubjectBound, covariant=True
+_OtherConditionSubjectT_co = TypeVar(
+    "_OtherConditionSubjectT_co", bound=ConditionSubjectBound, covariant=True
 )
-_OtherConditionComparisonOperatorT = TypeVar(
-    "_OtherConditionComparisonOperatorT",
+_OtherConditionComparisonOperatorT_co = TypeVar(
+    "_OtherConditionComparisonOperatorT_co",
     bound=ConditionComparisonOperatorBound,
     covariant=True,
 )
-_OtherConditionTargetT = TypeVar(
-    "_OtherConditionTargetT", bound=ConditionTargetBound, covariant=True
+_OtherConditionTargetT_co = TypeVar(
+    "_OtherConditionTargetT_co", bound=ConditionTargetBound, covariant=True
 )
-_OtherConditionCombinationOperatorT = TypeVar(
-    "_OtherConditionCombinationOperatorT",
+_OtherConditionCombinationOperatorT_co = TypeVar(
+    "_OtherConditionCombinationOperatorT_co",
     bound=ConditionCombinationOperatorBound,
     covariant=True,
 )
 
 
 class Condition(
     Generic[
-        ConditionSubjectT,
-        ConditionComparisonOperatorT,
-        ConditionTargetT,
-        ConditionCombinationOperatorT,
+        ConditionSubjectT_co,
+        ConditionComparisonOperatorT_co,
+        ConditionTargetT_co,
+        ConditionCombinationOperatorT_co,
     ],
     _BaseOperation,
     ABC,
 ):
     def __and__(
         self,
         other: Condition[
-            _OtherConditionSubjectT,
-            _OtherConditionComparisonOperatorT,
-            _OtherConditionTargetT,
-            _OtherConditionCombinationOperatorT,
+            _OtherConditionSubjectT_co,
+            _OtherConditionComparisonOperatorT_co,
+            _OtherConditionTargetT_co,
+            _OtherConditionCombinationOperatorT_co,
         ],
         /,
     ) -> CombinedCondition[
-        Union[ConditionSubjectT, _OtherConditionSubjectT],
-        Union[ConditionComparisonOperatorT, _OtherConditionComparisonOperatorT],
-        Union[ConditionTargetT, _OtherConditionTargetT],
+        Union[ConditionSubjectT_co, _OtherConditionSubjectT_co],
+        Union[ConditionComparisonOperatorT_co, _OtherConditionComparisonOperatorT_co],
+        Union[ConditionTargetT_co, _OtherConditionTargetT_co],
         Union[
             Literal["and"],
-            ConditionCombinationOperatorT,
-            _OtherConditionCombinationOperatorT,
+            ConditionCombinationOperatorT_co,
+            _OtherConditionCombinationOperatorT_co,
         ],
     ]:
         return CombinedCondition(sub_conditions=(self, other), operator="and")
 
     def __bool__(self) -> NoReturn:
         raise AssertionError(
             "Conditions cannot be cast to a boolean as they are only evaluated during query execution. To combine conditions, use the bitwise `&`, `|`, or `~` operators."
         )
 
     @abstractmethod
     def __invert__(
         self,
     ) -> Condition[
-        ConditionSubjectT,
+        ConditionSubjectT_co,
         ConditionComparisonOperatorBound,
-        ConditionTargetT,
+        ConditionTargetT_co,
         ConditionCombinationOperatorBound,
     ]:
         ...
 
     def __or__(
         self,
         other: Condition[
-            _OtherConditionSubjectT,
-            _OtherConditionComparisonOperatorT,
-            _OtherConditionTargetT,
-            _OtherConditionCombinationOperatorT,
+            _OtherConditionSubjectT_co,
+            _OtherConditionComparisonOperatorT_co,
+            _OtherConditionTargetT_co,
+            _OtherConditionCombinationOperatorT_co,
         ],
         /,
     ) -> CombinedCondition[
-        Union[ConditionSubjectT, _OtherConditionSubjectT],
-        Union[ConditionComparisonOperatorT, _OtherConditionComparisonOperatorT],
-        Union[ConditionTargetT, _OtherConditionTargetT],
+        Union[ConditionSubjectT_co, _OtherConditionSubjectT_co],
+        Union[ConditionComparisonOperatorT_co, _OtherConditionComparisonOperatorT_co],
+        Union[ConditionTargetT_co, _OtherConditionTargetT_co],
         Union[
             Literal["or"],
-            ConditionCombinationOperatorT,
-            _OtherConditionCombinationOperatorT,
+            ConditionCombinationOperatorT_co,
+            _OtherConditionCombinationOperatorT_co,
         ],
     ]:
         return CombinedCondition(sub_conditions=(self, other), operator="or")
 
     def __xor__(
         self,
         other: Condition[
-            _OtherConditionSubjectT,
-            _OtherConditionComparisonOperatorT,
-            _OtherConditionTargetT,
-            _OtherConditionCombinationOperatorT,
+            _OtherConditionSubjectT_co,
+            _OtherConditionComparisonOperatorT_co,
+            _OtherConditionTargetT_co,
+            _OtherConditionCombinationOperatorT_co,
         ],
         /,
     ) -> NoReturn:
         raise AssertionError("Conditions cannot be `xor`ed.")
 
 
 ConditionBound = Condition[
@@ -632,35 +634,35 @@
 ]
 
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class CombinedCondition(
     Condition[
-        ConditionSubjectT,
-        ConditionComparisonOperatorT,
-        ConditionTargetT,
-        ConditionCombinationOperatorT,
+        ConditionSubjectT_co,
+        ConditionComparisonOperatorT_co,
+        ConditionTargetT_co,
+        ConditionCombinationOperatorT_co,
     ]
 ):
     sub_conditions: tuple[
         Condition[
-            ConditionSubjectT,
-            ConditionComparisonOperatorT,
-            ConditionTargetT,
-            ConditionCombinationOperatorT,
+            ConditionSubjectT_co,
+            ConditionComparisonOperatorT_co,
+            ConditionTargetT_co,
+            ConditionCombinationOperatorT_co,
         ],
         Condition[
-            ConditionSubjectT,
-            ConditionComparisonOperatorT,
-            ConditionTargetT,
-            ConditionCombinationOperatorT,
+            ConditionSubjectT_co,
+            ConditionComparisonOperatorT_co,
+            ConditionTargetT_co,
+            ConditionCombinationOperatorT_co,
         ],
     ]
-    operator: ConditionCombinationOperatorT
+    operator: ConditionCombinationOperatorT_co
 
     def __post_init__(self) -> None:
         # Access the `boolean_operator` property to trigger the validation process.
         assert self.boolean_operator
 
     @cached_property
     def boolean_operator(self) -> BooleanOperator:
@@ -669,17 +671,17 @@
         assert operator is not None, "Missing combination operator."
 
         return operator
 
     def __invert__(
         self,
     ) -> Condition[
-        ConditionSubjectT,
+        ConditionSubjectT_co,
         ConditionComparisonOperatorBound,
-        ConditionTargetT,
+        ConditionTargetT_co,
         ConditionCombinationOperatorBound,
     ]:
         return CombinedCondition(
             sub_conditions=(~self.sub_conditions[0], ~self.sub_conditions[1]),
             operator="or" if self.operator == "and" else "and",
         )
 
@@ -694,16 +696,16 @@
             )
         )
 
     def __repr__(self) -> str:
         return f"({self.sub_conditions[0]!r}) {'&' if self.operator == 'and' else '|'} ({self.sub_conditions[1]!r})"
 
 
-_ComparisonOperatorT = TypeVar(
-    "_ComparisonOperatorT",
+_ComparisonOperatorT_co = TypeVar(
+    "_ComparisonOperatorT_co",
     bound=ComparisonOperator,
     covariant=True,
 )
 
 _COMPARISON_OPERATOR_TO_SYMBOL: Mapping[ComparisonOperator, str] = {
     "eq": "==",
     "ge": ">=",
@@ -713,19 +715,19 @@
     "ne": "!=",
 }
 
 
 @keyword_only_dataclass
 @dataclass(frozen=True)
 class ComparisonCondition(
-    Condition[ConditionSubjectT, _ComparisonOperatorT, ConditionTargetT, None]
+    Condition[ConditionSubjectT_co, _ComparisonOperatorT_co, ConditionTargetT_co, None]
 ):
-    subject: ConditionSubjectT
-    operator: _ComparisonOperatorT
-    target: ConditionTargetT
+    subject: ConditionSubjectT_co
+    operator: _ComparisonOperatorT_co
+    target: ConditionTargetT_co
 
     def __post_init__(self) -> None:
         assert not isinstance(
             self.subject, HierarchyIdentifier
         ), "Conditions on hierarchies must use `HierarchyIsinCondition`."
 
         if self.target is None and self.operator not in {"eq", "ne"}:
@@ -742,15 +744,15 @@
                     for operand in [self.subject, self.target]
                 )
             )
         )
 
     def __invert__(
         self,
-    ) -> Condition[ConditionSubjectT, ComparisonOperator, ConditionTargetT, None]:
+    ) -> Condition[ConditionSubjectT_co, ComparisonOperator, ConditionTargetT_co, None]:
         return ComparisonCondition(
             subject=self.subject,
             operator=OPERATOR_TO_INVERSE_OPERATOR[self.operator],
             target=self.target,
         )
 
     def __repr__(self) -> str:
@@ -766,16 +768,16 @@
     "sub": "-",
     "truediv": "/",
 }
 
 
 @keyword_only_dataclass
 @dataclass(eq=False, frozen=True)
-class ArithmeticOperation(Operation[IdentifierT]):
-    operands: tuple[NonConditionOperand[IdentifierT], ...]
+class ArithmeticOperation(Operation[IdentifierT_co]):
+    operands: tuple[NonConditionOperand[IdentifierT_co], ...]
     operator: ArithmeticOperator
 
     @property
     def _identifier_types(self) -> frozenset[type[Identifier]]:
         return frozenset(
             chain(*(self._get_identifier_types(operand) for operand in self.operands))
         )
@@ -797,21 +799,21 @@
             if operation_is_function_call_result
             else f"({operand_representation})"
         )
 
 
 @keyword_only_dataclass
 @dataclass(eq=False, frozen=True)
-class IndexingOperation(Operation[IdentifierT]):
-    operand: NonConstantNonConditionOperand[IdentifierT]
+class IndexingOperation(Operation[IdentifierT_co]):
+    operand: NonConstantNonConditionOperand[IdentifierT_co]
     index: Union[
         Constant,
         slice,
-        IdentifierT,
-        Operation[IdentifierT],
+        IdentifierT_co,
+        Operation[IdentifierT_co],
     ]
 
     def __post_init__(self) -> None:
         allowed_data_types: tuple[DataType, ...] = ("int", "int[]", "long", "long[]")
 
         if (
             isinstance(self.index, Constant)
@@ -829,21 +831,21 @@
             else self._get_identifier_types(self.index)
         )
 
     def __repr__(self) -> str:
         return f"{self.operand!r}[{self.index!r}]"
 
 
-NonConstantNonConditionOperand = Union[IdentifierT, Operation[IdentifierT]]
-NonConditionOperand = Union[Constant, NonConstantNonConditionOperand[IdentifierT]]
+NonConstantNonConditionOperand = Union[IdentifierT_co, Operation[IdentifierT_co]]
+NonConditionOperand = Union[Constant, NonConstantNonConditionOperand[IdentifierT_co]]
 
 OperandCondition = Condition[
-    NonConstantNonConditionOperand[IdentifierT],
+    NonConstantNonConditionOperand[IdentifierT_co],
     ConditionComparisonOperatorBound,
-    Optional[NonConditionOperand[IdentifierT]],
+    Optional[NonConditionOperand[IdentifierT_co]],
     ConditionCombinationOperatorBound,
 ]
 
 NonConstantOperand = Union[
-    NonConstantNonConditionOperand[IdentifierT], OperandCondition[IdentifierT]
+    NonConstantNonConditionOperand[IdentifierT_co], OperandCondition[IdentifierT_co]
 ]
-Operand = Union[Constant, NonConstantOperand[IdentifierT]]
+Operand = Union[Constant, NonConstantOperand[IdentifierT_co]]
```

## atoti_core/plugin.py

```diff
@@ -8,17 +8,26 @@
 
 class Plugin:
     @property
     def app_extensions(self) -> Mapping[str, Union[str, Path]]:
         """The app extensions contributed by the plugin to be added to the session configuration."""
         return EMPTY_MAPPING
 
-    def init_session(self, session: BaseSessionBound, /) -> None:
-        """Handle newly initialized session."""
-
     @property
     def jar_path(self) -> Optional[Path]:
         """The path to the plugin's JAR.
 
         When not ``None``, the JAR will be added to the classpath of the Java process.
         """
         return None
+
+    @property
+    def java_package_name(self) -> Optional[str]:
+        """The fully qualified name of the plugin's Java package.
+
+        When not ``None``, the `init()` method of its class named like this Python class will be called before starting the application.
+        """
+        return None
+
+    def post_init_session(self, session: BaseSessionBound, /) -> None:
+        """Hook called at the end of *session*'s initialization."""
+        ...
```

## Comparing `atoti_core-0.8.2.dist-info/METADATA` & `atoti_core-0.8.3.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: atoti-core
-Version: 0.8.2
+Version: 0.8.3
 Summary: Package containing private symbols shared by the other Atoti packages
 Home-page: https://www.atoti.io
 Author: ActiveViam
 Author-email: dev@atoti.io
 Keywords: atoti,core
 Classifier: Development Status :: 4 - Beta
 Classifier: License :: Free To Use But Restricted
```

## Comparing `atoti_core-0.8.2.dist-info/RECORD` & `atoti_core-0.8.3.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-atoti_core/LICENSE,sha256=JSyRUznwhVW6jj2RsFMZDaY_2QEQFMMOlbJvTy8OgOk,23472
+atoti_core/LICENSE,sha256=uj-cQ9LFo0v58DA-lc_SlI46k1rg1zHPkXQ_RNPB-bQ,23472
 atoti_core/__init__.py,sha256=uHM5zuc6B5_91WRdbo-xd8xPFt8ZnxAZF84UTUJZJPc,2490
 atoti_core/_get_endpoint_path.py,sha256=zmrlyiXz6APpXtMEAFb2-o3C82bAKGuTC6ZTjaSskf0,1679
-atoti_core/_link.py,sha256=ggyp5Jw-2-XVIMiNZ0gFe2anSRMcIcCZpniSSQpRBCA,1565
-atoti_core/_other_identifier.py,sha256=YWiRGiK8zNSi1MjDZrvtAFqKyHmBkGjuvJ-j-cRUbaU,145
+atoti_core/_link.py,sha256=LlUMKeecXWO6cC5FX353R50XAUNq6jUaI32MO__2zzg,1564
+atoti_core/_other_identifier.py,sha256=TS388rFzKBpjykChy2gxCqRJQT-3sysL7h9iwF1dl8k,151
 atoti_core/_server_versions.py,sha256=f2L-z8f3isTBH0fNttGgESTWKe62ZbofJ2Ay1DYw3AU,384
 atoti_core/activeviam_client.py,sha256=qEzCgjvP0HwnmSHXjzrNgc7lP2h8DUA8sXebIjH0KzM,8797
 atoti_core/arithmetic_operator.py,sha256=KXpKn1Zw2z_bxkW2VebZU_g6kWrBTTqeQTkEg0JxI08,128
-atoti_core/base_cube.py,sha256=cXn8jGSL6zRfDMKWzEIuhz45zdAMFEBs6R3CrpkT3ns,2437
-atoti_core/base_cubes.py,sha256=v05VbN41yBTEjFdhS3b05I8VqBmV_2qsjYZhff2INwQ,561
-atoti_core/base_hierarchies.py,sha256=JaQZJ8WuULcmBmiOdzmZ4azxjOl0UBpax9rTlUl1MOY,2273
-atoti_core/base_hierarchy.py,sha256=TrObNDpHg2yCey_5QEDRCughVtbX33Ik1u-xdOBQpfE,5672
+atoti_core/base_cube.py,sha256=nIxm5bVxHQJxn-QGhG1aTrbzGYTI_8w1f5LV3HADgQQ,2476
+atoti_core/base_cubes.py,sha256=_Rsdmxg2jyViDpp7tGBpoYeu2VrtXwV6eTmfh8-zEtk,570
+atoti_core/base_hierarchies.py,sha256=UH7cird2XDh86LjQjBEYGUwriCwPum9mVHNcxewgdYg,2327
+atoti_core/base_hierarchy.py,sha256=d8PtkyLB0ZN9XMaPNfCPgOvvtbRYinpgFxSH8r0Th1M,5690
 atoti_core/base_level.py,sha256=SppB6xmJDINc-R7i7BEBxyMqO4KMngPchfkQalda1v0,4989
-atoti_core/base_levels.py,sha256=RhYXjoqTdqswXu-odkcmtDl6R7q9EEyFlLRmXw2RkwY,3961
+atoti_core/base_levels.py,sha256=xb8b8224JgAEvMVMQzyLxPZ_wu6yULOtSxqHT_TMztg,3994
 atoti_core/base_measure.py,sha256=MLWzp2YvvkA823CKQtkrFp1ULs4XwXGEeL0NRY32Vis,2551
-atoti_core/base_measures.py,sha256=9v1yjAflQ_F2bkdG-BWBDEqBM9UGFpf8WFfjb_RDX94,1365
-atoti_core/base_session.py,sha256=fCwz2vuScEf7Uh_IHQdDwQMakcesJnGcaDLc0z85DmQ,11005
+atoti_core/base_measures.py,sha256=cb4hbsbhmnbU483C5w6AH1MnUSpdukuJB_-Zm3bfgDs,1410
+atoti_core/base_session.py,sha256=k5RXUGN8P5Ux3QctjPMrnRsRqZtvbnynQ4x-U-iaumg,11028
 atoti_core/boolean_operator.py,sha256=ibSEuUAGWYkFj8vsE22j4adXLkXIUsKS4_p9Fpyny88,221
 atoti_core/column_identifier.py,sha256=awh9TWAnourUfIV9X_Z_WOAcvNjcsCtp6pvJ5oKszQw,494
-atoti_core/combine_conditions.py,sha256=sZ_bmrorhcfPg8VT_dOxz7g4tl-wMgEyNqvFT0Q5WsM,3537
+atoti_core/combine_conditions.py,sha256=bKAX4B2vkAjHRpGw7LYE9KpH5vaZwIRqrgI3jM_-mLA,3657
 atoti_core/comparison_operator.py,sha256=UrFgPkRECKxU9wqcB45dloVYBrUGrZyAMGdN_Q4aii8,732
-atoti_core/condition_to_dict.py,sha256=zbXzfUQtmTNmyGybbdJ2McyQlDlnT5q290F4XYzD7u4,764
-atoti_core/condition_to_pairs.py,sha256=zQQWT70scCM8YGYXZxKC2tdZkKPNUB31nSx3CjYa09s,913
+atoti_core/condition_to_dict.py,sha256=iQ1lvUrv55-UMj06k-N59r_VlVMUjhTnx3hZ1-6pXx8,790
+atoti_core/condition_to_pairs.py,sha256=nCbCmOXe6sRL6GYUUgnVi0hqQLui90i-0X9R_xBnXDQ,980
 atoti_core/constant.py,sha256=-G09zKPly0G6wClLBp6KKQ1J0DMFSCRWvWdf_itYNs8,5240
 atoti_core/context.py,sha256=_vh7nlMabh6221vp0fcpZ35WAOAqsssG_DCQb3SeXVM,88
 atoti_core/convert_series.py,sha256=NAYgA_WspxiQztdWk0ch41TB3VPThiIxHBpo8-F5OIQ,3313
 atoti_core/create_dataframe.py,sha256=HJ5EaXfOPzgzQQXsui4KSubzkSIN60zSmYukOd-0R4c,1720
 atoti_core/data_type.py,sha256=UjVTL6mmwYFNUMkLJHQVE7DNy4VAngMLQfc9XIolV3c,3946
-atoti_core/decombine_condition.py,sha256=yI-uzoQ0DKVsPP7ChyplvvRuAFQzUqEWj-hmqtI8HnQ,9596
+atoti_core/decombine_condition.py,sha256=QkP6CVhpxZQaZUtfTMiyk2SYmkTNyU7pMWbAWtUEKYw,9906
 atoti_core/default_query_timeout.py,sha256=W5qgzdk26T0eoXVM6W2VC3nv7bKUwplM6wE8wl3qRiQ,78
 atoti_core/delegate_mutable_mapping.py,sha256=Q_HDEv3mKSoGUsZMaKLCaWr77cIlZNcTXbi_nREGRss,3191
 atoti_core/delegate_mutable_set.py,sha256=Wh54XQj4d63yVaiGN7xUdPkLUwuul0avd8xvvMrPQ-g,1325
 atoti_core/deprecated.py,sha256=Z9PKwNBfem77PUTqEJYUHZYNgK_s56A1gYOF4aDQ9yU,553
-atoti_core/doc.py,sha256=0yG7EWcSogqzwRAh_zLP9gBoayTQ-L-PY8i8_YOWHa4,1900
+atoti_core/doc.py,sha256=R8VcrPMTRjUBbHdqdNr9jrOl_MLq9-kEZX8aXe0sXA4,1293
 atoti_core/empty_mapping.py,sha256=i2jBPz404-PcpHoHusfQNv9kmEYP10Hzn7XB02F-sGc,165
 atoti_core/fetch_json.py,sha256=fvxOcK7YNwR-qZDM8lPsYYBSR7X-YG2JCLPqlzwmrqk,3471
 atoti_core/find_corresponding_top_level_variable_name.py,sha256=SOsU4RpW8Ix29C4aTIBIu-xacAGGIXBr5468b7XsVtU,590
 atoti_core/get_env_flag.py,sha256=vVc3jfLZEuvIDwvlENInkhMOMQtZrIUHMaGtbjMHIsg,326
-atoti_core/get_identifier.py,sha256=4rxxuyL0UsNyJ8qt0SH-8jrqQ_CeUQ2OuixWSJ2knCg,318
+atoti_core/get_identifier.py,sha256=bqjD9miHiPNuW4dTtMXqUvohyf7Lq1EqABxWjPFi8Og,330
 atoti_core/get_installed_plugins.py,sha256=eeeu0Er_udDLVfqupKiQ-4IkqDynFylyCBnfRK92MhE,1613
 atoti_core/get_ipython.py,sha256=n9B-amc65pSIZFf5ZdOR8goqvpkozP_QV5PVuF-EZx4,1008
 atoti_core/get_literal_args.py,sha256=Z3nRNgn-cu6KsBXm6QZP9_P5RNvMlaq1Bwzgf2UwH6A,2145
 atoti_core/get_package_version.py,sha256=w0QRERDT9e2S15aTujfv7py3QNkAf-Z5LxG0B3tqOcA,358
 atoti_core/get_top_level_package_name.py,sha256=RTsEgQWDzXL5WokrXDVzyK2GSsTf4XUbCOXgi08cq-w,265
-atoti_core/has_identifier.py,sha256=LpBFEXLhV-ykvr0zshktk5fpVtE6bJHLRtQsL7tZDXw,367
-atoti_core/hierarchy_identifier.py,sha256=RzzgHxdSiYC0mUim80agXEhw06hsSfhj7W6aU_06EF0,642
+atoti_core/has_identifier.py,sha256=S6L7Y8CJiS6FGbZn9Y9j0hlqi7t1yuso5vKRcm0sRTo,379
+atoti_core/hierarchy_identifier.py,sha256=Z3_18jEfmzeyM0YwCvKF3P0j0f_dtmD4nYcs46qt0oM,792
 atoti_core/hierarchy_isin_condition.py,sha256=g7VuAbge8AbUnNAOHSzCHqi7Ebs5lrheRudCXZXmNuU,3954
 atoti_core/hierarchy_key.py,sha256=9phdmKk2sp8q1GGsTZKpyiLM7-ojibRebA8FcBgQFpo,69
 atoti_core/http_method.py,sha256=wd2TYDjpLryll8PLHOWKP8nYZEDaG-iW4aim7PjSXho,109
-atoti_core/identifiable.py,sha256=AKysC9y9afOLgFIf2o5VCKQCF1tYRpwQmvURgjSF0Qs,144
-atoti_core/identifier.py,sha256=j2ur4ysQIGJ-v4d9I5yXUFhJZJXKvsLJhPK1kfC8TZ4,348
-atoti_core/identifier_like.py,sha256=nMN6LGnbLhabNGc9esuS0wBYPTR9Dxw1bfzV-6WuiGE,146
-atoti_core/identify.py,sha256=wRsGwqgRDPIGkccClLsEwlWyCQeSLXDDEjEbidU7dhc,312
+atoti_core/identifiable.py,sha256=MpmicOJUYDTHf_NQtKAcgq7gWhcWxBDjMQsZVSJu7ks,153
+atoti_core/identifier.py,sha256=zHq6Om1NWRK45KyVCv62oFuNSLkN0dGVv6TKMd2ReCs,181
+atoti_core/identifier_like.py,sha256=AVRhq_p_nKsIPurU-EEyEQ6jnSq04h_xaVxCid-v98o,155
+atoti_core/identify.py,sha256=kGDHT5_GFJAjF_yoSaqFkr8ENB-kk4wFmfMHL7R5yzA,324
 atoti_core/immutable_mapping.py,sha256=l_6zp5OO8uheyS91xlZvasdOjTR-IcN6Nd7xq7YoNmY,886
 atoti_core/ipython_key_completions.py,sha256=ur_ahskeZIkJlhVtUnKWvw9ZD80pFw6T8342bSyDdYk,404
-atoti_core/isin_condition.py,sha256=dV_zOcBsUnnAW4vVCBZIciRQ5rdnSatk4MRmkRR_TEA,3407
+atoti_core/isin_condition.py,sha256=gxOvCHkNnh6LEuOGOfmDbKHgHxf10bW3JuAJpoHKYJM,3505
 atoti_core/java_max_int.py,sha256=EPR4gNoGUOyaWAi6OnT2L_KutDLHQBpzOFMwWVwvtbQ,109
-atoti_core/keyword_only_dataclass.py,sha256=MVuE-zdwuCf7bcPj6eh8C2MkyiTnAzVxxuzMzhQaGoU,1055
-atoti_core/level_identifier.py,sha256=fBjExmd9VC0kzjncowfOY9suottu2xqhaSpdr94PJZg,767
+atoti_core/keyword_only_dataclass.py,sha256=_IMjjmL--uxNr1XPfSAkfarAtcOG-QZMggwvmpww3ug,1057
+atoti_core/level_identifier.py,sha256=C6iDaz7MbV79bOcTuzwzBZ7kWva7pXoj9ejuH_XQ0n0,917
 atoti_core/level_key.py,sha256=KJSltyI9tDw4I2Jyy7bnH74YcO0Qml-c5GtEuMFhrbo,102
 atoti_core/license_key.py,sha256=-CIVHH-Q0mCDHwdZPciTpSpeqDnt0958jTVLZOOe3dQ,637
-atoti_core/measure_identifier.py,sha256=-xWbp6QMnejDpe5LUIyeoEjPPCynp7vwwTLiAO9FxpY,777
+atoti_core/measure_identifier.py,sha256=v3HMUV7jfhsibuwagjBJlYJTiK1XPmnvmHZt9XVZ-Eg,693
 atoti_core/mime_type.py,sha256=5GZJ0QrOl-jigCwp_FLob5y96K3inJgHsmRuECSksss,295
 atoti_core/missing_plugin_error.py,sha256=tzuIKMAfNosWfSLjFh5NXQPzWxdI_uMFznLowMhD1Gk,282
-atoti_core/operand_convertible_with_identifier.py,sha256=lVcM1Cvnc14YwyTgjOXU9TfxY7KlRVHrQ8qSHFoU7i4,9041
-atoti_core/operation.py,sha256=azRQvP202ftQbglZ8TZ4QAzFCJIrIuKbTeaNztdpDXg,25370
+atoti_core/operand_convertible_with_identifier.py,sha256=mzvVUDrKSW8DJzmJxir54Tf_9dYbfZ_fD_0nc5P_wUo,9311
+atoti_core/operation.py,sha256=olHyGDIuid8AbuqHbWSlGQwt9gynpS4NVOz_o81uX_c,25967
 atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py,sha256=GtlR0Ow9OZWcfYEctr0NI1SwNei20YORnaWW01IS42Y,315
 atoti_core/path.py,sha256=477HG_h_YrE320S-Q5hwnlbCh9xjcthKVkmI0Mn7wVQ,180
-atoti_core/plugin.py,sha256=XwymA0gJ3UAM4iZ7QQ5ZyNd3suP7SWKZY3OV31JwoDI,738
+atoti_core/plugin.py,sha256=Q0DdYqC95NHe1cNi1LBPoKI2htjJWnZ-1-TQtFH8m-c,1076
 atoti_core/plugins.py,sha256=28ckZdVW3Rn_XmQ14MKMsa5Vj7zgQClv2Du7HSuMgq8,866
 atoti_core/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 atoti_core/query_doc.py,sha256=SZ81X9K2srZBJnZrhK5-HhUIIvZ26BwqhvwRs3hceqI,9949
 atoti_core/query_filter.py,sha256=AHuU6ZL4OOqmjunwaBnd4jAFZ7zTPsN9cXvDN4KtDj8,399
 atoti_core/raise_multiple_levels_with_same_name_error.py,sha256=J9lEGm-e52uYKDdtGxxnpTdHUduZionB0Njky4SpDp8,785
 atoti_core/reactive_mutable_set.py,sha256=vGQlNAiDnto2GWLdVhL6sM4qKRxdA8uqXm4NYMbUi14,2270
 atoti_core/repr_json.py,sha256=0M2H3k3A0AW-De2xt71MzgyFTFfWc9eQin_S5ZbCYiQ,2202
 atoti_core/scenario.py,sha256=Kp7RU9veySavOAG6mufEAjZPcBdh-m2P8MDpHY2Q4HE,28
 atoti_core/str_to_bool.py,sha256=Nq27fx8yRn3bDBcDr2ktT9emk-wlnBbNfRBOVLJfgmM,563
 atoti_core/table_identifier.py,sha256=gXWslfq_yJqe0sCzU8zaMHCsl12ZT8xmTVPU9Lg_FVQ,352
-atoti_core-0.8.2.dist-info/METADATA,sha256=xRLywPk-q6wbeAniBAWO2zov3q7VmLSWkPHXAaEngkk,855
-atoti_core-0.8.2.dist-info/WHEEL,sha256=8ngoJnqny485_Zhidm3gUHNLPQTUIjfhFb7Qoa0d3wA,109
-atoti_core-0.8.2.dist-info/top_level.txt,sha256=X4wSoqoZ3mCpyKACr5RpBXn4RbvtPqwcYyaJXAiLuy4,11
-atoti_core-0.8.2.dist-info/RECORD,,
+atoti_core-0.8.3.dist-info/METADATA,sha256=TluzYlfIle8KKbK7l4YrxxGekNnEUS4loXr6d2NoKQ8,855
+atoti_core-0.8.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+atoti_core-0.8.3.dist-info/top_level.txt,sha256=X4wSoqoZ3mCpyKACr5RpBXn4RbvtPqwcYyaJXAiLuy4,11
+atoti_core-0.8.3.dist-info/RECORD,,
```

