# Comparing `tmp/quarchCalibration-1.1.6.dev1-py2.py3-none-any.whl.zip` & `tmp/quarchCalibration-1.1.6.dev2-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,37 +1,37 @@
-Zip file size: 132776 bytes, number of entries: 35
--rw-rw-rw-  2.0 fat    25225 b- defN 23-Jul-17 13:56 quarchCalibration/BK9832B.py
--rw-rw-rw-  2.0 fat     7185 b- defN 23-Jul-17 13:56 quarchCalibration/ET2260.py
--rw-rw-rw-  2.0 fat    18660 b- defN 23-Jul-17 13:56 quarchCalibration/Keithley_DMM6500_control.py
--rw-rw-rw-  2.0 fat    19603 b- defN 23-Jul-17 13:56 quarchCalibration/Keysight_AC6804B_control.py
--rw-rw-rw-  2.0 fat    23554 b- defN 23-Jul-17 13:56 quarchCalibration/PowerModuleCalibration.py
--rw-rw-rw-  2.0 fat    68014 b- defN 23-Jul-17 13:56 quarchCalibration/QTL1944_06_hd_plus_ppm.py
--rw-rw-rw-  2.0 fat    65172 b- defN 23-Jul-17 13:56 quarchCalibration/QTL1944_hd_ppm.py
--rw-rw-rw-  2.0 fat    49330 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2347_pcie.py
--rw-rw-rw-  2.0 fat    39890 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2525_sff.py
--rw-rw-rw-  2.0 fat     2966 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2536_6_way_switchbox.py
--rw-rw-rw-  2.0 fat    40468 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2582_3ph_ac.py
--rw-rw-rw-  2.0 fat    39414 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2621_2ch_mezz.py
--rw-rw-rw-  2.0 fat    32603 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2626_4ch_mezz.py
--rw-rw-rw-  2.0 fat    33360 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2631_ext_mezz.py
--rw-rw-rw-  2.0 fat    37022 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2673_edsff.py
--rw-rw-rw-  2.0 fat    40449 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2843_iec_ac.py
--rw-rw-rw-  2.0 fat      632 b- defN 23-May-10 11:06 quarchCalibration/__init__.py
--rw-rw-rw-  2.0 fat       82 b- defN 23-Apr-05 12:46 quarchCalibration/__main__.py
--rw-rw-rw-  2.0 fat       26 b- defN 23-Jul-20 13:01 quarchCalibration/_version.py
--rw-rw-rw-  2.0 fat     6523 b- defN 23-Jul-17 13:56 quarchCalibration/acHelpers.py
--rw-rw-rw-  2.0 fat      713 b- defN 23-Apr-05 12:46 quarchCalibration/calibrationConfig.py
--rw-rw-rw-  2.0 fat    17889 b- defN 23-Jul-17 13:56 quarchCalibration/calibrationUtil.py
--rw-rw-rw-  2.0 fat     4126 b- defN 23-May-01 15:32 quarchCalibration/deviceHelpers.py
--rw-rw-rw-  2.0 fat     9958 b- defN 23-Jul-17 13:56 quarchCalibration/elpaSine.py
--rw-rw-rw-  2.0 fat    22184 b- defN 23-Apr-05 12:46 quarchCalibration/keithley_2460_control.py
--rw-rw-rw-  2.0 fat     9506 b- defN 23-Jul-17 13:56 quarchCalibration/noise_test.py
--rw-rw-rw-  2.0 fat    39461 b- defN 23-May-10 11:06 quarchCalibration/pamCommon.py
--rw-rw-rw-  2.0 fat     1072 b- defN 23-Jul-17 13:56 quarchCalibration/pamHelpers.py
--rw-rw-rw-  2.0 fat     7585 b- defN 23-Jul-17 13:56 quarchCalibration/threePhaseSwitchBox.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-05 12:46 quarchCalibration/docs/__init__.py
--rw-rw-rw-  2.0 fat     2076 b- defN 23-Apr-05 12:46 quarchCalibration/docs/conf.py
--rw-rw-rw-  2.0 fat     1567 b- defN 23-Jul-20 13:02 quarchCalibration-1.1.6.dev1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      110 b- defN 23-Jul-20 13:02 quarchCalibration-1.1.6.dev1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       18 b- defN 23-Jul-20 13:02 quarchCalibration-1.1.6.dev1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     3216 b- defN 23-Jul-20 13:02 quarchCalibration-1.1.6.dev1.dist-info/RECORD
-35 files, 669659 bytes uncompressed, 127554 bytes compressed:  81.0%
+Zip file size: 133172 bytes, number of entries: 35
+-rw-rw-rw-  2.0 fat    25225 b- defN 23-Aug-03 15:06 quarchCalibration/BK9832B.py
+-rw-rw-rw-  2.0 fat     7185 b- defN 23-Aug-03 15:06 quarchCalibration/ET2260.py
+-rw-rw-rw-  2.0 fat    19602 b- defN 23-Aug-03 15:06 quarchCalibration/Keithley_DMM6500_control.py
+-rw-rw-rw-  2.0 fat    19603 b- defN 23-Aug-03 15:06 quarchCalibration/Keysight_AC6804B_control.py
+-rw-rw-rw-  2.0 fat    23554 b- defN 23-Aug-03 15:06 quarchCalibration/PowerModuleCalibration.py
+-rw-rw-rw-  2.0 fat    68014 b- defN 23-Aug-03 15:06 quarchCalibration/QTL1944_06_hd_plus_ppm.py
+-rw-rw-rw-  2.0 fat    65172 b- defN 23-Aug-03 15:06 quarchCalibration/QTL1944_hd_ppm.py
+-rw-rw-rw-  2.0 fat    49330 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2347_pcie.py
+-rw-rw-rw-  2.0 fat    39890 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2525_sff.py
+-rw-rw-rw-  2.0 fat     2966 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2536_6_way_switchbox.py
+-rw-rw-rw-  2.0 fat    40468 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2582_3ph_ac.py
+-rw-rw-rw-  2.0 fat    38839 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2621_2ch_mezz.py
+-rw-rw-rw-  2.0 fat    32849 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2626_4ch_mezz.py
+-rw-rw-rw-  2.0 fat    33986 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2631_ext_mezz.py
+-rw-rw-rw-  2.0 fat    37022 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2673_edsff.py
+-rw-rw-rw-  2.0 fat    41024 b- defN 23-Aug-03 15:06 quarchCalibration/QTL2843_iec_ac.py
+-rw-rw-rw-  2.0 fat      632 b- defN 23-Aug-03 15:06 quarchCalibration/__init__.py
+-rw-rw-rw-  2.0 fat       82 b- defN 23-Aug-03 15:06 quarchCalibration/__main__.py
+-rw-rw-rw-  2.0 fat       26 b- defN 23-Aug-03 15:09 quarchCalibration/_version.py
+-rw-rw-rw-  2.0 fat     6523 b- defN 23-Aug-03 15:06 quarchCalibration/acHelpers.py
+-rw-rw-rw-  2.0 fat      713 b- defN 23-Aug-03 15:06 quarchCalibration/calibrationConfig.py
+-rw-rw-rw-  2.0 fat    17889 b- defN 23-Aug-03 15:06 quarchCalibration/calibrationUtil.py
+-rw-rw-rw-  2.0 fat     4164 b- defN 23-Aug-03 15:06 quarchCalibration/deviceHelpers.py
+-rw-rw-rw-  2.0 fat     9958 b- defN 23-Aug-03 15:06 quarchCalibration/elpaSine.py
+-rw-rw-rw-  2.0 fat    22184 b- defN 23-Aug-03 15:06 quarchCalibration/keithley_2460_control.py
+-rw-rw-rw-  2.0 fat     9506 b- defN 23-Aug-03 15:06 quarchCalibration/noise_test.py
+-rw-rw-rw-  2.0 fat    39461 b- defN 23-Aug-03 15:06 quarchCalibration/pamCommon.py
+-rw-rw-rw-  2.0 fat     1072 b- defN 23-Aug-03 15:06 quarchCalibration/pamHelpers.py
+-rw-rw-rw-  2.0 fat     7585 b- defN 23-Aug-03 15:06 quarchCalibration/threePhaseSwitchBox.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Aug-03 15:06 quarchCalibration/docs/__init__.py
+-rw-rw-rw-  2.0 fat     2076 b- defN 23-Aug-03 15:06 quarchCalibration/docs/conf.py
+-rw-rw-rw-  2.0 fat     1567 b- defN 23-Aug-03 15:16 quarchCalibration-1.1.6.dev2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      110 b- defN 23-Aug-03 15:16 quarchCalibration-1.1.6.dev2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       18 b- defN 23-Aug-03 15:16 quarchCalibration-1.1.6.dev2.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     3216 b- defN 23-Aug-03 15:16 quarchCalibration-1.1.6.dev2.dist-info/RECORD
+35 files, 671511 bytes uncompressed, 127950 bytes compressed:  80.9%
```

## zipnote {}

```diff
@@ -87,20 +87,20 @@
 
 Filename: quarchCalibration/docs/__init__.py
 Comment: 
 
 Filename: quarchCalibration/docs/conf.py
 Comment: 
 
-Filename: quarchCalibration-1.1.6.dev1.dist-info/METADATA
+Filename: quarchCalibration-1.1.6.dev2.dist-info/METADATA
 Comment: 
 
-Filename: quarchCalibration-1.1.6.dev1.dist-info/WHEEL
+Filename: quarchCalibration-1.1.6.dev2.dist-info/WHEEL
 Comment: 
 
-Filename: quarchCalibration-1.1.6.dev1.dist-info/top_level.txt
+Filename: quarchCalibration-1.1.6.dev2.dist-info/top_level.txt
 Comment: 
 
-Filename: quarchCalibration-1.1.6.dev1.dist-info/RECORD
+Filename: quarchCalibration-1.1.6.dev2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quarchCalibration/Keithley_DMM6500_control.py

```diff
@@ -103,14 +103,16 @@
 '''
 Class for control of Keithley source measure units for calibration purposes
 '''
 class KeithleyDMM6500:
 
     ACCurrentRanges = {"1mA":1E-3,"10mA":10E-3,"100mA":100E-3,"1A":1,"3A":3,"10A":10}
     CurrentRange = ""
+    ACVoltageRanges = {"100mV":100E-3,"1V":1,"10V":10,"750V":750}
+    VoltageRange = ""
 
     # Discover DMM6500 devices through mDNS
     # returns a list of [ALIAS,IP] lists from mDNS, where the name includes "DMM6500" and the service type is scpi-raw
     # This function makes a lot of assumptions about the data and certainly could be a lot more robust
     @staticmethod
     def discover():
 
@@ -158,14 +160,15 @@
             self.conString = self.addr
         self.connection = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
         self.connection.settimeout(self.TIMEOUT)
         self.connection.connect((self.conString,5025))
         self.isOpen = True
 
         # Reset the device on connection
+        self.connection.send("*LANG SCPI\r\n".encode('latin-1'))
         self.connection.send("*RST\r\n".encode('latin-1'))
         
     '''
     Close the connection to the instrument
     '''
     def closeConnection (self):
         logging.debug(os.path.basename(__file__) + ": closing connection to DMM6500 ")
@@ -310,16 +313,34 @@
         count = self.sendCommandQuery("TRAC:ACT?")
         result = float(self.sendCommandQuery("TRACE:STAT:AVER?"))
         return result
         
     '''
     Measures AC Voltage
     '''
-    def measureACVoltage (self):    
-        result = float(self.sendCommandQuery("MEAS:VOLT:AC?"))
+    def measureACVoltage (self,range="AUTO,",readings=1):  
+        
+        # set the range, if required
+        if range != self.CurrentRange:
+            if range in self.ACVoltageRanges.keys():
+                self.sendCommand("SENS:VOLT:AC:RANG " + str(self.ACCurrentRanges[range]))
+            else:
+                self.sendCommand("SENS:VOLT:AC:RANG:AUTO ON")
+
+        #Make a buffer of at least the specified size
+
+        self.sendCommand("TRAC:CLEAR")
+        self.sendCommand("SENS:COUNT " + str(readings))
+        self.sendCommand("STAT:OPER:MAP 0, 4917, 4918")
+        self.sendCommandQuery("MEAS:VOLT:AC?",timeoutAllowed=True)
+
+        while (self.sendCommandQuery("STAT:OPER?",timeoutAllowed=True) != "0"):
+            time.sleep(0.1)
+        count = self.sendCommandQuery("TRAC:ACT?")
+        result = float(self.sendCommandQuery("TRACE:STAT:AVER?"))
         return result
        
     '''
     Reset Trace
     '''
     def resetTrace (self):    
         self.sendCommandQuery("TRAC:CLE")
```

## quarchCalibration/QTL2621_2ch_mezz.py

```diff
@@ -62,44 +62,53 @@
         return parseFixtureData(data,16,25)
     elif (channel == "POWER_2 V"):
         return parseFixtureData(data,41,16)
     elif (channel == "POWER_2 A"):
         return parseFixtureData(data,57,25)
 
 
-
 class QTL2621 (PowerModule):
 
     # Fixture Register Addresses
     CAL_ADDRESSES = {
-    'CALIBRATION_MODE'				: '0xA100',
-    'CALIBRATION_CONTROL'			: '0xA101',      
+    #'SERIAL_1'						: '0xA102',	-- Mezzanine Serial Number
+    #'SERIAL_2'						: '0xA103',	-- Mezzanine Serial Number
+    #'SERIAL_3'						: '0xA104',	-- Mezzanine Serial Number
     'POWER_1_VOLT_MULTIPLIER'		: '0xA105',
     'POWER_1_VOLT_OFFSET'			: '0xA106',
     'POWER_1_HIGH_MULTIPLIER'		: '0xA107',
     'POWER_1_HIGH_OFFSET'			: '0xA108',
-    #'POWER_1_LEAKAGE_MULTIPLIER'	: '0xA109', -- Not required in Mezzanine
+    #'POWER_1_LEAKAGE_MULTIPLIER'	: '0xA109',	-- Not used in 2-Channel Mezzanine
     'POWER_2_VOLT_MULTIPLIER'		: '0xA10A',
     'POWER_2_VOLT_OFFSET'			: '0xA10B',
     'POWER_2_HIGH_MULTIPLIER'		: '0xA10C',
     'POWER_2_HIGH_OFFSET'			: '0xA10D',
-    #'POWER_2_LEAKAGE_MULTIPLIER'	: '0xA10E', -- Not required in Mezzanine
+    #'POWER_2_LEAKAGE_MULTIPLIER'	: '0xA10E',	-- Not used in 2-Channel Mezzanine
+    #'POWER_3_VOLT_MULTIPLIER'		: '0xA10F',	-- Not used in 2-Channel Mezzanine
+    #'POWER_3_VOLT_OFFSET'			: '0xA110',	-- Not used in 2-Channel Mezzanine
     'POWER_1_LOW_MULTIPLIER'		: '0xA111',
     'POWER_1_LOW_OFFSET'			: '0xA112',
+    #'POWER_3_LEAKAGE_MULTIPLIER'   : '0xA113',	-- Not used in 2-Channel Mezzanine
+    #'POWER_4_VOLT_MULTIPLIER'		: '0xA114',	-- Not used in 2-Channel Mezzanine
+    #'POWER_4_VOLT_OFFSET'			: '0xA115',	-- Not used in 2-Channel Mezzanine
     'POWER_2_LOW_MULTIPLIER'		: '0xA116',
     'POWER_2_LOW_OFFSET'			: '0xA117',
-    'CALIBRATION_COMPLETE'			: '0xA118',
+    'CALIBRATION_COMPLETE'			: '0xA118'
+    }
 
-    'POWER_1_LOW_CALIBRATION_CONTROL_SETTING'   : '0x00F1',  #set manual range, full averaging, POWER_1 low current mode, POWER_2 all off (so we can detect we're connected to the wrong channel
-    'POWER_2_LOW_CALIBRATION_CONTROL_SETTING'   : '0x00F4',  #set manual range, full averaging, POWER_1 high current mode, POWER_1 all off (so we can detect we're connected to the wrong channel
-    'POWER_1_HIGH_CALIBRATION_CONTROL_SETTING'  : '0x00F2',  #set manual range, full averaging, POWER_1 low current mode, POWER_2 all off (so we can detect we're connected to the wrong channel
-    'POWER_2_HIGH_CALIBRATION_CONTROL_SETTING'  : '0x00F8'  #set manual range, full averaging, POWER_1 high current mode, POWER_1 all off (so we can detect we're connected to the wrong channel
+    CAL_CONTROL_SETTINGS = {
+    'POWER_1_LOW_CALIBRATION_CONTROL_SETTING'   : '0x00F1',  #set manual range, full averaging, POWER_1 low current mode, POWER_2 auto
+    'POWER_2_LOW_CALIBRATION_CONTROL_SETTING'   : '0x00F4',  #set manual range, full averaging, POWER_2 low current mode, POWER_1 auto
+    'POWER_1_HIGH_CALIBRATION_CONTROL_SETTING'  : '0x00F2',  #set manual range, full averaging, POWER_1 high current mode, POWER_2 auto
+    'POWER_2_HIGH_CALIBRATION_CONTROL_SETTING'  : '0x00F8'  #set manual range, full averaging, POWER_2 high current mode, POWER_1 auto
 	}
 
-    LOAD_VOLTAGE                    = 12000
+    CALIBRATION_MODE_ADDR           = '0xA100'
+    CALIBRATION_CONTROL_ADDR        = '0xA101'
+    LOAD_VOLTAGE					= 12000
 
     host_switchbox_title = "12V Switchbox"
     host_switchbox_message = "Select the switch box which connects a 12V supply to POWER IN:"
     host_switchbox_mapping = {'12V':'A','POWER_1_IN':'1','POWER_2_IN':'2'}
 
     load_switchbox_title = "Load Switchbox"
     load_switchbox_message = "Select the switch box which connects a Keithley 2460 SourceMeter to POWER OUT:"
@@ -168,22 +177,20 @@
             versionStr = "NOT-FOUND"    
         self.Firmware = versionStr.strip()
 
         self.calibrations = {}
         # populate POWER_1 channel with calibrations
         self.calibrations["POWER_1"] = {
             "Voltage":self.QTL2621_VoltageCalibration(self,"POWER_1"),
-            #"Leakage":self.QTL2621_LeakageCalibration(self,"POWER_1"),
             "Low Current":self.QTL2621_LowCurrentCalibration(self,"POWER_1"),
             "High Current":self.QTL2621_HighCurrentCalibration(self,"POWER_1")
             }
         # populate POWER_2 channel with calibrations
         self.calibrations["POWER_2"] = {
             "Voltage":self.QTL2621_VoltageCalibration(self,"POWER_2"),
-            #"Leakage":self.QTL2621_LeakageCalibration(self,"POWER_2"),
             "Low Current":self.QTL2621_LowCurrentCalibration(self,"POWER_2"),
             "High Current":self.QTL2621_HighCurrentCalibration(self,"POWER_2")
             }
 
         self.verifications = {}
         # populate POWER_1 channel with verifications
         self.verifications["POWER_1"] = {
@@ -194,15 +201,14 @@
         # populate POWER_2 channel with verifications
         self.verifications["POWER_2"] = {
             "Voltage":self.QTL2621_VoltageVerification(self,"POWER_2"),
             "Low Current":self.QTL2621_LowCurrentVerification(self,"POWER_2"),
             "High Current":self.QTL2621_HighCurrentVerification(self,"POWER_2")
             }
 
-
     def specific_requirements(self):
 
         reportText=""
 
         # select the host switchbox to use for calibration
         if "host_switchbox" in calibrationResources.keys():
             self.host_switchbox = calibrationResources["host_switchbox"]
@@ -263,16 +269,16 @@
             self.waitComplete = True
 
         return reportText
 
     def open_module(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
 
     def get_switchbox(self,msg,name,portDict):
         # CheckSwitchbox
         while (True):
             switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message=msg, nice=True)
             if switchboxAddress == "quit":
                 printText("User Quit Program")
@@ -286,16 +292,16 @@
                 switchboxAddress = None
                 raise
         return switchbox
 
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
 
         # clear all calibration registers
         for address in self.CAL_ADDRESSES.values():
             self.dut.sendAndVerifyCommand("write " + address + " 0x0000")
         
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
         self.dut.sendAndVerifyCommand("write " + self.CAL_ADDRESSES["CALIBRATION_COMPLETE"] + " 0xaa55")
@@ -348,16 +354,16 @@
             # set averaging to max
             self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
 
             #Turn off compression and power up
             self.powerModule.dut.sendAndVerifyCommand("write 0xA010 0x0011")
 
             # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
 
             #Reset Keithley
             self.powerModule.calInstrument.reset()
 
         # check connections to host power and load
         def checkLoadVoltage(self,voltage,tolerance):
 
@@ -375,15 +381,15 @@
             self.powerModule.calInstrument.disable()
 
             #turn off switch
             self.powerModule.host_switchbox.setConnections([]) #sendCommand("connect off")
             self.powerModule.load_switchbox.setConnections([]) #sendCommand("connect off")
 
             # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CALIBRATION_CONTROL_ADDR + " 0x00F0")
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -557,16 +563,16 @@
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
             super().init_cal(self.thisChannel)
 
-            #set manual range, full averaging, [thisChannel] low current mode, other channels all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_CALIBRATION_CONTROL_SETTING"])
+            #set manual range, full averaging, [thisChannel] current range
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CALIBRATION_CONTROL_ADDR + " " + self.powerModule.CAL_CONTROL_SETTINGS[self.thisChannel + "_LOW_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " 0x0000")
 
             self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')])
             self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
 
@@ -579,17 +585,14 @@
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            # read device voltage and add leakage current to the reference
-            #voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
-            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
@@ -648,15 +651,15 @@
             self.offset_frac_width = 6
 
         def init(self):
 
             super().init_cal(self.thisChannel)
 
             #set manual range, full averaging, [thisChannel] high current mode, other channels all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_CALIBRATION_CONTROL_SETTING"])
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CALIBRATION_CONTROL_ADDR + " " + self.powerModule.CAL_CONTROL_SETTINGS[self.thisChannel + "_HIGH_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " 0x0000")
 
             self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')])
             self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
 
@@ -687,16 +690,14 @@
             result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
             logSimpleResult("Set " + self.thisChannel + " high current", result)
 
-            # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.hexString(4))
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
```

## quarchCalibration/QTL2626_4ch_mezz.py

```diff
@@ -3,15 +3,15 @@
 Written for Python 3.6 64 bit
 
 M Dearman April 2019
 '''
 
 '''
 Calibration Flow
-    Connect to PPM
+    Connect to PAM Fixture 
     Connect to Keithley
     step through a set of values and get ADC vs Reference Value
     evaluate results vs defined limits
 
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
@@ -42,15 +42,14 @@
     # pick out the section we want
     result = int(result[start:(start+length)],2)
     # convert two's compliment
     if (result >= 2**(length-1)):
         result -= 2**length
     return result
 
-
 def getFixtureData(device,channel):
     #hold measurement
     response = device.sendCommand("read 0x0000")
     device.sendCommand("write 0x0000 " + setBit(response,3))
     #read measurement
     data = device.sendCommand("read 0x1000 to 0x1008")
     #release measurement
@@ -75,38 +74,49 @@
         return parseFixtureData(data,112,16)
 
 
 class QTL2626 (PowerModule):
 
     # Fixture Register Addresses
     CAL_ADDRESSES = {
-    'CALIBRATION_MODE'              : '0xA100',
-    'CALIBRATION_CONTROL'           : '0xA101',      
+    #'SERIAL_1'						: '0xA102',	-- Mezzanine Serial Number
+    #'SERIAL_2'						: '0xA103',	-- Mezzanine Serial Number
+    #'SERIAL_3'						: '0xA104',	-- Mezzanine Serial Number
     'POWER_1_VOLT_MULTIPLIER'       : '0xA105',
     'POWER_1_VOLT_OFFSET'           : '0xA106',
     'POWER_1_CURR_MULTIPLIER'       : '0xA107',
     'POWER_1_CURR_OFFSET'           : '0xA108',
-    #'POWER_1_LEAKAGE_MULTIPLIER'   : '0xA109', -- Not required in Mezzanine
+    #'POWER_1_LEAKAGE_MULTIPLIER'   : '0xA109',	-- Not used in 4-Channel Mezzanine
     'POWER_2_VOLT_MULTIPLIER'       : '0xA10A',
     'POWER_2_VOLT_OFFSET'           : '0xA10B',
     'POWER_2_CURR_MULTIPLIER'       : '0xA10C',
     'POWER_2_CURR_OFFSET'           : '0xA10D',
-    #'POWER_2_LEAKAGE_MULTIPLIER'   : '0xA10E', -- Not required in Mezzanine
+    #'POWER_2_LEAKAGE_MULTIPLIER'   : '0xA10E',	-- Not used in 4-Channel Mezzanine
     'POWER_3_VOLT_MULTIPLIER'       : '0xA10F',
     'POWER_3_VOLT_OFFSET'           : '0xA110',
     'POWER_3_CURR_MULTIPLIER'       : '0xA111',
     'POWER_3_CURR_OFFSET'           : '0xA112',
-    #'POWER_3_LEAKAGE_MULTIPLIER'   : '0xA113', -- Not required in Mezzanine
+    #'POWER_3_LEAKAGE_MULTIPLIER'   : '0xA113',	-- Not used in 4-Channel Mezzanine
     'POWER_4_VOLT_MULTIPLIER'       : '0xA114',
     'POWER_4_VOLT_OFFSET'           : '0xA115',
     'POWER_4_CURR_MULTIPLIER'       : '0xA116',
     'POWER_4_CURR_OFFSET'           : '0xA117',
     'CALIBRATION_COMPLETE'          : '0xA118'
     }
-    LOAD_VOLTAGE                        = 12000
+
+    CAL_CONTROL_SETTINGS = {
+    'POWER_1_CALIBRATION_CONTROL_SETTING'	: '0x00F0',	#set full averaging
+    'POWER_2_CALIBRATION_CONTROL_SETTING'	: '0x00F0',	#set full averaging
+    'POWER_3_CALIBRATION_CONTROL_SETTING'	: '0x00F0',	#set full averaging
+    'POWER_4_CALIBRATION_CONTROL_SETTING'	: '0x00F0'	#set full averaging
+	}
+
+    CALIBRATION_MODE_ADDR           = '0xA100'
+    CALIBRATION_CONTROL_ADDR        = '0xA101'
+    LOAD_VOLTAGE					= 12000
 
     host_switchbox_title = "12V Switchbox"
     host_switchbox_message = "Select the switch box which connects a 12V supply to POWER IN:"
     host_switchbox_mapping = {'12V':'A','POWER_1_IN':'1','POWER_2_IN':'2','POWER_3_IN':'3','POWER_4_IN':'4'}
 
     load_switchbox_title = "Load Switchbox"
     load_switchbox_message = "Select the switch box which connects a Keithley 2460 SourceMeter to POWER OUT:"
@@ -280,16 +290,16 @@
             self.waitComplete = True
 
         return reportText
 
     def open_module(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
 
     def get_switchbox(self,msg,name,portDict):
         # CheckSwitchbox
         while (True):
             switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message=msg, nice=True)
             if switchboxAddress == "quit":
                 printText("User Quit Program")
@@ -300,20 +310,19 @@
             except:
                 printText("Unable to communicate with selected device!")
                 printText("")
                 switchboxAddress = None
                 raise
         return switchbox
 
-
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
 
         # clear all calibration registers
         for address in self.CAL_ADDRESSES.values():
             self.dut.sendAndVerifyCommand("write " + address + " 0x0000")
         
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
         self.dut.sendAndVerifyCommand("write " + self.CAL_ADDRESSES["CALIBRATION_COMPLETE"] + " 0xaa55")
@@ -362,26 +371,29 @@
             # TODO: No Power control at the moment
             # power up
             #self.powerModule.dut.sendAndVerifyCommand("power up")
 
             # set averaging to max
             self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
 
+            #Turn off compression and power up
+            self.powerModule.dut.sendAndVerifyCommand("write 0xA010 0x0011")
+
             # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
 
             #Reset Keithley
             self.powerModule.calInstrument.reset()
 
         # check connections to host power and load
         def checkLoadVoltage(self,voltage,tolerance):
 
             self.powerModule.calInstrument.setReferenceCurrent(0)
-            result = self.powerModule.calInstrument.measureLoadVoltage()*1000    # *1000 because we use mV but keithley uses volts
+            result = self.powerModule.calInstrument.measureLoadVoltage()*1000   # *1000 because we use mV but keithley uses volts
             # check result is in required range
             if (result >= voltage-tolerance) and (result <= voltage+tolerance):
                 return True
             else:
                 return False
 
         def finish_cal(self):
@@ -390,15 +402,15 @@
             self.powerModule.calInstrument.disable()
 
             #turn off switch
             self.powerModule.host_switchbox.setConnections([]) #sendCommand("connect off")
             self.powerModule.load_switchbox.setConnections([]) #sendCommand("connect off")
 
             # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CALIBRATION_CONTROL_ADDR + " 0x00F0")
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -534,25 +546,25 @@
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get POWER_1 voltage multiplier
+            # get voltage multiplier
             coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"])
-            # get POWER_1 voltage offset
+            # get voltage offset
             coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write POWER_1 voltage multiplier
+            # write voltage multiplier
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + coefficients["multiplier"])
-            # write POWER_1 voltage offset
+            # write voltage offset
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + coefficients["offset"])
 
     class QTL2626_CurrentCalibration (QTL2626Calibration):
 
         def __init__(self,powerModule,thisChannel):
 
             self.thisChannel = thisChannel
@@ -572,16 +584,16 @@
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
             super().init_cal(self.thisChannel)
 
-            #set full averaging
-            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
+            #set manual range, full averaging, [thisChannel] current range
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CALIBRATION_CONTROL_ADDR + " " + self.powerModule.CAL_CONTROL_SETTINGS[self.thisChannel + "_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"] + " 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"] + " 0x0000")
 
             self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')])
             self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
 
@@ -594,17 +606,14 @@
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000)
 
         def readRef(self):
 
-            # read device voltage and add leakage current to the reference
-            #voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
-            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
             return self.powerModule.calInstrument.measureLoadCurrent()*1000# + leakage
 
         def readVal(self):
 
             return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
@@ -624,25 +633,25 @@
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get POWER_1 low current multiplier
+            # get current multiplier
             coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"])
-            # get POWER_1 low current offset
+            # get current offset
             coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write POWER_1 low current multiplier
+            # write current multiplier
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"] + " " + coefficients["multiplier"])
-            # write POWER_1 low current offset
+            # write current offset
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"] + " " + coefficients["offset"])
 
     class QTL2626_VoltageVerification (QTL2626Calibration):
 
         def __init__(self,powerModule,thisChannel):
 
             self.thisChannel = thisChannel
```

## quarchCalibration/QTL2631_ext_mezz.py

```diff
@@ -3,15 +3,15 @@
 Written for Python 3.6 64 bit
 
 M Dearman April 2019
 '''
 
 '''
 Calibration Flow
-    Connect to PPM
+    Connect to PAM Fixture 
     Connect to Keithley
     step through a set of values and get ADC vs Reference Value
     evaluate results vs defined limits
 
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
@@ -42,15 +42,14 @@
     # pick out the section we want
     result = int(result[start:(start+length)],2)
     # convert two's compliment
     if (result >= 2**(length-1)):
         result -= 2**length
     return result
 
-
 def getFixtureData(device,channel):
     #hold measurement
     response = device.sendCommand("read 0x0000")
     device.sendCommand("write 0x0000 " + setBit(response,3))
     #read measurement
     data = device.sendCommand("read 0x1000 to 0x1008")
     #release measurement
@@ -75,38 +74,49 @@
         return parseFixtureData(data,115,17)
 
 
 class QTL2631 (PowerModule):
 
     # Fixture Register Addresses
     CAL_ADDRESSES = {
-    'CALIBRATION_MODE'              : '0xA100',
-    'CALIBRATION_CONTROL'           : '0xA101',      
+    #'SERIAL_1'						: '0xA102',	-- Mezzanine Serial Number
+    #'SERIAL_2'						: '0xA103',	-- Mezzanine Serial Number
+    #'SERIAL_3'						: '0xA104',	-- Mezzanine Serial Number
     'POWER_1_VOLT_MULTIPLIER'       : '0xA105',
     'POWER_1_VOLT_OFFSET'           : '0xA106',
     'POWER_1_CURR_MULTIPLIER'       : '0xA107',
     'POWER_1_CURR_OFFSET'           : '0xA108',
-    #'POWER_1_LEAKAGE_MULTIPLIER'   : '0xA109', -- Not required in Mezzanine
+    #'POWER_1_LEAKAGE_MULTIPLIER'   : '0xA109',	-- Not used in External Shunt Mezzanine
     'POWER_2_VOLT_MULTIPLIER'       : '0xA10A',
     'POWER_2_VOLT_OFFSET'           : '0xA10B',
     'POWER_2_CURR_MULTIPLIER'       : '0xA10C',
     'POWER_2_CURR_OFFSET'           : '0xA10D',
-    #'POWER_2_LEAKAGE_MULTIPLIER'   : '0xA10E', -- Not required in Mezzanine
+    #'POWER_2_LEAKAGE_MULTIPLIER'   : '0xA10E',	-- Not used in External Shunt Mezzanine
     'POWER_3_VOLT_MULTIPLIER'       : '0xA10F',
     'POWER_3_VOLT_OFFSET'           : '0xA110',
     'POWER_3_CURR_MULTIPLIER'       : '0xA111',
     'POWER_3_CURR_OFFSET'           : '0xA112',
-    #'POWER_3_LEAKAGE_MULTIPLIER'   : '0xA113', -- Not required in Mezzanine
+    #'POWER_3_LEAKAGE_MULTIPLIER'   : '0xA113',	-- Not used in External Shunt Mezzanine
     'POWER_4_VOLT_MULTIPLIER'       : '0xA114',
     'POWER_4_VOLT_OFFSET'           : '0xA115',
     'POWER_4_CURR_MULTIPLIER'       : '0xA116',
     'POWER_4_CURR_OFFSET'           : '0xA117',
     'CALIBRATION_COMPLETE'          : '0xA118'
     }
-    LOAD_VOLTAGE                        = 12000
+
+    CAL_CONTROL_SETTINGS = {
+    'POWER_1_CALIBRATION_CONTROL_SETTING'	: '0x00F0',	#set full averaging
+    'POWER_2_CALIBRATION_CONTROL_SETTING'	: '0x00F0',	#set full averaging
+    'POWER_3_CALIBRATION_CONTROL_SETTING'	: '0x00F0',	#set full averaging
+    'POWER_4_CALIBRATION_CONTROL_SETTING'	: '0x00F0'	#set full averaging
+	}
+
+    CALIBRATION_MODE_ADDR           = '0xA100'
+    CALIBRATION_CONTROL_ADDR        = '0xA101'
+    LOAD_VOLTAGE					= 12000
 
     host_switchbox_title = "12V Switchbox"
     host_switchbox_message = "Select the switch box which connects a 12V supply to POWER IN:"
     host_switchbox_mapping = {'12V':'A','POWER_1_IN':'1','POWER_2_IN':'2','POWER_3_IN':'3','POWER_4_IN':'4'}
 
     load_switchbox_title = "Load Switchbox"
     load_switchbox_message = "Select the switch box which connects a Keithley 2460 SourceMeter to POWER OUT:"
@@ -125,15 +135,15 @@
     load_switchbox = None
     waitComplete = False
     checkedWiring = False
 
     def __init__(self,dut):
 
         # set the name of this module
-        self.name = "4-Channel Power Measurement Fixture"
+        self.name = "External Shunt Power Measurement Fixture"
         self.dut = dut
         
         # Serial numbers (ensure QTL at start)
         self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
         if (self.enclosureSerial.find ("QTL") == -1):
             self.enclosureSerial = "QTL" + self.enclosureSerial
         # fetch the enclosure position
@@ -280,16 +290,16 @@
             self.waitComplete = True
 
         return reportText
 
     def open_module(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
 
     def get_switchbox(self,msg,name,portDict):
         # CheckSwitchbox
         while (True):
             switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message=msg, nice=True)
             if switchboxAddress == "quit":
                 printText("User Quit Program")
@@ -303,16 +313,16 @@
                 switchboxAddress = None
                 raise
         return switchbox
 
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
-        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
+        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
 
         # clear all calibration registers
         for address in self.CAL_ADDRESSES.values():
             self.dut.sendAndVerifyCommand("write " + address + " 0x0000")
         
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
         self.dut.sendAndVerifyCommand("write " + self.CAL_ADDRESSES["CALIBRATION_COMPLETE"] + " 0xaa55")
@@ -361,26 +371,29 @@
             # TODO: No Power control at the moment
             # power up
             #self.powerModule.dut.sendAndVerifyCommand("power up")
 
             # set averaging to max
             self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
 
+            #Turn off compression and power up
+            self.powerModule.dut.sendAndVerifyCommand("write 0xA010 0x0011")
+
             # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
 
             #Reset Keithley
             self.powerModule.calInstrument.reset()
 
         # check connections to host power and load
         def checkLoadVoltage(self,voltage,tolerance):
 
             self.powerModule.calInstrument.setReferenceCurrent(0)
-            result = self.powerModule.calInstrument.measureLoadVoltage()*1000    # *1000 because we use mV but keithley uses volts
+            result = self.powerModule.calInstrument.measureLoadVoltage()*1000   # *1000 because we use mV but keithley uses volts
             # check result is in required range
             if (result >= voltage-tolerance) and (result <= voltage+tolerance):
                 return True
             else:
                 return False
 
         def finish_cal(self):
@@ -389,15 +402,15 @@
             self.powerModule.calInstrument.disable()
 
             #turn off switch
             self.powerModule.host_switchbox.setConnections([]) #sendCommand("connect off")
             self.powerModule.load_switchbox.setConnections([]) #sendCommand("connect off")
 
             # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CALIBRATION_CONTROL_ADDR + " 0x00F0")
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -453,15 +466,15 @@
                     report.append("\t" + '{:>11.3f}'.format(reference) + '     ' + '{:>10.1f}'.format(ppmValue) + '     ' + "{:>10.3f}".format(actError) + '     ' + '{0:>16}'.format(errorSign + "(" + str(absError) + self.units + "," + "{:.3f}".format(relError) + "%)") + '     ' + '{0:>10}'.format(passfail(result)))
 
             report.append("==================================================================================================")
             report.append('\n')
 
             if action == "calibrate":
                 report.append("Calculated Multiplier: " + str(self.multiplier.originalValue()) + ", Calculated Offset: " + str(self.offset.originalValue()))
-                report.append("Stored Multiplier: " + str(self.multiplier.storedValue) + ", Stored Offset: " + str(self.offset.storedValue))
+                report.append("Stored Multiplier: " + str(self.multiplier.storedValue()) + ", Stored Offset: " + str(self.offset.storedValue()))
                 report.append("Multiplier Register: " + self.multiplier.hexString(4) + ", Offset Register: " + self.offset.hexString(4))
 
             report.append("" + '{0:<35}'.format(self.title)+ '     '  +'{0:>10}'.format("Passed : ")+ '  '  + '{0:<5}'.format(str(overallResult))+ '     ' + '{0:>11}'.format( "worst case:")+ '  '  +'{0:>11}'.format(worstCase))
             report.append("\n\n\n")
             
             #Add to Test Summary? Do this here?
             passfail = lambda x: "Passed" if x else "Failed"
@@ -533,35 +546,35 @@
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get POWER_1 voltage multiplier
+            # get voltage multiplier
             coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"])
-            # get POWER_1 voltage offset
+            # get voltage offset
             coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write POWER_1 voltage multiplier
+            # write voltage multiplier
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + coefficients["multiplier"])
-            # write POWER_1 voltage offset
+            # write voltage offset
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + coefficients["offset"])
 
     class QTL2631_deltaVoltCalibration (QTL2631Calibration):
 
         def __init__(self,powerModule,thisChannel):
 
             self.thisChannel = thisChannel
             self.title = thisChannel + " deltaVolt Calibration"
             self.powerModule = powerModule
-            self.absErrorLimit = 2                 # 10uV
+            self.absErrorLimit = 10                 # 10uV
             self.relErrorLimit = 1                  # 1%
             self.test_min = 10                      # 10uV = 2mA
             self.test_max = 20000                   # 20000uV = 4A which is the keithley limit
             self.test_steps = 20
             self.units = "uV"
             self.scaling = 16
             self.multiplier_signed = False
@@ -571,16 +584,16 @@
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
             super().init_cal(self.thisChannel)
 
-            #set full averaging
-            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
+            #set manual range, full averaging, [thisChannel] current range
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CALIBRATION_CONTROL_ADDR + " " + self.powerModule.CAL_CONTROL_SETTINGS[self.thisChannel + "_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"] + " 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"] + " 0x0000")
 
             self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')])
             self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
 
@@ -589,15 +602,15 @@
                 showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
                 self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')],reset=True)
                 self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')],reset=True)
 
 
         def setRef(self,value):
 
-            # The Keithley sources resistance in Amps, the calibration board has a 5mOhm resistor on it
+            # The Keithley sources current in Amps, the calibration board has a 5mOhm resistor on it
             # we need to convert our reference voltage into an amp value
             # i = V/R = (value in uV/1000000) / Resistance 0.005
             self.powerModule.calInstrument.setReferenceCurrent((value/1000000)/0.005)
 
         def readRef(self):
 
             # The Keithley sources resistance in Amps, the calibration board has a 5mOhm resistor on it
@@ -626,25 +639,25 @@
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get POWER_1 low current multiplier
+            # get current multiplier
             coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"])
-            # get POWER_1 low current offset
+            # get current offset
             coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write POWER_1 low current multiplier
+            # write current multiplier
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"] + " " + coefficients["multiplier"])
-            # write POWER_1 low current offset
+            # write current offset
             self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"] + " " + coefficients["offset"])
 
     class QTL2631_VoltageVerification (QTL2631Calibration):
 
         def __init__(self,powerModule,thisChannel):
 
             self.thisChannel = thisChannel
@@ -691,15 +704,15 @@
     class QTL2631_deltaVoltVerification (QTL2631Calibration):
 
         def __init__(self,powerModule,thisChannel):
 
             self.thisChannel = thisChannel
             self.title = thisChannel + " deltaVolt Verification"
             self.powerModule = powerModule
-            self.absErrorLimit = 2     # 25mA  - Deliberately higher than calibration limit
+            self.absErrorLimit = 10     # 10uV = 2mA  - Deliberately higher than calibration limit
             self.relErrorLimit = 1      # 1% tolerance
             self.test_min = 50          # 50uV = 10mA 
             self.test_max = 20000       # 20000uV = 4A which is the keithley limit
             self.test_steps = 20
             self.units = "uV"
 
         def init(self):
```

## quarchCalibration/QTL2843_iec_ac.py

```diff
@@ -39,15 +39,14 @@
 import csv
 from collections import OrderedDict
 from .threePhaseSwitchBox import ThreePhaseSwitchBox
 from quarchCalibration import Keysight_AC6804B_control
 from quarchCalibration.Keysight_AC6804B_control import KeysightAC6804B
 from .pamHelpers import bcdString
 #from .acHelpers import *
-#import matplotlib.pyplot as plt --debug only
 
 #todo: MIKE - terrible name and strange location
 def get_QIS_version():
 	#TODO option var "close_qis_afer_check" to determine if qis is left open or not.
     global my_close_qis
     """
     Returns the version of QIS.  This is the version of QIS currenty running on the local system if one exists.
@@ -230,23 +229,30 @@
     checkedWiring = False
     currentPhase = None
 
     def specific_requirements(self):
 
         reportText=""
 
-        # select a DMM6500 to use for calibration
-        if "dmm6500" in calibrationResources.keys():
-            self.dmm = calibrationResources["dmm6500"]
+        # select a DMM6500 to use for voltage calibration
+        if "dmm6500_voltage" in calibrationResources.keys():
+            self.voltage_dmm = calibrationResources["dmm6500_voltage"]
         else:
-            self.dmm = self.getDMM()
-        calibrationResources["dmm6500"] = self.dmm
+            self.voltage_dmm = self.getDMM(alias="DMM6500 for Voltage Measurement")
+        calibrationResources["dmm6500_voltage"] = self.voltage_dmm
+
+        # select a DMM6500 to use for current calibration
+        if "dmm6500_current" in calibrationResources.keys():
+            self.current_dmm = calibrationResources["dmm6500_current"]
+        else:
+            self.current_dmm = self.getDMM(alias="DMM6500 for Current Measurement")
+        calibrationResources["dmm6500_current"] = self.current_dmm
 
         # do a read, otherwise the first reading after connection seems to be wrong
-        self.dmm.measureACCurrent("10A") * 1000.0
+        self.current_dmm.measureACCurrent("10A") * 1000.0
 
         # select an AC Supply to use for calibration
         if "acSupply" in calibrationResources.keys():
             self.acSupply = calibrationResources["acSupply"]
         else:
             self.acSupply = self.getAcSupply()
         calibrationResources["acSupply"] = self.acSupply
@@ -293,20 +299,20 @@
             reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
             self.waitComplete = True
 
         return reportText
 
     #todo: MIKE - move to Keithley_DMM6500_control.py?
     def getDMM(self,alias=""):
-        #if alias is None or alias == "":
-        alias = "DMM6500"
+        if alias is None or alias == "":
+            alias = "DMM6500"
         # Find an AC Mux
         while (True):
             devices = KeithleyDMM6500.discover()
-            selectedDevice = quarchpy.user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
+            selectedDevice = quarchpy.user_interface.listSelection(title="Select a " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
             if str(selectedDevice[1]).lower() == "rescan":
                 pass
             elif str(selectedDevice[1]).lower() == "quit":
                 printText("User Quit Program")
                 sys.exit(0)
             else:
                 try:
@@ -617,25 +623,28 @@
             else:
                 key = "{0:s} mA".format(phase)
 
             if key in vals:
 		                
 		        ##TODO: Mike Debug but might be useful if we want to add another package
 		        ##plot value in question
-		        #data = self.readRawValues()[key]
-		        #x = range(0,len(data),1)
-		        #y = self.readRawValues()[key]
+
+                #import matplotlib.pyplot as plt #debug only
+
+          #      data = self.readRawValues()[key]
+          #      x = range(0,len(data),1)
+          #      y = self.readRawValues()[key]
 		
-		        #plt.clf()           # clear figure
-		        #plt.title(key)      # set title
-		        #plt.ion()           #interactive on, so it doesnt block
-		        #plt.plot(x, y)      # add the data
-		        #plt.draw()          # draw the data
-		        #plt.pause(0.001)    # allow the GUI to update
-		        #plt.show()          # show the window
+          #      plt.clf()           # clear figure
+          #      plt.title(key)      # set title
+          #      plt.ion()           #interactive on, so it doesnt block
+          #      plt.plot(x, y)      # add the data
+          #      plt.draw()          # draw the data
+          #      plt.pause(0.001)    # allow the GUI to update
+          #      plt.show()          # show the window
 		
                 return vals[key]
 		
             else:
                 raise ValueError("requested measurement not found in data")
         
         def finish_cal(self):
@@ -772,16 +781,16 @@
 
         def setRef(self,value):
             self.reference = value
             self.powerModule.acSupply.setACSupplyVoltage(value/1000)
             sleep(3) # Add settling time
 
         def readRef(self):
-            self.startStream(self.powerModule.dut,0.2)
-            return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
+            self.startStream(self.powerModule.dut,3.3)
+            return self.powerModule.voltage_dmm.measureACVoltage(readings=10) * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
             return self.getMeasurement(self.phase, 'V', typ='RMS', average=1)
 
         def setCoefficients(self):
 
@@ -852,15 +861,15 @@
                 raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
             self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
             self.powerModule.acLoad.setOutputEnable(True)
             sleep(1) # Add settling time
 
         def readRef(self):
             self.startStream(self.powerModule.dut,3.3)
-            return self.powerModule.dmm.measureACCurrent("10A",readings = 10) * 1000.0
+            return self.powerModule.current_dmm.measureACCurrent("10A",readings = 10) * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
             return self.getMeasurement(self.phase, 'I', typ='RMS', average=16)
 
         def setCoefficients(self):
 
@@ -915,16 +924,16 @@
 #                input("Unexpected voltage detected at load, please check connections")
 
         def setRef(self,value):
             self.powerModule.acSupply.setACSupplyVoltage(value/1000)
             sleep(1) # Add settling time
 
         def readRef(self):
-            self.startStream(self.powerModule.dut,0.2)
-            return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
+            self.startStream(self.powerModule.dut,3.3)
+            return self.powerModule.voltage_dmm.measureACVoltage(readings=10) * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
             return self.getMeasurement(self.phase, 'V', typ='RMS', average=1)
 
         def finish(self):
 
@@ -965,15 +974,15 @@
                 raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
             self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
             self.powerModule.acLoad.setOutputEnable(True)
             time.sleep(1) # add settling time
 
         def readRef(self):
             self.startStream(self.powerModule.dut,3.3)
-            return self.powerModule.dmm.measureACCurrent("10A",10) * 1000.0
+            return self.powerModule.current_dmm.measureACCurrent("10A",10) * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
             return self.getMeasurement(self.phase, 'I', typ='RMS', average=1)
 
         def finish(self):
```

## quarchCalibration/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.1.6.dev1"
+__version__ = "1.1.6.dev2"
```

## quarchCalibration/deviceHelpers.py

```diff
@@ -70,22 +70,24 @@
     def remove_service(self, zeroconf, type, name):
         pass
 
     '''
     Add all located devices to the dictionary (IP:Name)
     '''
     def add_service(self, zeroconf, type, name):
-        if 'OKI-B401' in name: # 'OKI-B401' Printer was causing error. #TODO change this to anything that isn't keithley 
-            return
-        info = zeroconf.get_service_info(type, name)
-        if info:
-            for address in info.addresses:
-                addr = socket.inet_ntoa(address)
-                self.deviceList[addr] = info.name
-                pass
+        try:
+            info = zeroconf.get_service_info(type, name)
+            if info:
+                for address in info.addresses:
+                    addr = socket.inet_ntoa(address)
+                    self.deviceList[addr] = info.name
+                    pass
+        except Exception as e:
+            logging.error("zeroconf threw an exception when attempting to add service " + name + " : " + e)
+
 
     def update_service(self, zeroconf, type, name):
         pass
             
 
 '''
 Function to locate a list of instruments matching the given name
```

## Comparing `quarchCalibration-1.1.6.dev1.dist-info/METADATA` & `quarchCalibration-1.1.6.dev2.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: quarchCalibration
-Version: 1.1.6.dev1
+Version: 1.1.6.dev2
 Summary: This packpage offers calibration for Quarch Technology modules.
 Author: Quarch Technology ltd
 Author-email: support@quarch.com
 License: Quarch Technology ltd
 Keywords: quarch quarchpy calibration torridon
 Classifier: Intended Audience :: Information Technology
 Classifier: Intended Audience :: Developers
```

## Comparing `quarchCalibration-1.1.6.dev1.dist-info/RECORD` & `quarchCalibration-1.1.6.dev2.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 quarchCalibration/BK9832B.py,sha256=lDCAIAvkw4WFyCfyxw0LtxVTV9fFkGAFJPGdXAHvFFU,25225
 quarchCalibration/ET2260.py,sha256=9nt9CfIbqz8kcGSBQnLsyScxPU3e7oNBlGg3TvWfkKQ,7185
-quarchCalibration/Keithley_DMM6500_control.py,sha256=dMBK1xoohrCJ0PiVGpfpZmbi9vX97Dsf3EyzVLGVxiI,18660
+quarchCalibration/Keithley_DMM6500_control.py,sha256=PeKHsOo7ZoRJX6EnL_viIQkIIa4LcDL2hxKIXrTmStY,19602
 quarchCalibration/Keysight_AC6804B_control.py,sha256=gDxKi1SAOxUl7DdmaYp2vQsd_bIo58X4XCKgLXNk5yI,19603
 quarchCalibration/PowerModuleCalibration.py,sha256=x4rsb27cksOeG3zubfiB93ixhoAO8aklpoW8qV8PwDs,23554
 quarchCalibration/QTL1944_06_hd_plus_ppm.py,sha256=ww60xV8kxgUbSNk_jN11ixQBFoVgDcUovjZYZPqQJ8g,68014
 quarchCalibration/QTL1944_hd_ppm.py,sha256=ovRvQHnMtjNKAlIG8-_r78gqxvh1PjoNYZveG-z8rYM,65172
 quarchCalibration/QTL2347_pcie.py,sha256=nWS8MWMo_1L6exG7DcNe7Y9D3hIDKaIoP-NM_fboVTQ,49330
 quarchCalibration/QTL2525_sff.py,sha256=L_uMhk47KVs81EUFVYGPuaLALhpPvkOGEYvnLQcgENg,39890
 quarchCalibration/QTL2536_6_way_switchbox.py,sha256=2_gODxuIsheQyRYC1EuuRRznQ8E1uTl34Ue4X0YuY-I,2966
 quarchCalibration/QTL2582_3ph_ac.py,sha256=uxkTiZsoJgOOIhCqUB0giVQAmagrKmLcyQ1752UTY4c,40468
-quarchCalibration/QTL2621_2ch_mezz.py,sha256=dRybUnoKgPqetEk_68yENEtSPySYxE7Gja3fd0B_tzI,39414
-quarchCalibration/QTL2626_4ch_mezz.py,sha256=Cr_U4jc0-VBwHHSApb6jL7TL4CrPytpO71GReHJmPek,32603
-quarchCalibration/QTL2631_ext_mezz.py,sha256=IjeQkIW3bVKcviXX5MARViEsvjRhaZK5u_8icrzw1x8,33360
+quarchCalibration/QTL2621_2ch_mezz.py,sha256=Fh2iXZ92PPJQjPSNVEB3uh6kGOVyBPUuJsImmtxbfWE,38839
+quarchCalibration/QTL2626_4ch_mezz.py,sha256=KABixcTMM-Lzi1ii42-ran0eGeyjdLbS5QQNalrQ7Ow,32849
+quarchCalibration/QTL2631_ext_mezz.py,sha256=VPQRcnyZ4yM7Zhr0DX21As-isYyTB5thrdXM0tiuIVY,33986
 quarchCalibration/QTL2673_edsff.py,sha256=Q65K1MNTRMxIrdgHPvgjNzZITCAUpaAWM6LdTS6Bq7w,37022
-quarchCalibration/QTL2843_iec_ac.py,sha256=6dZ2oPrDFLwtz5MvEJCYNiC9wPyoDyO5tjofMmz-dAM,40449
+quarchCalibration/QTL2843_iec_ac.py,sha256=D688F2-kx-s_oLT48cs8Lm8t0QksijBpFSibKt5znaI,41024
 quarchCalibration/__init__.py,sha256=P9qGw04tWqlg9S_Kq24Lr6TQiWwc-6aCs48mWEt8aRc,632
 quarchCalibration/__main__.py,sha256=gZxkbC5-1lzb_PZnjMW68hExuCWkFevjP5ED39w1KSo,82
-quarchCalibration/_version.py,sha256=oJUa4ZCaRpufw-YTC0bpAkQqIQ6cacQQhbgEJR8XDQ4,26
+quarchCalibration/_version.py,sha256=v5MKHZe6Zjs_bSwLCfCkhb17WW5sr8Wh5pM6arg6-v4,26
 quarchCalibration/acHelpers.py,sha256=rnq9q5BDCOatki9qan3gmZ7GsVYJXqAVZrbmXzGQqkg,6523
 quarchCalibration/calibrationConfig.py,sha256=kfyTEUJFHFh9WHiudgXIA2gmW53IB1cc76523YWsOQM,713
 quarchCalibration/calibrationUtil.py,sha256=sogYOO6x5yJRIBao1ZCiVSIC_gefV-9HNGhdgQRInmI,17889
-quarchCalibration/deviceHelpers.py,sha256=O4K3JnldZjFoCPcrBqhDgrdSeDEiA-eR5_wM5IHzKPw,4126
+quarchCalibration/deviceHelpers.py,sha256=-9huVNJm5PGVTczXL54jdFutPUqeWGksIrpcCcRXmoI,4164
 quarchCalibration/elpaSine.py,sha256=3iUaEGQ2VPh06YU4NerdKp2FQsKNO1Y7oQ0ZUUxfv-c,9958
 quarchCalibration/keithley_2460_control.py,sha256=8BjRY7R1mViFcqOOIUUyqcIltUDnz1DkZwUSm44heZU,22184
 quarchCalibration/noise_test.py,sha256=p9D3yLouscf3ske4xEH8e096hamrfkFxHYZNhq4D7Ss,9506
 quarchCalibration/pamCommon.py,sha256=Miji_Ewuiyq-92EGb1YzWttWM_zNwxag4KpCXrR895E,39461
 quarchCalibration/pamHelpers.py,sha256=p0GCe0X-2Z_rbqkdLFyAaHraFabmhkbGxrjug0UJyRo,1072
 quarchCalibration/threePhaseSwitchBox.py,sha256=8LpjGFEMmznKWc2mwoYI9pUgHexr_DA5HMrYTv0hsOU,7585
 quarchCalibration/docs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 quarchCalibration/docs/conf.py,sha256=QQjLji6g2mzCksnfluxXWHGgxpV5mrtGiTkH5kMCRWo,2076
-quarchCalibration-1.1.6.dev1.dist-info/METADATA,sha256=dfuwbam145Vtw3kF07d4QRf1yvvO7ZAxNHRBSztLzdM,1567
-quarchCalibration-1.1.6.dev1.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
-quarchCalibration-1.1.6.dev1.dist-info/top_level.txt,sha256=4sTt-nDiODeU-FUOWSdIZfUEK8olrtX1wbjExcJ-_3M,18
-quarchCalibration-1.1.6.dev1.dist-info/RECORD,,
+quarchCalibration-1.1.6.dev2.dist-info/METADATA,sha256=VUWQ55ZfAzZ5ilbbYwwdVT-PUPwnQRAFp6Ro9t9VWp8,1567
+quarchCalibration-1.1.6.dev2.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+quarchCalibration-1.1.6.dev2.dist-info/top_level.txt,sha256=4sTt-nDiODeU-FUOWSdIZfUEK8olrtX1wbjExcJ-_3M,18
+quarchCalibration-1.1.6.dev2.dist-info/RECORD,,
```

