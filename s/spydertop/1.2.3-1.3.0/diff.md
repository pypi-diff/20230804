# Comparing `tmp/spydertop-1.2.3-py3-none-any.whl.zip` & `tmp/spydertop-1.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,39 @@
-Zip file size: 83522 bytes, number of entries: 33
--rw-r--r--  2.0 unx      698 b- defN 23-Jul-07 15:34 spydertop/__init__.py
--rw-r--r--  2.0 unx     6718 b- defN 23-Jul-07 15:34 spydertop/cli.py
--rw-r--r--  2.0 unx    10227 b- defN 23-Jul-07 15:34 spydertop/config.py
--rw-r--r--  2.0 unx    25655 b- defN 23-Jul-07 15:34 spydertop/model.py
--rw-r--r--  2.0 unx    13234 b- defN 23-Jul-07 15:34 spydertop/recordpool.py
--rw-r--r--  2.0 unx      823 b- defN 23-Jul-07 15:34 spydertop/constants/__init__.py
--rw-r--r--  2.0 unx    19877 b- defN 23-Jul-07 15:34 spydertop/constants/columns.py
--rw-r--r--  2.0 unx     3902 b- defN 23-Jul-07 15:34 spydertop/constants/palettes.py
--rw-r--r--  2.0 unx     2742 b- defN 23-Jul-07 15:34 spydertop/screens/__init__.py
--rw-r--r--  2.0 unx    35201 b- defN 23-Jul-07 15:34 spydertop/screens/config.py
--rw-r--r--  2.0 unx     3315 b- defN 23-Jul-07 15:34 spydertop/screens/failure.py
--rw-r--r--  2.0 unx     4121 b- defN 23-Jul-07 15:34 spydertop/screens/feedback.py
--rw-r--r--  2.0 unx     2056 b- defN 23-Jul-07 15:34 spydertop/screens/footer.py
--rw-r--r--  2.0 unx     7578 b- defN 23-Jul-07 15:34 spydertop/screens/help.py
--rw-r--r--  2.0 unx     7753 b- defN 23-Jul-07 15:34 spydertop/screens/loading.py
--rw-r--r--  2.0 unx    34957 b- defN 23-Jul-07 15:34 spydertop/screens/main.py
--rw-r--r--  2.0 unx    11199 b- defN 23-Jul-07 15:34 spydertop/screens/meters.py
--rw-r--r--  2.0 unx     5855 b- defN 23-Jul-07 15:34 spydertop/screens/modals.py
--rw-r--r--  2.0 unx     4472 b- defN 23-Jul-07 15:34 spydertop/screens/quit.py
--rw-r--r--  2.0 unx    12680 b- defN 23-Jul-07 15:34 spydertop/screens/setup.py
--rw-r--r--  2.0 unx     7892 b- defN 23-Jul-07 15:34 spydertop/utils/__init__.py
--rw-r--r--  2.0 unx     2242 b- defN 23-Jul-07 15:34 spydertop/utils/cache.py
--rw-r--r--  2.0 unx     4462 b- defN 23-Jul-07 15:34 spydertop/utils/cursorlist.py
--rw-r--r--  2.0 unx    16961 b- defN 23-Jul-07 15:34 spydertop/utils/types.py
--rw-r--r--  2.0 unx     4754 b- defN 23-Jul-07 15:34 spydertop/widgets/__init__.py
--rw-r--r--  2.0 unx     6246 b- defN 23-Jul-07 15:34 spydertop/widgets/meter.py
--rw-r--r--  2.0 unx    19510 b- defN 23-Jul-07 15:34 spydertop/widgets/table.py
--rw-r--r--  2.0 unx     1083 b- defN 23-Jul-07 15:35 spydertop-1.2.3.dist-info/LICENSE
--rw-r--r--  2.0 unx     6719 b- defN 23-Jul-07 15:35 spydertop-1.2.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-07 15:35 spydertop-1.2.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       44 b- defN 23-Jul-07 15:35 spydertop-1.2.3.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Jul-07 15:35 spydertop-1.2.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2737 b- defN 23-Jul-07 15:35 spydertop-1.2.3.dist-info/RECORD
-33 files, 285815 bytes uncompressed, 79176 bytes compressed:  72.3%
+Zip file size: 91868 bytes, number of entries: 37
+-rw-r--r--  2.0 unx      706 b- defN 23-Aug-04 20:23 spydertop/__init__.py
+-rw-r--r--  2.0 unx    18803 b- defN 23-Aug-04 20:23 spydertop/cli.py
+-rw-r--r--  2.0 unx    27339 b- defN 23-Aug-04 20:23 spydertop/model.py
+-rw-r--r--  2.0 unx    13747 b- defN 23-Aug-04 20:23 spydertop/recordpool.py
+-rw-r--r--  2.0 unx     1512 b- defN 23-Aug-04 20:23 spydertop/state.py
+-rw-r--r--  2.0 unx      381 b- defN 23-Aug-04 20:23 spydertop/config/__init__.py
+-rw-r--r--  2.0 unx     2841 b- defN 23-Aug-04 20:23 spydertop/config/cache.py
+-rw-r--r--  2.0 unx     9498 b- defN 23-Aug-04 20:23 spydertop/config/config.py
+-rw-r--r--  2.0 unx     2230 b- defN 23-Aug-04 20:23 spydertop/config/secrets.py
+-rw-r--r--  2.0 unx      823 b- defN 23-Aug-04 20:23 spydertop/constants/__init__.py
+-rw-r--r--  2.0 unx    20064 b- defN 23-Aug-04 20:23 spydertop/constants/columns.py
+-rw-r--r--  2.0 unx     3902 b- defN 23-Aug-04 20:23 spydertop/constants/palettes.py
+-rw-r--r--  2.0 unx     5033 b- defN 23-Aug-04 20:23 spydertop/screens/__init__.py
+-rw-r--r--  2.0 unx    32896 b- defN 23-Aug-04 20:23 spydertop/screens/config.py
+-rw-r--r--  2.0 unx     3406 b- defN 23-Aug-04 20:23 spydertop/screens/failure.py
+-rw-r--r--  2.0 unx     4119 b- defN 23-Aug-04 20:23 spydertop/screens/feedback.py
+-rw-r--r--  2.0 unx     2074 b- defN 23-Aug-04 20:23 spydertop/screens/footer.py
+-rw-r--r--  2.0 unx     7576 b- defN 23-Aug-04 20:23 spydertop/screens/help.py
+-rw-r--r--  2.0 unx     8556 b- defN 23-Aug-04 20:23 spydertop/screens/loading.py
+-rw-r--r--  2.0 unx    37497 b- defN 23-Aug-04 20:23 spydertop/screens/main.py
+-rw-r--r--  2.0 unx    11176 b- defN 23-Aug-04 20:23 spydertop/screens/meters.py
+-rw-r--r--  2.0 unx     5855 b- defN 23-Aug-04 20:23 spydertop/screens/modals.py
+-rw-r--r--  2.0 unx     4575 b- defN 23-Aug-04 20:23 spydertop/screens/quit.py
+-rw-r--r--  2.0 unx    11624 b- defN 23-Aug-04 20:23 spydertop/screens/setup.py
+-rw-r--r--  2.0 unx     8861 b- defN 23-Aug-04 20:23 spydertop/utils/__init__.py
+-rw-r--r--  2.0 unx     4462 b- defN 23-Aug-04 20:23 spydertop/utils/cursorlist.py
+-rw-r--r--  2.0 unx    17310 b- defN 23-Aug-04 20:23 spydertop/utils/types.py
+-rw-r--r--  2.0 unx     4754 b- defN 23-Aug-04 20:23 spydertop/widgets/__init__.py
+-rw-r--r--  2.0 unx     4539 b- defN 23-Aug-04 20:23 spydertop/widgets/form.py
+-rw-r--r--  2.0 unx     6246 b- defN 23-Aug-04 20:23 spydertop/widgets/meter.py
+-rw-r--r--  2.0 unx    19736 b- defN 23-Aug-04 20:23 spydertop/widgets/table.py
+-rw-r--r--  2.0 unx     1083 b- defN 23-Aug-04 20:23 spydertop-1.3.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7328 b- defN 23-Aug-04 20:23 spydertop-1.3.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-04 20:23 spydertop-1.3.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       44 b- defN 23-Aug-04 20:23 spydertop-1.3.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 23-Aug-04 20:23 spydertop-1.3.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3070 b- defN 23-Aug-04 20:23 spydertop-1.3.0.dist-info/RECORD
+37 files, 313768 bytes uncompressed, 87006 bytes compressed:  72.3%
```

## zipnote {}

```diff
@@ -1,22 +1,34 @@
 Filename: spydertop/__init__.py
 Comment: 
 
 Filename: spydertop/cli.py
 Comment: 
 
-Filename: spydertop/config.py
-Comment: 
-
 Filename: spydertop/model.py
 Comment: 
 
 Filename: spydertop/recordpool.py
 Comment: 
 
+Filename: spydertop/state.py
+Comment: 
+
+Filename: spydertop/config/__init__.py
+Comment: 
+
+Filename: spydertop/config/cache.py
+Comment: 
+
+Filename: spydertop/config/config.py
+Comment: 
+
+Filename: spydertop/config/secrets.py
+Comment: 
+
 Filename: spydertop/constants/__init__.py
 Comment: 
 
 Filename: spydertop/constants/columns.py
 Comment: 
 
 Filename: spydertop/constants/palettes.py
@@ -57,44 +69,44 @@
 
 Filename: spydertop/screens/setup.py
 Comment: 
 
 Filename: spydertop/utils/__init__.py
 Comment: 
 
-Filename: spydertop/utils/cache.py
-Comment: 
-
 Filename: spydertop/utils/cursorlist.py
 Comment: 
 
 Filename: spydertop/utils/types.py
 Comment: 
 
 Filename: spydertop/widgets/__init__.py
 Comment: 
 
+Filename: spydertop/widgets/form.py
+Comment: 
+
 Filename: spydertop/widgets/meter.py
 Comment: 
 
 Filename: spydertop/widgets/table.py
 Comment: 
 
-Filename: spydertop-1.2.3.dist-info/LICENSE
+Filename: spydertop-1.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: spydertop-1.2.3.dist-info/METADATA
+Filename: spydertop-1.3.0.dist-info/METADATA
 Comment: 
 
-Filename: spydertop-1.2.3.dist-info/WHEEL
+Filename: spydertop-1.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: spydertop-1.2.3.dist-info/entry_points.txt
+Filename: spydertop-1.3.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: spydertop-1.2.3.dist-info/top_level.txt
+Filename: spydertop-1.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: spydertop-1.2.3.dist-info/RECORD
+Filename: spydertop-1.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## spydertop/__init__.py

```diff
@@ -20,8 +20,8 @@
     # pylint: disable=no-value-for-parameter
     # if frozen, then we are running as a pyinstaller executable
     if getattr(sys, "frozen", False):
         cli(sys.argv[1:])
 
     # otherwise, we are running as a python module, likely for debugging
     # default to debug logging
-    cli(["--log-level", "DEVELOPMENT+"] + sys.argv[1:])
+    cli(["--log-level", "DEVELOPMENT+", "load"] + sys.argv[1:])
```

## spydertop/cli.py

```diff
@@ -5,25 +5,39 @@
 # Copyright 2022 Spyderbat, Inc. All rights reserved.
 #
 
 """
 Contains the logic to process cli arguments and start the application
 """
 
-import time
+
+from datetime import datetime, timedelta
 import gzip
-from datetime import datetime
-from typing import Optional
-from os.path import exists
+import logging
+from pathlib import Path
+from typing import Optional, TextIO
 
 import click
-from spydertop.config import Config
+from click.shell_completion import CompletionItem
+import yaml
+
+from spydertop.config import DEFAULT_API_URL, DIRS
+from spydertop.config.secrets import Secret
+from spydertop.config.config import (
+    DEFAULT_CONFIG_PATH,
+    Config,
+    ConfigError,
+    Context,
+    Focus,
+)
+from spydertop.recordpool import RecordPool
 from spydertop.screens import start_screen
 
-from spydertop.utils import convert_to_seconds
+from spydertop.utils import convert_to_seconds, get_source_name, log
+from spydertop.utils.types import LoadArgs
 
 
 class Timestamp(click.ParamType):
     """
     An absolute time or relative time, using simple units at the end,
     or a datetime string. Negative times are considered relative to now.
     Accepted units are s: seconds, m: minutes, h: hours, d: days, y: years.
@@ -36,105 +50,232 @@
     """
 
     name = "Timestamp"
 
     def convert(
         self, value, param: Optional[click.Parameter], ctx: Optional[click.Context]
     ):
+        # dateparser is a slow dependency to start up, so only import it if necessary
+        import dateparser  # pylint: disable=import-outside-toplevel
+
         if not value:
             return None
-        # try converting to datetime with iso first
-        try:
-            timestamp = datetime.fromisoformat(value)
-            return timestamp.timestamp()
-        except ValueError:
-            try:
-                timestamp = convert_to_seconds(value)
-
-                if timestamp < 0:
-                    timestamp = time.time() + timestamp
-                return timestamp
-            except ValueError:
-                return self.fail(
-                    f"{value} is not a valid timestamp. "
-                    "Please use a valid timestamp or a relative time "
-                    "using the following units: s, m, h, d, y",
-                )
+        parsed_date = dateparser.parse(value)
+        if parsed_date:
+            return parsed_date
+        return self.fail(
+            f"{value} is not a valid timestamp. "
+            "Please use a valid timestamp or a relative time.",
+        )
 
     def get_missing_message(self, param):
         return "TIMESTAMP is required to fetch the correct records"
 
+    def shell_complete(self, ctx, param, incomplete):
+        options = ["5 minutes ago", "15 minutes ago", "an hour ago", "yesterday", "now"]
+        return [
+            CompletionItem(option)
+            for option in options
+            if option.startswith(incomplete)
+        ]
+
 
 class Duration(click.ParamType):
     """
     A duration in time, using simple units.
     Accepted units are s: seconds, m: minutes, h: hours, d: days, y: years.
-    No unit is interpreted as seconds. For example:
+    An absent unit is interpreted as seconds. For example:
 
-    -5.5d = 5.5 days ago
-    -5m = 5 minutes ago
+    5.5d = 5.5 days
+    5m = 5 minutes
     """
 
     name = "Duration"
 
     def convert(
         self, value, param: Optional[click.Parameter], ctx: Optional[click.Context]
     ):
         if not value:
             return None
         try:
             timestamp = convert_to_seconds(value)
-            return timestamp
+            return timedelta(seconds=timestamp)
         except ValueError as exc:
             return self.fail(f"Unable to convert input into duration: {value} {exc}")
 
+    def shell_complete(self, ctx, param, incomplete):
+        options = ["1m", "5m", "10m", "15m", "30m", "1h"]
+        return [
+            CompletionItem(option)
+            for option in options
+            if option.startswith(incomplete)
+        ]
+
 
-class FileOrUrl(click.ParamType):
+class SecretsParam(click.ParamType):
     """
-    A text or gzipped file input, or a string url.
-    Files will automatically be opened by the proper reader,
-    and urls will be converted to a proper base url (with https, etc.)
+    The name of a secret in the config directory.
     """
 
-    name = "File or Url"
+    name = "Secrets"
 
-    def convert(
-        self, value: str, param: Optional[click.Parameter], ctx: Optional[click.Context]
-    ):
-        if not value:
-            return None
-        if exists(value):
-            try:
-                # first, determine if it is JSON or GZIP
-                tmp = open(value, "rb")  # pylint: disable=consider-using-with
-                magic_bytes = tmp.read(2)
-                tmp.close()
-                if magic_bytes == b"\x1f\x8b":
-                    # GZIP file detected
-                    return gzip.open(value, "rt")
-                # other file detected, assuming JSON
-                return open(value, "r", encoding="utf-8")
-
-            except FileNotFoundError as exc:
-                return self.fail(f"Unable to open file {value}: {exc}")
-        else:
-            # first see if it is a file, but a non-existent one
-            if value.endswith(".json") or value.endswith(".json.gz"):
-                return self.fail(f"File {value} does not exist")
-            # convert base domains into a full url base
-            return f"https://{value}" if "http" not in value else value
+    def shell_complete(self, ctx, param, incomplete):
+        secrets = Secret.get_secrets(Path(DIRS.user_config_dir))
+        secret_names = list(secrets.keys())
+        secret_names.sort()
+        return [
+            CompletionItem(secret_name)
+            for secret_name in secret_names
+            if secret_name.startswith(incomplete)
+        ]
+
+
+class ContextParam(click.ParamType):
+    """
+    The name of a context in the configuration.
+    """
+
+    name = "Contexts"
+
+    def shell_complete(self, ctx, param, incomplete):
+        try:
+            config_obj = Config.load_from_directory(Path(DIRS.user_config_dir))
+            context_names = list(config_obj.contexts.keys())
+            context_names.sort()
+            return [
+                CompletionItem(context_name)
+                for context_name in context_names
+                if context_name.startswith(incomplete)
+            ]
+        except ConfigError:
+            return []
+
+
+SUB_EPILOG = """
+Run 'spydertop COMMAND --help' for more information on a command.
+"""
+CONTEXT_SETTINGS = {"help_option_names": ["-h", "--help"]}
+
+
+def ensure_org_uid(recordpool: RecordPool, organization: str) -> Optional[str]:
+    """Converts an organization's name or uid to a uid"""
+    click.echo("Loading organizations...")
+    recordpool.load_orgs()
+    maybe_org = [
+        o
+        for o in recordpool.orgs
+        if o.get("uid") == organization or o.get("name") == organization
+    ]
+    if len(maybe_org) == 0:
+        answer = click.confirm(
+            f"Organization '{organization}' does not exist."
+            " Would you like to see a list of organizations?",
+            default=True,
+        )
+        if answer:
+            click.echo(
+                "\n".join([o["name"] for o in recordpool.orgs]),
+            )
+        return None
+    return maybe_org[0]["uid"]
+
+
+def ensure_source_uid(
+    recordpool: RecordPool, organization: Optional[str], source: str
+) -> Optional[str]:
+    """Converts a source's name or uid to a uid"""
+    if source.startswith("mach:") or source.startswith("clus:"):
+        return source
+
+    if organization is None:
+        raise click.BadParameter(
+            "You must specify an organization when specifying a source by name.",
+            param=organization,
+        )
+    click.echo("Loading sources...")
+    recordpool.load_sources(organization)
+    maybe_source = [
+        s
+        for s in recordpool.sources.get(organization, [])
+        if s.get("uid") == source or get_source_name(s) == source
+    ]
+    if len(maybe_source) == 0:
+        answer = click.confirm(
+            f"Source '{source}' does not exist. Would you like to see a list of sources?"
+        )
+        if answer:
+            click.echo(
+                [get_source_name(s) for s in recordpool.sources.get(organization, [])]
+            )
+        return None
+    return maybe_source[0]["uid"]
+
+
+@click.group(context_settings={**CONTEXT_SETTINGS})
+@click.version_option(None, "--version", "-V")
+@click.option(
+    "--config-dir",
+    "-c",
+    type=click.Path(exists=True, path_type=Path, dir_okay=True, file_okay=False),
+    default=Path(DIRS.user_config_dir),
+    help=f"The configuration file to use. Defaults to {DEFAULT_CONFIG_PATH}",
+)
+@click.option(
+    "--log-level",
+    type=str,
+    default="WARN",
+    help="What level of verbosity in logs, one of TRACEBACK, DEBUG, INFO, WARN, ERROR. If a + is \
+appended to the log level, extended logging and saving to a file will be enabled. \
+Defaults to WARN",
+    envvar="SPYDERTOP_LOG_LEVEL",
+)
+@click.pass_context
+def cli(ctx: click.Context, config_dir: Path, log_level: str):
+    """
+    Spydertop - Historical TOP Tool
+
+    Run 'spydertop COMMAND --help' for more information on a command.
+    """
+    # allow for logging from the underlying library
+    # and saving to a file if it is requested
+    if log_level.endswith("+"):
+        log_level = log_level[:-1]
+        log.log_level = logging.getLevelName(log_level)
+        log.initialize_development_logging()
+    else:
+        log.log_level = logging.getLevelName(log_level)
+
+    if isinstance(log.log_level, str):
+        log.log_level = logging.WARN
+        log.warn(
+            "Invalid log level specified, defaulting to WARN. \
+See --help for a list of valid log levels."
+        )
+
+    # Load the config file
+    if not config_dir.exists() and config_dir != Path(DIRS.user_config_dir):
+        click.echo(f"Error loading config file: {config_dir} does not exist")
+        ctx.exit(1)
+    try:
+        config_obj = Config.load_from_directory(config_dir)
+    except ConfigError as exc:
+        click.echo(f"Error loading config file: {exc}")
+        ctx.exit(1)
+    ctx.obj = {
+        "config": config_obj,
+    }
 
 
 # ignore unknown options is necessary to allow dashes in the
 # timestamp argument, but is imperfect. This will work:
 #   spydertop -300
 # but this will not:
 #   spydertop -2d
 # because it detects it as the '-d' argument
-@click.command(context_settings={"ignore_unknown_options": True})
+@cli.command(context_settings={**CONTEXT_SETTINGS, "ignore_unknown_options": True})
 @click.option(
     "--organization",
     "-g",
     type=str,
     help="The organization ID to pull data from. \
 Defaults to the values set in your spyderbat_api config",
 )
@@ -144,76 +285,344 @@
     type=str,
     help="The machine ID to pull data from. This should be in the format 'mach:aEdYih-4bia'. \
 Defaults to the values set in your spyderbat_api config",
 )
 @click.option(
     "--duration",
     "-d",
-    default=900,
     type=Duration(),
-    help="What period of time records should be pre-fetched for playback in seconds. \
-Defaults to 15 minutes",
+    help="The duration before and after the given time to pre-load for display. \
+Defaults to the values set in your spyderbat_api config",
 )
 @click.option(
     "--input",
     "-i",
     "input_file",
-    type=FileOrUrl(),
-    help="If set, spydertop with use the specified input file or domain instead of \
+    type=click.File("r"),
+    help="If set, spydertop with use the specified input file instead of \
 fetching records from the production Spyderbat API",
 )
 @click.option(
     "--output",
     "-o",
     type=click.File("w"),
     help="If set, spydertop with use the specified output file to save the loaded records",
 )
-@click.option(
-    "--confirm/--no-confirm",
-    "-c/-C",
-    default=True,
-    help="Ask for confirmation of values saved in the config file",
-)
-@click.option(
-    "--log-level",
-    type=str,
-    default="WARN",
-    help="What level of verbosity in logs, one of TRACEBACK, DEBUG, INFO, WARN, ERROR. If a + is \
-appended to the log level, extended logging and saving to a file will be enabled. \
-Defaults to WARN",
-    envvar="SPYDERTOP_LOG_LEVEL",
-)
 @click.argument("timestamp", type=Timestamp(), required=False)
-@click.version_option()
-def cli(  # pylint: disable=too-many-arguments
-    organization, machine, input_file, output, timestamp, duration, confirm, log_level
+@click.pass_context
+def load(  # pylint: disable=too-many-arguments
+    ctx: click.Context,
+    organization: Optional[str],
+    machine: Optional[str],
+    input_file: Optional[TextIO],
+    output: Optional[TextIO],
+    timestamp: Optional[datetime],
+    duration: Optional[timedelta],
 ):
     """
+    Fetches data and starts the TUI.
+
     Fetches data from the specified org and machine, or the defaults specified
     in ~/.spyderbat-api/config, and presents an htop-like interface for the state of
     the machine at the specified time.
 
     TIMESTAMP: Fetch records after this time; use negative for relative to now.
     Note: due to argument parsing limitations, this value may need to be
     passed after a -- separator, like so:
 
-    spydertop [options] -- TIMESTAMP
+    spydertop load [options] -- TIMESTAMP
 
     Durations, such as negative timestamps and the -d flag, can have an optional
     unit at the end. Accepted units are s: seconds, m: minutes, h: hours, d: days,
     y: years. Default is seconds. For example:
 
-    spydertop -- -5.5d
+    spydertop load -- -5.5d
     """
 
-    config = Config(
-        organization,
-        machine,
-        input_file,
-        output,
-        timestamp,
-        duration,
-        confirm,
-        log_level,
+    if input_file is not None and input_file.name.endswith(".gz"):
+        input_file = gzip.open(input_file.name, "rt")
+        if isinstance(input_file, gzip.GzipFile):
+            raise click.BadParameter(
+                "Input file must be a text gzip file, not a binary gzip file"
+            )
+
+    inner_config = get_config_from_ctx(ctx)
+
+    context = (
+        inner_config.contexts[inner_config.active_context]
+        if inner_config.active_context
+        else None
+    )
+    secret = context.get_secret(inner_config.directory) if context else None
+    recordpool = RecordPool(secret) if secret else None
+
+    if organization is not None and recordpool is not None:
+        organization = ensure_org_uid(recordpool, organization)
+        if organization is None:
+            return
+    if machine is not None and organization is not None and recordpool is not None:
+        machine = ensure_source_uid(recordpool, organization, machine)
+        if machine is None:
+            return
+
+    args = LoadArgs(
+        organization=organization,
+        source=machine,
+        duration=duration,
+        input=input_file,
+        output=output,
+        timestamp=timestamp,
     )
 
-    start_screen(config)
+    start_screen(ctx.obj["config"], args)
+    log.dump()
+
+
+@cli.group()
+def config():
+    """
+    Set or show the current configuration values.
+
+    Allows setting the default values for the organization, machine ids,
+    and more, and displaying the current values for configurations.
+    """
+
+
+def get_config_from_ctx(ctx: click.Context) -> Config:
+    """
+    Gets the configuration object from the context, or exits if it is not set
+    """
+    ctx.ensure_object(dict)
+    inner_config: Config = ctx.obj.get("config", None)
+    if inner_config is None:
+        click.echo("No config loaded")
+        ctx.exit(1)
+    return inner_config
+
+
+@config.command("get")
+@click.pass_context
+def get_config(ctx: click.Context):
+    """
+    Gets the currently loaded configuration
+    """
+    inner_config = get_config_from_ctx(ctx)
+
+    click.echo(f"The current configuration is located at {inner_config.directory}\n")
+    click.echo(yaml.dump(inner_config.as_dict()))
+
+
+@config.command()
+@click.argument("name", required=False, type=ContextParam())
+@click.pass_context
+def get_context(ctx: click.Context, name: Optional[str] = None):
+    """
+    Shows a specific context, or all contexts if no name is specified
+    """
+    inner_config = get_config_from_ctx(ctx)
+    if name is not None and name not in inner_config.contexts:
+        click.echo(f"Context {name} does not exist")
+        ctx.exit(1)
+    if name is not None:
+        contexts = {name: inner_config.contexts[name].as_dict()}
+    else:
+        contexts = {
+            name: context.as_dict() for name, context in inner_config.contexts.items()
+        }
+    click.echo(yaml.dump(contexts))
+
+
+@config.command()
+@click.option(
+    "--secret",
+    "-s",
+    type=SecretsParam(),
+    help="Name of the secret to use in this context. Defaults to 'default'",
+)
+@click.option(
+    "--organization",
+    "--org",
+    "-g",
+    type=str,
+    help="Name or ID of the organization to pull data from",
+)
+@click.option(
+    "--source",
+    type=str,
+    help="Name or ID of the machine or cluster to load",
+)
+@click.option(
+    "--focus",
+    "-f",
+    type=str,
+    help="ID of the record to focus on",
+)
+@click.option(
+    "--time",
+    type=str,
+    help="The default time to use when loading data. Can be an absolute time, or a relative time.",
+)
+@click.argument(
+    "name",
+    type=ContextParam(),
+)
+@click.pass_context
+def set_context(  # pylint: disable=too-many-arguments
+    ctx: click.Context,
+    secret: Optional[str],
+    name: str,
+    organization: Optional[str],
+    focus: Optional[str],
+    source: Optional[str],
+    time: Optional[str],
+):
+    """
+    Create or update a context for loading data.
+    """
+    if time is not None:
+        Timestamp().convert(time, None, None)
+    focuses = []
+    inner_config = get_config_from_ctx(ctx)
+    if name in inner_config.contexts:
+        click.echo(f"Context {name} already exists. Updating.")
+        context = inner_config.contexts[name]
+        secret = secret or context.secret_name
+        organization = organization or context.org_uid
+        source = source or context.source
+        time = time or context.time
+        focuses = context.focus
+    if focus is not None:
+        focuses = Focus.get_focuses(focus)
+    if secret is None:
+        secret = "default"
+
+    actual_secret = inner_config.get_secret(secret)
+    if actual_secret is None:
+        click.echo(f"Secret '{secret}' does not exist.")
+        return
+    recordpool = RecordPool(actual_secret)
+    if organization is not None:
+        organization = ensure_org_uid(recordpool, organization)
+        if organization is None:
+            return
+    if source is not None:
+        source = ensure_source_uid(recordpool, organization, source)
+        if source is None:
+            return
+
+    inner_config.contexts[name] = Context(
+        secret or "default", organization, source, time, focuses
+    )
+    inner_config.save()
+    click.echo(f"Context {name} saved.")
+
+
+@config.command()
+@click.argument("name", type=ContextParam(), required=True)
+@click.pass_context
+def use_context(ctx: click.Context, name: str):
+    """
+    Set the current context to use.
+    """
+    inner_config = get_config_from_ctx(ctx)
+    if name not in inner_config.contexts:
+        click.echo(f"Context {name} does not exist.")
+        return
+    inner_config.active_context = name
+    inner_config.save()
+
+
+@config.command()
+@click.argument("name", type=ContextParam(), required=True)
+@click.pass_context
+def delete_context(ctx: click.Context, name: str):
+    """
+    Delete a context from the configuration.
+    """
+    inner_config = get_config_from_ctx(ctx)
+    if name not in inner_config.contexts:
+        click.echo(f"Context {name} does not exist.")
+        return
+    click.confirm(f"Are you sure you want to delete context {name}?", abort=True)
+    del inner_config.contexts[name]
+    inner_config.save()
+
+
+@config.command("set-secret")
+@click.option(
+    "--api-key",
+    "--apikey",
+    "-k",
+    type=str,
+    help="API key generated via the Spyderbat UI",
+    required=True,
+)
+@click.option(
+    "--api-url",
+    "--apiurl",
+    "-u",
+    type=str,
+    help="URL target for api queries.",
+    default=DEFAULT_API_URL,
+)
+@click.argument("name", type=SecretsParam(), required=True)
+@click.pass_context
+def set_api_secret(
+    ctx: click.Context,
+    api_key: str,
+    api_url: Optional[str] = None,
+    name: Optional[str] = None,
+):
+    """
+    Create or update a secret for accessing the API.
+    """
+    if not name:
+        name = "default"
+    config_dir = get_config_from_ctx(ctx).directory
+    secrets = Secret.get_secrets(config_dir)
+    if name in secrets:
+        click.confirm(
+            f"Secret {name} already exists. Are you sure you want to overwrite it?",
+            abort=True,
+        )
+        click.echo(f"Updating secret {name}...")
+    else:
+        click.echo(f"Creating secret {name}...")
+
+    secrets[name] = Secret(api_key) if api_url is None else Secret(api_key, api_url)
+
+    Secret.set_secrets(config_dir, secrets)
+
+
+@config.command("get-secret")
+@click.argument("name", required=False, type=SecretsParam())
+@click.pass_context
+def get_api_secret(ctx: click.Context, name=None):
+    """Describe one or many api secrets."""
+    config_dir = get_config_from_ctx(ctx).directory
+    secrets = Secret.get_secrets(config_dir)
+    if name is not None and name not in secrets:
+        click.echo(f"Secret {name} does not exist")
+        return
+    if name:
+        secrets = {name: secrets[name].as_dict()}
+    else:
+        secrets = {name: secret.as_dict() for name, secret in secrets.items()}
+
+    click.echo(yaml.dump(secrets))
+
+
+@config.command("delete-secret")
+@click.argument("name", required=True, type=SecretsParam())
+@click.pass_context
+def delete_api_secret(ctx: click.Context, name=None):
+    """Delete an api secret"""
+    assert name is not None
+    config_dir = get_config_from_ctx(ctx).directory
+    secrets = Secret.get_secrets(config_dir)
+    if name not in secrets:
+        click.echo(f"Secret {name} does not exist.")
+        return
+    click.confirm(f"Are you sure you want to delete secret {name}?", abort=True)
+
+    del secrets[name]
+    Secret.set_secrets(config_dir, secrets)
```

## spydertop/model.py

```diff
@@ -8,115 +8,130 @@
 """
 The main app model for the application, containing all logic necessary
 to fetch and cache data from the Spyderbat API
 """
 
 from itertools import groupby
 import threading
-import gzip
 from datetime import datetime, timedelta, timezone
 from typing import Callable, Dict, Optional, List, Any, Tuple
 import uuid
 
 import orjson
 import urllib3
 
-from spydertop.config import Config
+from spydertop.config import DEFAULT_API_URL
+from spydertop.config.cache import set_user_cache
+from spydertop.config.config import Settings
+from spydertop.config.secrets import Secret
 from spydertop.recordpool import RecordPool
-from spydertop.utils import get_timezone, log, sum_element_wise
+from spydertop.state import State
+from spydertop.utils import get_machine_short_name, get_timezone, log, sum_element_wise
 from spydertop.utils.types import APIError, Record, Tree
 from spydertop.utils.cursorlist import CursorList
 from spydertop.constants import API_LOG_TYPES
 
+DEFAULT_DURATION = timedelta(minutes=5)
+
 
 class AppModel:  # pylint: disable=too-many-instance-attributes,too-many-public-methods
     """
     The main app model for the application, containing all logic necessary
-    to asynchronously fetch and cache data from the Spyderbat API. It also
-    provides a collection of quick methods to get data from the model.
+    to provide data and state to the application.
+
+    Data is divided into a few main objects:
+    - The record pool, which contains all records fetched from the API
+    - The settings, which contains all options that persist across sessions
+    - The state, which contains internal state and options that do not persist
+        across sessions, such as command line arguments
     """
 
     failed: bool = False
     failure_reason: str = ""
-    config: Config
+    settings: Settings
+    state: State
     columns_changed: bool = False
     thread: Optional[threading.Thread] = None
     selected_machine: Optional[str] = None
 
     # cache for arbitrary states, registered through
     # register_state
     _cache: Dict[str, Dict[str, Any]] = {}
 
-    _timestamp: Optional[float] = None
     _last_good_timestamp: Optional[float] = None
     _session_id: str
     _http_client: urllib3.PoolManager
 
     _record_pool: RecordPool
 
     _tree: Optional[Tree] = None
     # the event_top records grouped by machine
     _tops: Dict[str, CursorList] = {}
     # memory information for the current time, grouped by machine
     # meminfo may not be available for every time
     _meminfo: Dict[str, Optional[Dict[str, int]]] = {}
 
-    def __init__(self, config: Config) -> None:
-        self.config = config
+    def __init__(
+        self, settings: Settings, state: State, record_pool: RecordPool
+    ) -> None:
+        self.settings = settings
+        self.state = state
         self._session_id = uuid.uuid4().hex
         self._http_client = urllib3.PoolManager()
-        self._record_pool = RecordPool(config)
+        self._record_pool = record_pool
+
+        log.info("Creating model with state:")
+        log.info(repr(self.state))
 
     def __del__(self):
+        self.close()
+
+    def close(self):
+        """Close the model, cleaning up any resources"""
         if self.thread:
             self.thread.join()
+        self._record_pool.close()
 
-    def init(self) -> None:
+    def init(self, start_duration: Optional[timedelta]) -> None:
         """Initialize the model, loading data from the source. Requires config to be complete"""
-        self._timestamp = (
-            self.config.start_time.astimezone(timezone.utc).timestamp()
-            if self.config.start_time
-            else None
-        )
-
-        self._record_pool.init_api()
-
-        if not self.config.is_complete:
-            # ideally, this would never happen, as the configuration screen
-            # should complete the configuration before the model is initialized
-            raise RuntimeError("Configuration is incomplete, cannot load data")
 
         def guard():
             try:
-                self.load_data(self._timestamp, self.config.start_duration)
+                self.load_data(self.timestamp, start_duration, before=start_duration)
             except Exception as exc:  # pylint: disable=broad-except
                 self.fail("An exception occurred while loading data")
                 log.traceback(exc)
 
-        # if the output file is gzipped, open it with gzip
-        if self.config.output and self.config.output.name.endswith(".gz"):
-            self.config.output = gzip.open(self.config.output.name, "wt")
-
         thread = threading.Thread(target=guard)
         thread.start()
         self.thread = thread
 
-    def init_api(self):
-        """Initialize the API client"""
-        self._record_pool.init_api()
-
     def load_data(
         self,
         timestamp: Optional[float],
-        duration: Optional[timedelta] = None,
-        before=timedelta(seconds=120),
+        duration: Optional[timedelta],
+        before: Optional[timedelta] = None,
     ) -> None:
         """Load data from the source, either the API or a file, then process it"""
+        if before is None:
+            before = timedelta(minutes=5)
         try:
-            self._record_pool.load(timestamp, duration, before)
+            if isinstance(self._record_pool.input_, Secret):
+                if timestamp is None or self.state.source_uid is None:
+                    raise RuntimeError("Not enough information to load data from API")
+
+                self._record_pool.load_api(
+                    self.state.org_uid,
+                    self.state.source_uid,
+                    timestamp,
+                    duration or timedelta(minutes=5),
+                    before,
+                )
+            else:
+                self._record_pool.load_file()
             log.debug(
                 "Loaded Items: ",
                 {key: len(value) for key, value in self._record_pool.records.items()},
             )
         except (RuntimeError, APIError) as exc:
             log.traceback(exc)
             self.fail(str(exc))
@@ -128,15 +143,15 @@
             log.traceback(exc)
             self.fail(str(exc))
             return
 
         event_top_data = self._record_pool.records["event_top_data"].values()
         event_top_data = groupby(event_top_data, lambda record: record["muid"])
         self._tops = {
-            muid: CursorList("time", list(records), self._timestamp)
+            muid: CursorList("time", list(records), self.timestamp)
             for muid, records in event_top_data
         }
 
         self.rebuild_tree()
 
         log.info("Finished loading data")
         self._fix_state()
@@ -159,46 +174,48 @@
         Fix the state of the model after loading. This includes:
             - correcting the memory information
             - updating time_elapsed
             - updating the machine
         """
         try:
             for c_list in self._tops.values():
-                c_list.update_cursor(self._timestamp)
+                c_list.update_cursor(self.timestamp)
             # if the time is None, there was no specified time, so
             # go back to the beginning of the records
-            if self._timestamp is None:
+            if self.timestamp is None:
                 self.recover("reload")
                 return
 
-            if not self._record_pool.is_loaded(self._timestamp) and isinstance(
-                self.config.input, str
+            if not self._record_pool.is_loaded(self.timestamp) and isinstance(
+                self._record_pool.input_, Secret
             ):
-                # this is currently disabled due to errors
-                #
-                # # load data for a time farther away from the loaded
-                # # time if self._timestamp is close
-                # # this is to avoid loading data that is not needed
-                # if len(self._tops.data) == 0:
-                #     closest_time = self._timestamp
-                #     offset = 0
-                # # make sure to leave a buffer of 2 event_tops
-                # elif not self._tops.is_valid(-2):
-                #     closest_time = self._tops.data[2]["time"]
-                #     offset = -298
-                # else:
-                #     closest_time = self._tops[0]["time"]
-                #     offset = +298
-
-                # time_to_load = (
-                #     self._timestamp
-                #     if abs(self._timestamp - closest_time) > 300
-                #     else closest_time + offset
-                # )
-                time_to_load = self._timestamp
+                time_to_load = self.timestamp
+
+                if self.thread:
+                    self.thread.join()
+
+                thread = threading.Thread(
+                    target=lambda: self.load_data(
+                        time_to_load, timedelta(seconds=300), timedelta(seconds=300)
+                    )
+                )
+                thread.start()
+                self.thread = thread
+                return
+
+            # pre-emptively load more records if we're close to the end
+            if (
+                not self._record_pool.is_loaded(self.timestamp + 120)
+                or not self._record_pool.is_loaded(self.timestamp - 120)
+                and isinstance(self._record_pool.input_, Secret)
+            ):
+                time_to_load = self.timestamp
+
+                if self.thread:
+                    self.thread.join()
 
                 thread = threading.Thread(
                     target=lambda: self.load_data(
                         time_to_load, timedelta(seconds=300), timedelta(seconds=300)
                     )
                 )
                 thread.start()
@@ -215,22 +232,22 @@
                 self.selected_machine = None
             else:
                 self.selected_machine = list(
                     self._record_pool.records["model_machine"].keys()
                 )[0]
             if len(self._record_pool.records["model_machine"]) > 1:
                 # the user will have to select a machine later
-                self.selected_machine = None
+                self.selected_machine = self.selected_machine or None
 
         except Exception as exc:  # pylint: disable=broad-except
             log.err("Exception occurred while fixing state:")
             log.traceback(exc)
             self.fail(
                 f"""\
-The time {self.time} is invalid, \
+The time {self.state.time} is invalid, \
 not enough information could be loaded.\
 """
             )
 
     @staticmethod
     def _make_branch(
         rec_id: str, processes_w_children: Dict[str, List], enabled: bool
@@ -259,107 +276,117 @@
                 self.fail(str(exc))
                 return None
             except Exception as exc:  # pylint: disable=broad-except
                 self.fail("An exception occurred while loading orgs")
                 log.traceback(exc)
         return self._record_pool.orgs
 
-    def get_sources(
+    def get_sources(  # pylint: disable=too-many-arguments
         self,
+        org_uid: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         uid: Optional[str] = None,
         force_reload: bool = False,
     ) -> Optional[List[dict]]:
         """Fetch a list of sources for this api_key"""
-        if self.config.org is None:
-            return None
-        if self._record_pool.sources.get(self.config.org) is None or force_reload:
+        if self._record_pool.sources.get(org_uid) is None or force_reload:
             try:
                 self._record_pool.load_sources(
-                    self.config.org, page, page_size, uid, force_reload
+                    org_uid, page, page_size, uid, force_reload
                 )
-                if self._record_pool.sources.get(self.config.org) is not None:
+                if self._record_pool.sources.get(org_uid) is not None:
                     self.log_api(
                         API_LOG_TYPES["sources"],
-                        {"count": len(self._record_pool.sources[self.config.org])},
+                        {"count": len(self._record_pool.sources[org_uid])},
                     )
             except APIError as exc:
                 log.traceback(exc)
                 self.fail(str(exc))
                 return None
             except Exception as exc:  # pylint: disable=broad-except
                 self.fail("An exception occurred while loading sources")
                 log.traceback(exc)
-        return self._record_pool.sources.get(self.config.org)
+        return self._record_pool.sources.get(org_uid)
 
-    def get_clusters(self, force_reload: bool = False) -> Optional[List[dict]]:
+    def get_clusters(
+        self, org_uid: str, force_reload: bool = False
+    ) -> Optional[List[dict]]:
         """Fetch a list of clusters for this api_key"""
-        if self.config.org is None:
-            return None
-        if self._record_pool.clusters.get(self.config.org) is None or force_reload:
+        if self._record_pool.clusters.get(org_uid) is None or force_reload:
             try:
-                self._record_pool.load_clusters(self.config.org, force_reload)
-                if self._record_pool.clusters.get(self.config.org) is not None:
+                self._record_pool.load_clusters(org_uid, force_reload)
+                if self._record_pool.clusters.get(org_uid) is not None:
                     self.log_api(
                         API_LOG_TYPES["clusters"],
-                        {"count": len(self._record_pool.clusters[self.config.org])},
+                        {"count": len(self._record_pool.clusters[org_uid])},
                     )
             except APIError as exc:
                 log.traceback(exc)
                 self.fail(str(exc))
                 return None
             except Exception as exc:  # pylint: disable=broad-except
                 self.fail("An exception occurred while loading clusters")
                 log.traceback(exc)
-        return self._record_pool.clusters.get(self.config.org)
+        return self._record_pool.clusters.get(org_uid)
 
     def log_api(self, name: str, data: Dict[str, Any]) -> None:
         """Send logs to the spyderbat internal logging API"""
-        if not isinstance(self.config.input, str):
-            url = "https://api.spyderbat.com"
+        if not self.is_loading_from_api():
+            url = DEFAULT_API_URL
         else:
-            url = self.config.input
+            assert isinstance(self._record_pool.input_, Secret)
+            url = self._record_pool.input_.api_url
         new_data = {
             "name": name,
             "application": "spydertop",
-            "orgId": self.config.org,
+            "orgId": self.state.org_uid,
             "session_id": self._session_id,
             **data,
         }
 
         log.debug(f"Sending API log: {new_data}")
 
-        try:
-            headers = {
-                "Content-Type": "application/json",
-            }
-            if self.config.api_key is not None:
-                headers["Authorization"] = f"Bearer {self.config.api_key}"
-            # send the data to the API
-            response = self._http_client.request(
-                "POST",
-                f"{url}/api/v1/_/log",
-                headers=headers,
-                body=orjson.dumps(new_data),
-            )
-            # check the response
-            if response.status != 200:
-                # don't fail noisily, the user doesn't care about the log
-                log.debug(
-                    f"Logging API returned status {response.status} with message: {response.data}"
+        def send_log():
+            try:
+                headers = {
+                    "Content-Type": "application/json",
+                }
+                if isinstance(self._record_pool.input_, Secret):
+                    headers[
+                        "Authorization"
+                    ] = f"Bearer {self._record_pool.input_.api_key}"
+                # send the data to the API
+                response = self._http_client.request(
+                    "POST",
+                    f"{url}/api/v1/_/log",
+                    headers=headers,
+                    body=orjson.dumps(new_data),
                 )
-        except Exception as exc:  # pylint: disable=broad-except
-            log.debug("Exception when logging to API")
-            log.traceback(exc)
+                # check the response
+                if response.status != 200:
+                    # don't fail noisily, the user doesn't care about the log
+                    log.debug(
+                        f"Logging API returned status {response.status}"
+                        f" with message: {response.data}"
+                    )
+            except Exception as exc:  # pylint: disable=broad-except
+                log.debug("Exception when logging to API")
+                log.traceback(exc)
+
+        # sending logs to the API should not block the ui,
+        # so do it in a daemon thread
+        thread = threading.Thread(target=send_log)
+        thread.daemon = True
+        thread.start()
 
     def submit_feedback(self, feedback: str) -> None:
         """Submit feedback to the spyderbat internal logging API"""
         self.log_api(API_LOG_TYPES["feedback"], {"message": feedback})
-        self.config["has_submitted_feedback"] = True
+        set_user_cache("has_submitted_feedback", True)
 
     def get_value(self, key, muid: Optional[str], previous=False) -> Any:
         """Provides the specified field on the most recent or the previous
         event_top_data record. If `muid` is None, the selected machine is used,
         and if that is None, the value is summed across all machines."""
         index = 0 if not previous else -1
         muid = muid or self.selected_machine
@@ -421,36 +448,36 @@
                 continue
 
         self._tree = {}  # type: ignore
 
         # add the root processes to the tree
         if kthreadd:
             self._tree[kthreadd] = AppModel._make_branch(
-                kthreadd, processes_w_children, not self.config["collapse_tree"]
+                kthreadd, processes_w_children, not self.settings.collapse_tree
             )
             # root processes are always enabled
             self._tree[kthreadd] = (True, self._tree[kthreadd][1])
         if init:
             self._tree[init] = AppModel._make_branch(
-                init, processes_w_children, not self.config["collapse_tree"]
+                init, processes_w_children, not self.settings.collapse_tree
             )
             self._tree[init] = (True, self._tree[init][1])
 
     def recover(self, method="revert") -> None:  # pylint: disable=too-many-branches
         """Recover the state of the model, using the given method.
         The method can be one of:
             - "revert": revert to the last loaded time
             - "reload": go back to the earliest valid time
             - "retry": try to load the data again, using the input source"""
 
         log.info(f"Attempting to recover state using {method}")
 
         # the user probably wants to get their bearings
         # before moving time again
-        self.config["play"] = False
+        self.state.play = False
 
         # we can only revert if we have a previous time
         if method == "revert" and self._last_good_timestamp is None:
             method = "reload"
 
         try:
             if method == "revert":
@@ -475,28 +502,28 @@
                         self.timestamp = c_list.data[0]["time"]
                     self._correct_meminfo()
                 else:
                     log.warn("No machine available to reload from.")
 
             elif method == "retry":
                 log.info("Retrying loading from the API.")
-                if self._timestamp is None:
+                if self.timestamp is None:
                     self.fail("No timestamp to retry loading from.")
                     return
-                self.load_data(self._timestamp)
+                self.load_data(self.timestamp, DEFAULT_DURATION)
 
             elif isinstance(method, float):
                 log.info("Loading from custom time.")
                 self.timestamp = method
 
             # sanity check
             if not self.is_valid():
                 self.fail("Recovering failed to find a valid time.")
                 et_data = self._record_pool.records["event_top_data"]
-                log.debug(f"Time: {self._timestamp}, # of Records: {len(et_data)}")
+                log.debug(f"Time: {self.state.time}, # of Records: {len(et_data)}")
                 return
 
             self.failed = False
             self.failure_reason = ""
         except Exception as exc:  # pylint: disable=broad-except
             log.err("Exception occurred while recovering:")
             log.traceback(exc)
@@ -517,15 +544,15 @@
                 if not self.tops_valid(muid_inner):
                     return False
             return True
         return (
             muid in self._tops
             and self._tops[muid].is_valid(0)
             and self._tops[muid].is_valid(-1)
-            and abs(self._tops[muid][0]["time"] - self._timestamp) < grace_period
+            and abs(self._tops[muid][0]["time"] - self.timestamp) < grace_period
         )
 
     def use_state(
         self, name: str, initial_value: Dict[str, Any]
     ) -> Tuple[Dict[str, Any], Callable]:
         """Manage state similar to a React state; this is used to retain
         information after resize"""
@@ -538,68 +565,92 @@
         return self._cache[name], set_state
 
     def is_valid(self) -> bool:
         """Determine if there is enough information
         loaded to be able to use the data"""
         return (
             self._record_pool.loaded
-            and self._timestamp is not None
+            and self.timestamp is not None
             and (
-                self._record_pool.is_loaded(self._timestamp)
-                or not isinstance(self.config.input, str)
+                self._record_pool.is_loaded(self.timestamp)
+                or not isinstance(self._record_pool.input_, Secret)
             )
         )
 
     def clear(self) -> None:
         """Remove all loaded data from the model"""
-        self._timestamp = None
+        self.state.time = None
         self._last_good_timestamp = None
-        self._record_pool = RecordPool(self.config)
+        self._record_pool.clear()
 
         self._tree = None
         self._tops = {}
         self.selected_machine = None
         self._meminfo = {}
 
         self.failed = False
         self.failure_reason = ""
         self.columns_changed = False
 
     def is_loaded(self, timestamp: float) -> bool:
         """Return whether the model has loaded data for the given time"""
         return self._record_pool.is_loaded(timestamp) or not isinstance(
-            self.config.input, str
+            self._record_pool.input_, Secret
         )
 
+    def is_loading_from_api(self) -> bool:
+        """Return whether the model is currently loading data from the API"""
+        return isinstance(self._record_pool.input_, Secret)
+
     def get_record_by_id(self, record_id: str) -> Optional[Record]:
         """Get a record from the record pool by its ID"""
         for group in self._record_pool.records.values():
             if record_id in group:
                 return group[record_id]
         return None
 
+    def get_machine_short_name(self, machine_id: str) -> str:
+        """Get the short name of a machine"""
+        source = [
+            source
+            for source in self._record_pool.sources.get(self.state.org_uid, [])
+            if source["id"] == machine_id
+        ]
+        alternative_name = (
+            get_machine_short_name(self.machines[machine_id])
+            if machine_id in self.machines
+            else machine_id
+        )
+        if len(source) == 0:
+            return alternative_name
+        source_name = source[0].get("description", source[0].get("runtime_description"))
+        return source_name or alternative_name
+
     @property
     def loaded(self) -> bool:
         """Return whether the model has loaded data"""
-        return self._record_pool.loaded
+        if not self._record_pool.loaded or self.timestamp is None:
+            return False
+
+        return self.is_loaded(self.timestamp)
 
     @property
     def progress(self) -> float:
         """Return the progress of the model"""
         return self._record_pool.progress
 
     @property
-    def state(self) -> str:
+    def status(self) -> str:
         """The current status of the model"""
         if log.log_level <= log.DEBUG:
             try:
                 return log.get_last_line()
             except IndexError:
                 pass
-        return f"Time: {self.time}"
+        return f"Time: {self.state.time}"
 
     @property
     def memory(self) -> Optional[Dict[str, int]]:
         """The most recent memory usage data"""
         if not self.tops_valid():
             return None
         if self.selected_machine is not None:
@@ -657,29 +708,25 @@
             ),
         }
         """
         if self._tree is None:
             raise RuntimeError("The tree is not yet loaded.")
         return self._tree
 
-    # time properties
-    @property
-    def time(self) -> Optional[datetime]:
-        """The current time, as a datetime object"""
-        if self._timestamp is None:
-            return None
-        return datetime.fromtimestamp(self._timestamp, tz=timezone.utc).astimezone(
-            get_timezone(self)
-        )
-
     @property
     def timestamp(self) -> Optional[float]:
         """The current time, as a float"""
-        return self._timestamp
+        return self.state.time.timestamp() if self.state.time is not None else None
 
     @timestamp.setter
     def timestamp(self, value: Optional[float]) -> None:
         # set the current time and fix the state
-        self._timestamp = value
+        self.state.time = (
+            datetime.fromtimestamp(value, tz=timezone.utc).astimezone(
+                get_timezone(self.settings)
+            )
+            if value is not None
+            else None
+        )
         self._fix_state()
         if not self.failed:
-            self._last_good_timestamp = self._timestamp
+            self._last_good_timestamp = self.timestamp
```

## spydertop/recordpool.py

```diff
@@ -11,163 +11,178 @@
 """
 
 
 import asyncio
 from collections import defaultdict
 from concurrent.futures import Future, ThreadPoolExecutor, as_completed
 from datetime import timedelta
+import gzip
 import multiprocessing
-from typing import DefaultDict, Dict, List, Optional, Union
+from typing import DefaultDict, Dict, List, Optional, TextIO, Union
 
 import orjson
 import urllib3
 from urllib3.exceptions import MaxRetryError
 
-from spydertop.config import Config
-from spydertop.utils import log
-from spydertop.utils.cache import DEFAULT_TIMEOUT, cache_block
+from spydertop.config.secrets import Secret
+from spydertop.utils import log, obscure_key
+from spydertop.config.cache import DEFAULT_TIMEOUT, cache_block
 from spydertop.utils.types import APIError, Record, TimeSpanTracker
 
 
 class RecordPool:
     """
     Handles the loading, and storing, the records.
     The model is meant to use this class to provide data in a better format
     to the UI elements.
     """
 
     loaded: bool = False
     progress: float = 0.0
-    records: DefaultDict[str, Dict[str, Record]]
+    input_: Union[Secret, TextIO]
+    records: DefaultDict[str, Dict[str, Record]] = defaultdict(lambda: {})
     orgs: List[dict] = []
     sources: Dict[str, List[dict]] = {}
     clusters: Dict[str, List[dict]] = {}
 
-    _config: Config
+    _output: Optional[TextIO]
     _time_span_tracker = TimeSpanTracker()
     _connection_pool: Optional[urllib3.PoolManager] = None
 
-    def __init__(self, config: Config):
-        self.records = defaultdict(lambda: {})
-        self._config = config
-
-    def init_api(self) -> None:
-        """Initialize the API client"""
-        if isinstance(self._config.input, str) and self._connection_pool is None:
+    def __init__(
+        self,
+        input_src: Union[Secret, TextIO],
+        output: Optional[TextIO] = None,
+    ):
+        self.input_ = input_src
+        self._output = output
+
+        # if the output file is gzipped, open it with gzip
+        if self._output and self._output.name.endswith(".gz"):
+            self._output = gzip.open(self._output.name, "wt")
+        if isinstance(self.input_, Secret) and self._connection_pool is None:
             self._connection_pool = urllib3.PoolManager()
 
-    def load(
+    def __del__(self):
+        self.close()
+
+    def close(self):
+        """Close the record pool"""
+        if not isinstance(self._output, Secret) and self._output is not None:
+            self._output.close()
+
+    def load_api(  # pylint: disable=too-many-arguments
         self,
-        timestamp: Optional[float],
-        duration: Optional[timedelta] = None,
+        org_uid: str,
+        source_uid: str,
+        timestamp: float,
+        duration: timedelta,
         before=timedelta(seconds=120),
     ):
         """Load data from the source, either the API or a file, then process it"""
-        self.loaded = False
-        if duration is None:
-            duration = self._config.start_duration
         log.info(f"Loading data for time: {timestamp} and duration: {duration}")
         self.loaded = False
         self.progress = 0.0
 
-        source = self._config.input
+        data_source = self.input_
 
-        if isinstance(source, str):
-            # url, load data from api
+        if not isinstance(data_source, Secret):
+            raise RuntimeError("Data source must be a Secret when loading from API")
 
-            if timestamp is None:
-                raise RuntimeError("No start time specified")
-            if not self._config.api_key:
-                raise RuntimeError("No API key specified")
-            assert self._config.machine is not None
-
-            input_data = {
-                # request data from a bit earlier, so that the information is properly filled out
-                "start_time": timestamp - before.total_seconds() + 30,
-                "end_time": timestamp + duration.total_seconds(),
-                "org_uid": self._config.org,
-            }
+        input_data = {
+            # request data from a bit earlier, so that the information is properly filled out
+            "start_time": timestamp - before.total_seconds() + 30,
+            "end_time": timestamp + duration.total_seconds(),
+            "org_uid": org_uid,
+        }
+
+        # we need more than one event_top record, so a buffer of 30 seconds is used
+        # to make sure the data is available
+        self._time_span_tracker.add_time_span(
+            input_data["start_time"] + 30, input_data["end_time"]
+        )
 
-            # we need more than one event_top record, so a buffer of 30 seconds is used
-            # to make sure the data is available
-            self._time_span_tracker.add_time_span(
-                input_data["start_time"] + 30, input_data["end_time"]
+        if source_uid.startswith("clus:"):
+            # this is a cluster, so we need to get the k8s data
+            # and then query each node
+            log.info("Loading cluster data")
+            k8s_data = self.guard_api_call(
+                method="POST",
+                url="/api/v1/source/query/",
+                **input_data,
+                src_uid=f"{source_uid}_base",
+                data_type="k8s",
             )
-
-            if self._config.machine.startswith("clus:"):
-                # this is a cluster, so we need to get the k8s data
-                # and then query each node
-                log.info("Loading cluster data")
-                k8s_data = self.guard_api_call(
-                    method="POST",
-                    url="/api/v1/source/query/",
-                    **input_data,
-                    src_uid=self._config.machine,
-                    data_type="k8s",
-                )
-                log.info("Parsing cluster data")
-                self._process_records(k8s_data.split(b"\n"), 0.1, parallel=False)
-                log.info("Loading node data")
-                sources = [
-                    node["muid"] for node in self.records["model_k8s_node"].values()
-                ]
-            else:
-                self.progress = 0.1
-                log.info("Loading machine data")
-                sources = [self._config.machine]
-
-            def call_api(data_type: str, src_id: str):
-                ndjson = self.guard_api_call(
-                    method="POST",
-                    url="/api/v1/source/query/",
-                    **input_data,
-                    src_uid=src_id,
-                    data_type=data_type,
-                )
-                return ndjson.split(b"\n")
-
-            async def load():
-                nonlocal lines
-                # future is unsubscriptable in python 3.7
-                threads: List[Future] = []  # : List[Future[List[bytes]]]
-                with ThreadPoolExecutor() as executor:
-                    for source in sources:
-                        for data_type in ["htop", "spydergraph"]:
-                            threads.append(executor.submit(call_api, data_type, source))
-                    for thread in as_completed(threads):
-                        self._process_records(
-                            thread.result(), 0.9 / len(threads), parallel=False
-                        )
-                        await asyncio.sleep(0)  # try to let the UI update
-
-            asyncio.run(load())
+            log.info("Parsing cluster data")
+            self._process_records(k8s_data.split(b"\n"), 0.1, parallel=False)
+            log.info("Loading node data")
+            sources = [node["muid"] for node in self.records["model_k8s_node"].values()]
         else:
-            # file, read in records and parse
-            log.info(f"Reading records from input file: {source.name}")
+            self.progress = 0.1
+            log.info("Loading machine data")
+            sources = [source_uid]
+
+        def call_api(data_type: str, src_id: str):
+            ndjson = self.guard_api_call(
+                method="POST",
+                url="/api/v1/source/query/",
+                **input_data,
+                src_uid=src_id,
+                data_type=data_type,
+            )
+            return ndjson.split(b"\n")
 
-            lines = source.readlines()
-            if len(lines) == 0:
-                # file was most likely already read
-                raise RuntimeError(
-                    "The current time is unloaded, but input is from a file. \
-No more records can be loaded."
-                )
-            self._process_records(lines, 1.0)
+        async def load():
+            nonlocal lines
+            # future is unsubscriptable in python 3.7
+            threads: List[Future] = []  # : List[Future[List[bytes]]]
+            with ThreadPoolExecutor() as executor:
+                for source in sources:
+                    for data_type in ["htop", "spydergraph"]:
+                        threads.append(executor.submit(call_api, data_type, source))
+                for thread in as_completed(threads):
+                    self._process_records(
+                        thread.result(), 0.9 / len(threads), parallel=False
+                    )
+                    await asyncio.sleep(0)  # try to let the UI update
+
+        asyncio.run(load())
 
-        if self._config.output:
+        if self._output is not None:
             lines = [
                 orjson.dumps(record).decode() + "\n"
                 for group in self.records.values()
                 for record in group.values()
             ]
-            self._config.output.writelines(lines)
+            self._output.writelines(lines)
 
         self.loaded = True
         log.debug("Completed loading records")
 
+    def load_file(self):
+        """Load data from a file, then process it"""
+        self.loaded = False
+        self.progress = 0.0
+        if isinstance(self.input_, Secret):
+            raise RuntimeError("Data source must be a file when loading from file")
+        # file, read in records and parse
+        log.info(f"Reading records from input file: {self.input_.name}")
+
+        lines = self.input_.readlines()
+        if len(lines) == 0:
+            # file was most likely already read
+            raise RuntimeError(
+                "The current time is unloaded, but input is from a file. \
+No more records can be loaded."
+            )
+        self._process_records(lines, 1.0)
+
+        self.loaded = True
+        log.debug("Completed loading records from file")
+
     def _process_records(
         self,
         lines: Union[List[str], List[bytes]],
         progress_increase: float,
         parallel=True,
     ) -> None:
         """Process the loaded records, parsing them and adding them to the model"""
@@ -217,15 +232,15 @@
     def load_orgs(self, force_reload=False) -> None:
         """Fetch a list of organization for this api_key"""
 
         orgs = self.guard_api_call(
             method="GET",
             url="/api/v1/org/",
             enable_cache=True,
-            timeout=(timedelta(minutes=0) if force_reload else timedelta(hours=1)),
+            timeout=(timedelta(minutes=0) if force_reload else timedelta(hours=6)),
         )
         orgs = orjson.loads(orgs)
         self.orgs = orgs
 
     def load_sources(  # pylint: disable=too-many-arguments
         self,
         org_uid: str,
@@ -246,29 +261,29 @@
             kwargs["page_size"] = page_size
         if uid is not None:
             kwargs["agent_uid_equals"] = uid
         raw_sources = self.guard_api_call(
             method="GET",
             url=f"/api/v1/org/{org_uid}/source/",
             enable_cache=True,
-            timeout=(timedelta(minutes=0) if force_reload else timedelta(minutes=15)),
+            timeout=(timedelta(minutes=0) if force_reload else timedelta(hours=1)),
             **kwargs,
         )
         sources: List = orjson.loads(raw_sources)
 
         if len(sources) > 0:
             self.sources[org_uid] = sources
 
     def load_clusters(self, org_uid: str, force_reload=False) -> None:
         """Fetch a list of clusters for this api_key"""
         response = self.guard_api_call(
             "GET",
             f"/api/v1/org/{org_uid}/cluster/",
             enable_cache=True,
-            timeout=(timedelta(minutes=0) if force_reload else timedelta(minutes=15)),
+            timeout=(timedelta(minutes=0) if force_reload else timedelta(hours=1)),
         )
         # parse the response
         self.clusters[org_uid] = orjson.loads(response)
 
     def guard_api_call(
         self,
         method: str,
@@ -278,31 +293,34 @@
         **input_data,
     ) -> bytes:
         """Calls the api with the given arguments, properly handling any errors
         in the API call and converting them to an APIError"""
 
         if self._connection_pool is None:
             raise RuntimeError("Connection pool is not initialized")
-        if not isinstance(self._config.input, str):
-            raise ValueError("Data cannot be loaded from an API; there is no url")
+        if not isinstance(self.input_, Secret):
+            raise ValueError(
+                "Data cannot be loaded from an API, input is from somewhere else."
+            )
 
-        full_url = self._config.input + url
+        if not self.input_.api_url.startswith("http"):
+            base_url = f"https://{self.input_.api_url}"
+        else:
+            base_url = self.input_.api_url
+
+        full_url = base_url + url
         conn_pool = self._connection_pool
 
         def make_api_call():
-            if self._config.api_key is None:
-                raise APIError("API key is not set")
+            assert isinstance(self.input_, Secret)
             headers = {
-                "Authorization": f"Bearer {self._config.api_key}",
+                "Authorization": f"Bearer {self.input_.api_key}",
                 "Content-Type": "application/json",
             }
-            assert isinstance(self._config.input, str)
-            log.debug(
-                f"Making API call to {self._config.input + url} with ", input_data
-            )
+            log.debug(f"Making API call to {full_url} with ", input_data)
             try:
                 api_response = conn_pool.request(
                     method,
                     url=full_url,
                     headers=headers,
                     body=(orjson.dumps(input_data) if method == "POST" else None),
                 )
@@ -312,15 +330,15 @@
                     f"{api_response.headers.get('x-context-uid', None)}, "
                     f"status: {api_response.status}, size: {len(api_response.data.split(newline))}"
                 )
 
             except MaxRetryError as exc:
                 raise APIError(
                     "There was an issue trying to connect to the API."
-                    f"Is the url {self._config.input} correct?"
+                    f"Is the url {self.input_} correct?"
                 ) from exc
             except Exception as exc:
                 log.traceback(exc)
                 log.debug(
                     f"""\
 Debug info:
 API Call: {url}
@@ -330,17 +348,16 @@
                 )
                 raise APIError(
                     "There was an issue trying to connect to the API."
                 ) from exc
 
             if api_response.status != 200:
                 sanitized_headers = {
-                    "Authorization": f"Bearer {self._config.api_key[:3]}"
-                    f"...{self._config.api_key[-3:]}",
                     **headers,
+                    "Authorization": f"Bearer {obscure_key(self.input_.api_key)}",
                 }
                 log.debug(
                     f"""\
 Debug info:
 API Call: {method} {url}
 Input data: {input_data}
 Status code: {api_response.status}
@@ -354,14 +371,22 @@
                 raise APIError(
                     f"Loading data from the api failed with reason: {api_response.reason}"
                 )
             return api_response.data
 
         if enable_cache:
             data = cache_block(
-                orjson.dumps((self._config.api_key, method, full_url, input_data)),
+                orjson.dumps((self.input_.api_key, method, full_url, input_data)),
                 make_api_call,
                 timeout=timeout,
             )
         else:
             data = make_api_call()
         return data
+
+    def clear(self):
+        """Clear all data from the loader"""
+        self.records.clear()
+        self.orgs.clear()
+        self.sources.clear()
+        self.clusters.clear()
+        self._time_span_tracker = TimeSpanTracker()
```

## spydertop/constants/columns.py

```diff
@@ -70,15 +70,15 @@
         )
         self.enabled = enabled
         str_field: str = field or name.lower()
         if value_type is datetime:
             self.value_getter = value_getter or (
                 lambda m, r: datetime.fromtimestamp(
                     float(r[str_field]), timezone.utc
-                ).astimezone(get_timezone(m))
+                ).astimezone(get_timezone(m.settings))
                 if str_field in r
                 else None
             )
         else:
             self.value_getter = value_getter or (lambda m, r: value_type(r[str_field]))
         self.value_formatter = value_formatter or (lambda m, r, v: str(v))
 
@@ -202,14 +202,21 @@
 PROCESS_COLUMNS = [
     Column("ID", 30, str, enabled=False),
     Column("NAME", 15, str, enabled=False),
     Column("PPID", 7, int, enabled=False),
     Column("PID", 7, int),
     Column("MUID", 16, str, enabled=False),
     Column(
+        "Machine",
+        16,
+        str,
+        enabled=False,
+        value_getter=lambda m, x: m.get_machine_short_name(x["muid"]),
+    ),
+    Column(
         "USER",
         9,
         str,
         field="euser",
         value_formatter=lambda m, r, x: x if x != "root" else "${8,1}root",
     ),
     Column(
@@ -621,29 +628,29 @@
         str,
         value_formatter=lambda m, c, x: x if x != "/pause" else "${8,1}/pause",
     ),
     Column(
         "CREATED",
         15,
         datetime,
-        value_formatter=lambda m, c, x: pretty_time((m.time - x).total_seconds())
+        value_formatter=lambda m, c, x: pretty_time((m.state.time - x).total_seconds())
         + " ago",
     ),
     Column("START_TIME", 27, datetime, field="valid_from", enabled=False),
     Column(
         "STATUS",
         15,
         datetime,
         value_getter=lambda m, c: map_optional(
             lambda x: datetime.fromtimestamp(x, timezone.utc).astimezone(
-                get_timezone(m)
+                get_timezone(m.settings)
             ),
             c.get("container_detail_state", {}).get("StartedAt"),
         ),
-        value_formatter=lambda m, c, x: f"Up {pretty_time((m.time - x).total_seconds())}",
+        value_formatter=lambda m, c, x: f"Up {pretty_time((m.state.time - x).total_seconds())}",
     ),
     Column(
         "PORTS",
         12,
         list,
         field="port_bindings",
         value_formatter=lambda m, c, x: ", ".join(x),
```

## spydertop/screens/__init__.py

```diff
@@ -6,72 +6,156 @@
 #
 
 """
 The screens module contains all of the frames in the application and
 the start_screen function, which initiates the main portion of the application
 """
 
+from datetime import timedelta
 from os import environ
 import os
-from asciimatics.screen import ManagedScreen
+import sys
+from typing import Callable, List
+from asciimatics.screen import ManagedScreen, Screen
 from asciimatics.scene import Scene
 from asciimatics.exceptions import ResizeScreenError
-from spydertop.config import Config
+import yaml
 
+from spydertop.config.config import Config
 from spydertop.model import AppModel
+from spydertop.recordpool import RecordPool
 from spydertop.screens.loading import LoadingFrame
 from spydertop.screens.main import MainFrame
 from spydertop.screens.help import HelpFrame
 from spydertop.screens.failure import FailureFrame
 from spydertop.screens.config import ConfigurationFrame
 from spydertop.screens.feedback import FeedbackFrame
 from spydertop.screens.quit import QuitFrame
+from spydertop.state import ExitReason, State
 from spydertop.utils import log
 from spydertop.constants import API_LOG_TYPES
+from spydertop.utils.types import LoadArgs
 
 
-def start_screen(config: Config) -> None:
+def start_screen(
+    config: Config,
+    args: LoadArgs,
+) -> None:
     """Initializes and manages the asciimatics screen"""
-    log.debug("Initial config:\n", config)
+    while True:
+        model = start_config_wizard(config, args)
+        model.log_api(
+            API_LOG_TYPES["startup"], {"term": environ.get("TERM", "unknown")}
+        )
+        model.init(
+            args.duration or timedelta(minutes=config.settings.default_duration_minutes)
+        )
+
+        context = (
+            config.contexts.get(config.active_context)
+            if config.active_context is not None
+            else None
+        )
+        focus = context.focus if context is not None else []
+
+        run_screens(
+            lambda screen: [
+                Scene([LoadingFrame(screen, model)], -1, name="Loading"),
+                Scene([MainFrame(screen, model, focus)], -1, name="Main"),
+                Scene([HelpFrame(screen, model)], -1, name="Help"),
+                Scene([FailureFrame(screen, model)], -1, name="Failure"),
+                Scene([FeedbackFrame(screen, model)], -1, name="Feedback"),
+                Scene([QuitFrame(screen, model)], -1, name="Quit"),
+            ]
+        )
+
+        if model.state.exit_reason == ExitReason.QUIT:
+            break
+        if args.input is not None:
+            log.warn(
+                "Cannot return to configuration wizard when"
+                " reading from a file. Exiting instead"
+            )
+            break
+        model.close()
+        log.info("Returning to configuration wizard")
+
+    # save settings which should persist across sessions
+    config.save()
+
+    model.log_api(
+        API_LOG_TYPES["shutdown"],
+        {"failure_state": model.failure_reason if model.failed else "None"},
+    )
+    model.close()
+
+    log.info("Gracefully exiting")
+
+
+def start_config_wizard(
+    config: Config,
+    args: LoadArgs,
+) -> AppModel:
+    """
+    Starts a new Asciimatics screen with the configuration wizard,
+    returning the new config
+    """
+    log.debug(
+        "Configuration wizard started with initial config:\n",
+        yaml.dump(config.as_dict()),
+    )
+    state = State()
+    if args.input is None:
+        model = None
+
+        run_screens(
+            lambda screen: [
+                Scene(
+                    [ConfigurationFrame(screen, config, state, args)],
+                    -1,
+                    name="Config",
+                )
+            ]
+        )
+        if state.exit_reason == ExitReason.QUIT:
+            sys.exit(0)
+
+        if config.active_context is None:
+            log.err("No context selected, exiting")
+            sys.exit(1)
+        secret = config.contexts[config.active_context].get_secret(config.directory)
+        if secret is None:
+            log.err(
+                "Failed to get secret "
+                f"'{config.contexts[config.active_context].secret_name}', exiting"
+            )
+            sys.exit(1)
+        model = AppModel(config.settings, state, RecordPool(secret, args.output))
+    else:
+        model = AppModel(config.settings, state, RecordPool(args.input, args.output))
+
+    return model
 
+
+def run_screens(build_screens: Callable[[Screen], List[Scene]]):
+    """Runs the given screens in a managed screen"""
     last_scene = None
-    model = AppModel(config)
-    model.log_api(API_LOG_TYPES["startup"], {"term": environ.get("TERM", "unknown")})
 
     # set delay for escape key
     os.environ.setdefault("ESCDELAY", "10")
 
     while True:
         try:
             with ManagedScreen() as screen:
                 screen.play(
-                    [
-                        Scene([ConfigurationFrame(screen, model)], -1, name="Config"),
-                        Scene([LoadingFrame(screen, model)], -1, name="Loading"),
-                        Scene([MainFrame(screen, model)], -1, name="Main"),
-                        Scene([HelpFrame(screen, model)], -1, name="Help"),
-                        Scene([FailureFrame(screen, model)], -1, name="Failure"),
-                        Scene([FeedbackFrame(screen, model)], -1, name="Feedback"),
-                        Scene([QuitFrame(screen, model)], -1, name="Quit"),
-                    ],
+                    scenes=build_screens(screen),
                     stop_on_resize=True,
                     start_scene=last_scene,
                     allow_int=True,
                 )
-
-            # save settings which should persist across sessions
-            config.dump()
-            config.cleanup()
-
-            model.log_api(
-                API_LOG_TYPES["shutdown"],
-                {"failure_state": model.failure_reason if model.failed else "None"},
-            )
-
-            log.info("Gracefully exiting")
             # If we get here, we have exited the screen,
             # it is safe to print logs
             log.dump()
             return
         except ResizeScreenError as exc:
             log.info("Screen resized")
             log.dump()
```

## spydertop/screens/config.py

```diff
@@ -6,103 +6,158 @@
 #
 
 """
 The configuration frame handles guiding the user through finishing setup or filling in
 the information missing from the configuration file.
 """
 
-import os
+from dataclasses import dataclass
+from enum import Enum
 import fnmatch
 import re
-from time import sleep
 from threading import Thread
-from datetime import datetime, time, timedelta, timezone, tzinfo
-from typing import Any, Callable, List, Optional, Union
+from datetime import datetime, timedelta, timezone
+from typing import Callable, List, Optional, TextIO
 
-import yaml
 from asciimatics.widgets import (
     Frame,
     Text,
     Layout,
     Button,
     Label,
     DatePicker,
     TimePicker,
-    CheckBox,
 )
 from asciimatics.screen import Screen
 from asciimatics.event import KeyboardEvent
-from asciimatics.exceptions import NextScene, StopApplication
+from asciimatics.exceptions import StopApplication
+from spydertop.config import DEFAULT_API_URL
 
-from spydertop.config import Config
+from spydertop.config.config import Config, Context
+from spydertop.config.secrets import Secret
 from spydertop.constants.columns import Column
 from spydertop.model import AppModel
+from spydertop.recordpool import RecordPool
+from spydertop.state import ExitReason, State
+from spydertop.utils.types import APIError, LoadArgs
 from spydertop.widgets import FuncLabel, Padding
 from spydertop.utils import (
     get_timezone,
     pretty_datetime,
     log,
 )
 from spydertop.constants import API_LOG_TYPES, COLOR_REGEX
 from spydertop.widgets.table import Table
 
 
+@dataclass
+class ConfigState:  # pylint: disable=too-many-instance-attributes
+    """State for the configuration frame"""
+
+    duration: timedelta
+    has_account: Optional[bool] = None
+    api_key: Optional[str] = None
+    source_glob: Optional[str] = None
+    looking_for_sources: bool = False
+    force_reload: bool = False
+    created_account: bool = False
+    notification: Optional[str] = None
+    failure_reason: Optional[str] = None
+
+
+class ConfigStep(Enum):
+    """Enum for the different configuration steps"""
+
+    HAS_ACCOUNT = 0
+    API_KEY = 1
+    ORGANIZATION = 2
+    SOURCE = 3
+    TIME = 4
+    FINISH = -1
+
+
 class ConfigurationFrame(Frame):  # pylint: disable=too-many-instance-attributes
     """Frame for initial configuration of the application
     to prepare for API access. This frame has several views,
     and switches between them by clearing the layout and rebuilding it."""
 
     config: Config
-    model: AppModel
+    state: State
+    recordpool: Optional[RecordPool] = None
 
     thread: Optional[Thread] = None
+    cache: ConfigState
     _on_submit: Optional[Callable] = None
     _needs_build: bool = True
+    _ouptut: Optional[TextIO]
 
-    def __init__(self, screen: Screen, model: AppModel) -> None:
+    def __init__(
+        self,
+        screen: Screen,
+        config: Config,
+        state: State,
+        args: LoadArgs,
+    ) -> None:
         super().__init__(  # pylint: disable=duplicate-code
             screen,
             screen.height,
             screen.width,
             has_border=False,
             can_scroll=False,
             name="Configuration",
         )
 
-        self.config = model.config
-        self.model = model
+        self.config = config
+        self.state = state
+        self.args = args
 
-        self.cache, self.set_cache = model.use_state(
+        self.cache = self.state.use_state(
             str(self._name),
-            {
-                "has_account": None,  # Optional[bool]
-                "orgs": None,  # Optional[List]
-                "sources": None,  # Optional[List]
-                "source_glob": None,  # Optional[str]
-                "looking_for_sources": False,  # bool
-                "force_reload": False,  # bool
-                "needs_saving": False,  # bool
-                "created_account": False,  # bool
-                "notification": None,  # Optional[str]
-            },
+            ConfigState(
+                duration=timedelta(minutes=config.settings.default_duration_minutes)
+            ),
+        )
+
+        # set up information that is already in config or args
+        if self.config.active_context is not None:
+            context = self.config.contexts[self.config.active_context]
+            secret = context.get_secret(config.directory)
+            if secret is not None:
+                self.set_api_key(secret.api_key, secret.api_url)
+                self.cache.has_account = True
+            self.state.org_uid = context.org_uid or ""
+            self.state.source_uid = context.source
+            if context.time is not None:
+                import dateparser  # pylint: disable=import-outside-toplevel
+
+                self.state.time = dateparser.parse(context.time)
+                log.log("parsing time:", context, self.state.time)
+
+        if self.args.source is not None:
+            if "*" in self.args.source:
+                self.cache.source_glob = self.args.source
+                self.state.source_uid = None
+            else:
+                self.state.source_uid = self.args.source
+
+        self.cache.duration = args.duration or timedelta(
+            minutes=config.settings.default_duration_minutes
         )
+        self.state.time = args.timestamp or self.state.time
+
+        self.state.org_uid = self.args.organization or self.state.org_uid
 
         self.layout = Layout([1, 6, 1], fill_frame=True)
         self.add_layout(self.layout)
         self.footer = Layout([1, 3, 3, 1])
         self.add_layout(self.footer)
 
-        self.set_theme(self.config["theme"])
+        self.set_theme(self.config.settings.theme)
 
     def update(self, frame_no):
-        if not self._needs_build and self.model.loaded:
-            # we have returned from Main, reset state
-            self._needs_build = True
-            self.model.clear()
-
         if self._needs_build:
             if self.thread:
                 self.thread.join()
                 self.thread = None
 
             self.build_next_layout()
 
@@ -117,387 +172,341 @@
         if isinstance(event, KeyboardEvent):
             if event.key_code == ord("\n"):
                 if self._on_submit:
                     self._on_submit()
                     self._on_submit = None
         return super().process_event(event)
 
-    def build_next_layout(  # pylint: disable=too-many-branches,too-many-statements,too-many-return-statements
+    def _pick_current_step(self) -> ConfigStep:
+        """Determines which step of the configuration process to display next"""
+        if not self.cache.has_account:
+            return ConfigStep.HAS_ACCOUNT
+        if self.cache.api_key is None:
+            return ConfigStep.API_KEY
+        if self.state.org_uid == "":
+            return ConfigStep.ORGANIZATION
+        if self.state.source_uid is None:
+            return ConfigStep.SOURCE
+        if self.state.time is None:
+            return ConfigStep.TIME
+        return ConfigStep.FINISH
+
+    def build_next_layout(  # pylint: disable=too-many-branches,too-many-statements,too-many-locals,too-many-return-statements
         self,
     ) -> None:
         """Determines which layout to display next based on the state of the config"""
-
         self._needs_build = False
         self._on_submit = None
         self.layout.clear_widgets()
         self.footer.clear_widgets()
 
+        current_step = self._pick_current_step()
+
         # add padding which is 20% of the height of the screen (without the title)
         self.layout.add_widget(Padding(max(int(self.screen.height * 0.2) - 2, 0)), 1)
         self.layout.add_widget(
             FuncLabel(
                 lambda: """\
      
      
 """,
             ),
             1,
         )
 
         # if the model failed to load, display the error message
-        if self.model.failed:
-            if "403" in self.model.failure_reason:
-
-                def on_continue():
-                    self.config.api_key = None
-                    self.model.failed = False
-                    self.model.failure_reason = ""
-
-                self.build_instructions(
-                    "Your API key is invalid. \
-Please make sure you entered it correctly.",
-                    on_continue,
-                )
-                return
-            self.build_error(self.model.failure_reason)
+        if self.cache.failure_reason is not None:
+            self.build_error(self.cache.failure_reason or "Unknown error")
             return
 
         # if there is a notification, display it
-        if self.cache["notification"] is not None:
+        if self.cache.notification is not None:
             self.build_instructions(
-                self.cache["notification"], lambda: self.set_cache(notification=None)
+                self.cache.notification,
+                lambda: setattr(self.cache, "notification", None),
             )
             return
 
         # if the config is complete, display the main screen
-        if self.config.is_complete:
-            if self.cache["needs_saving"] and not self.config.has_config_file:
-                self.build_config_save()
-                return
+        if current_step == ConfigStep.FINISH:
+            assert self.recordpool is not None
+
+            if self.cache.created_account:
+                # create a temporary model to log the account creation
+                model = AppModel(
+                    self.config.settings,
+                    self.state,
+                    self.recordpool,
+                )
+                model.log_api(
+                    API_LOG_TYPES["account_created"],
+                    {"orgId": self.state.org_uid or ""},
+                )
+            # update the configuration if the user does not have one complete
+            if len(self.config.contexts) == 0:
+                secrets = Secret.get_secrets(self.config.directory)
+                if not self.cache.api_key in [s.api_key for s in secrets.values()]:
+                    assert isinstance(self.recordpool.input_, Secret)
+                    secrets["default"] = self.recordpool.input_
+                    Secret.set_secrets(self.config.directory, secrets)
+
+                self.config.contexts["default"] = Context(
+                    secret_name="default",
+                    org_uid=None,
+                    source=None,
+                )
+                self.config.active_context = "default"
             log.info("Config is complete, starting load")
-            log.info(self.config)
-            self.model.init()
-            raise NextScene("Loading")
-
-        # if there is no api_key, determine if the user has an account,
-        # and then help them find the api_key
-        if self.config.api_key is None:
-            self.set_cache(needs_saving=True)
-            if self.cache["has_account"] is None:
+            raise StopApplication("Finished configuration")
+
+        if current_step == ConfigStep.HAS_ACCOUNT:
+            if self.cache.has_account is None:
+
+                def callback1(confirmed):
+                    self.cache.has_account = confirmed
+                    self._needs_build = True
+
                 self.build_confirm(
                     "Do you have a Spyderbat account?",
-                    lambda confirmed: self.set_state("has_account", confirmed),
+                    callback1,
                 )
                 return
-            if not self.cache["has_account"]:
 
-                def on_next():
-                    self.set_cache(created_account=True, has_account=True)
+            def callback():
+                self.cache.has_account = True
+                self.cache.created_account = True
+                self._needs_build = True
 
-                self.build_instructions(
-                    """\
+            self.build_instructions(
+                """\
 You need a Spyderbat account to use Spydertop, otherwise I won't \
 have any data to display! Please go to https://app.spyderbat.com/signup \
 and create an account, then come back here to continue.
 
 If you want to try out Spydertop without an account, you can use one \
 of the example files (included in the docker image as well as the source \
 repository) like so:
 
-    $ spydertop -i examples/minikube-sock-shop.json.gz
+$ spydertop -i examples/minikube-sock-shop.json.gz
 
 """,
-                    on_next,
-                )
-                return
-            if self.cache["has_account"]:
-                self.build_api_key_question()
-                return
+                callback,
+            )
+            return
 
-        self.model.init_api()
+        if current_step == ConfigStep.API_KEY:
+            self.build_api_key_question()
+            return
 
         # if the config has no org, ask the user to select one
-        if not self.config.org_confirmed or self.config.org is None:
-            self.set_cache(needs_saving=self.config.org is None)
+        if current_step == ConfigStep.ORGANIZATION:
+            assert self.recordpool is not None
             # if there are no orgs, load the orgs
-            if self.cache["orgs"] is None:
-
-                def load_orgs():
-                    orgs = self.model.get_orgs(force_reload=self.cache["force_reload"])
-                    if orgs is not None:
-                        self.set_cache(
-                            orgs=[
-                                org
-                                for org in orgs
-                                # the defend the flag org is not useful for the user
-                                if org["uid"] != "defend_the_flag"
-                            ]
-                        )
-                    self.trigger_build()
-                    self._screen.force_update()
-                    self.set_cache(force_reload=False)
-
-                self.thread = Thread(target=load_orgs)
-                self.thread.start()
+            if len(self.recordpool.orgs) == 0:
+                self.load_data("orgs")
                 self.build_loading("Loading organizations...")
                 return
 
             # if there are orgs, determine how many, and pick one
-            if self.cache["orgs"] is not None:
-                if len(self.cache["orgs"]) == 0:
-                    self.build_error(
-                        """\
-No organizations found! This is unexpected; try \
-logging into your account on the website.\
-"""
-                    )
-                    return
-                if len(self.cache["orgs"]) == 1:
-                    self.set_org(self.cache["orgs"][0])
-                if len(self.cache["orgs"]) > 1:
-                    orgs = sorted(
-                        self.cache["orgs"],
-                        key=lambda o: o.get("total_sources", 0),
-                        reverse=True,
-                    )
+            if len(self.recordpool.orgs) == 1:
+                self.state.org_uid = self.recordpool.orgs[0]["id"]
+                self._needs_build = True
+                return
+            if len(self.recordpool.orgs) > 1:
+                orgs = sorted(
+                    self.recordpool.orgs,
+                    key=lambda o: o.get("total_sources", 0),
+                    reverse=True,
+                )
+
+                def reload_orgs():
+                    self.cache.force_reload = True
+                    self._on_submit = None
+                    self._needs_build = True
 
-                    if self.config.org is None:
-                        index = 0
-                    else:
-                        try:
-                            index = [o["uid"] for o in orgs].index(self.config.org)
-                        except ValueError:
-                            index = 0
-
-                    def reload_orgs():
-                        self.set_cache(force_reload=True)
-                        self.set_cache(orgs=None)
-                        self._on_submit = None
-                        self.trigger_build()
+                def org_callback(row):
+                    if row is None:
+                        return
+                    self.state.org_uid = row[4]
+                    self._needs_build = True
 
-                    self.build_question(
-                        "Please select an organization",
+                self.build_question(
+                    "Please select an organization",
+                    [
                         [
-                            [
-                                org["name"],
-                                f"Sources: {org['total_sources']}"
-                                if "total_sources" in org
-                                else "",
-                                str(org.get("owner_email", "")),
-                                ", ".join(org["tags"]) if "tags" in org else "",
-                                org["uid"],
-                            ]
-                            for org in orgs
-                        ],
-                        lambda row: self.set_org(row[4]) if row is not None else None,
-                        index,
-                        refresh_button=reload_orgs,
-                    )
-                    return
-
-        # if the config source has asterisks, then it is a glob, and we need to
-        # ask the user to select one of the sources that match
-        if self.config.machine is not None and "*" in self.config.machine:
-            self.set_cache(source_glob=self.config.machine)
-            self.config.source_confirmed = False
-            self.config.machine = None
-
-        if self.cache["created_account"]:
-            self.model.log_api(
-                API_LOG_TYPES["account_created"], {"orgId": self.config.org or ""}
-            )
-            # prevent this log from being sent again
-            self.set_cache(created_account=False)
+                            org["name"],
+                            f"Sources: {org['total_sources']}"
+                            if "total_sources" in org
+                            else "",
+                            str(org.get("owner_email", "")),
+                            ", ".join(org["tags"]) if "tags" in org else "",
+                            org["uid"],
+                        ]
+                        for org in orgs
+                    ],
+                    org_callback,
+                    0,
+                    refresh_button=reload_orgs,
+                )
+                return
 
         # if the config has no source, ask the user to select one
-        if not self.config.source_confirmed or self.config.machine is None:
+        if current_step == ConfigStep.SOURCE:
+            assert self.recordpool is not None
             # if the sources have not been loaded, load the sources
-            if self.cache["sources"] is None:
-
-                def load_sources():
-                    sources = self.model.get_sources(
-                        force_reload=self.cache["force_reload"]
-                    )
-                    clusters = self.model.get_clusters(
-                        force_reload=self.cache["force_reload"]
-                    )
-                    self.set_cache(force_reload=False)
-                    if sources is None and clusters is None:
-                        self.model.fail("Failed to load any machines or clusters")
-                        self.trigger_build()
-                        self._screen.force_update()
-                        return
-                    if self.cache["looking_for_sources"] and sources is not None:
-                        if len(sources) == 0:
-                            sleep(1)
-                            load_sources()
-                            return
-                    self.set_cache(
-                        sources=[
-                            source
-                            for source in (sources or [])
-                            # the global source is not useful in this context
-                            if not source["uid"].startswith("global:")
-                        ],
-                        clusters=clusters or [],
-                    )
-                    self.trigger_build()
-                    self._screen.force_update()
-
-                self.thread = Thread(target=load_sources)
-                self.thread.start()
+            if self.state.org_uid not in self.recordpool.sources:
+                self.load_data("sources")
                 self.build_loading(
                     "Loading sources..."
-                    if not self.cache["looking_for_sources"]
+                    if not self.cache.looking_for_sources
                     else "Looking for sources..."
                 )
                 return
 
+            sources = self.recordpool.sources.get(self.state.org_uid, [])
+            clusters = self.recordpool.clusters.get(self.state.org_uid, [])
             # if there are no sources, guide the user through creating one
-            if self.cache["sources"] == [] and self.cache["clusters"] == []:
-                self.set_cache(needs_saving=True, sources=None)
+            if len(sources) == 0 and len(clusters) == 0:
                 self.build_instructions(
                     f"""\
 You don't have any sources yet. You can create one by going to \
-https://app.spyderbat.com/app/org/{self.config.org}/first-time-config and \
+https://app.spyderbat.com/app/org/{self.state.org_uid}/first-time-config and \
 following the instructions. \
 Once you have a source configured, you can continue.\
 """,
-                    lambda: self.set_state("looking_for_sources", True),
+                    lambda: setattr(self.cache, "looking_for_sources", True),
                 )
                 return
 
             # if there are sources, pick one
-            if self.cache["sources"]:
+            if sources:
                 # if there is a glob, remove non-matching sources
-                sources = self.cache["sources"]
-                if self.cache["source_glob"]:
+                if self.cache.source_glob:
                     sources = [
                         s
-                        for s in self.cache["sources"]
-                        if fnmatch.fnmatch(s["name"], self.cache["source_glob"])
-                        or fnmatch.fnmatch(s["uid"], self.cache["source_glob"])
+                        for s in sources
+                        if fnmatch.fnmatch(s["name"], self.cache.source_glob)
+                        or fnmatch.fnmatch(s["uid"], self.cache.source_glob)
                         or (
                             "description" in s
                             and fnmatch.fnmatch(
                                 s["description"],
-                                self.cache["source_glob"],
+                                self.cache.source_glob,
                             )
                         )
                     ]
                     if len(sources) == 0:
                         self.build_instructions(
-                            f"No sources matched '{self.cache['source_glob']}'",
-                            lambda: self.set_cache(source_glob=None),
+                            f"No sources matched '{self.cache.source_glob}'",
+                            lambda: setattr(self.cache, "source_glob", None),
                         )
                         return
                     if len(sources) == 1:
-                        self.set_source(sources[0]["uid"])
+                        self.state.source_uid = sources[0]["uid"]
                         self._needs_build = True
                         self._screen.force_update()
                         return
 
-                self.set_cache(needs_saving=True)
                 # sort the sources by the last time they were seen
                 sources = sorted(
-                    self.cache["sources"],
+                    sources,
                     key=lambda s: s.get("last_stored_chunk_end_time", 0),
                     reverse=True,
                 )
-                if self.config.machine is None:
-                    index = 0
-                else:
-                    try:
-                        index = [s["uid"] for s in sources].index(self.config.machine)
-                    except ValueError:
-                        index = 0
 
                 def back_handler():
-                    self.config.org_confirmed = False
-                    self.config.source_confirmed = False
+                    self.state.org_uid = ""
+                    self.state.source_uid = None
                     self._on_submit = None
-                    self.trigger_build()
+                    self._needs_build = True
 
                 def refresh_handler():
-                    self.set_cache(force_reload=True)
-                    self.config.source_confirmed = False
-                    self.set_cache(sources=None)
+                    self.cache.force_reload = True
+                    self.state.source_uid = None
                     self._on_submit = None
-                    self.trigger_build()
+                    self._needs_build = True
 
                 # there is no org selection to go back to if
                 # the user is in only one org
-                if self.cache["orgs"] and len(self.cache["orgs"]) == 1:
+                if self.recordpool.orgs and len(self.recordpool.orgs) == 1:
                     back = None
                 else:
                     back = back_handler
 
+                def set_source(row):
+                    if row is None:
+                        return
+                    self.state.source_uid = row[5]
+                    self._needs_build = True
+
                 self.build_question(
                     "Please select a machine or cluster",
                     [
                         [
                             "${4}Cluster:",
                             cluster.get("name", "<No Name>"),
                             " ",
                             pretty_datetime(
                                 datetime.strptime(
                                     cluster["last_data"],
                                     "%Y-%m-%dT%H:%M:%SZ",
                                 )
                                 .replace(tzinfo=timezone.utc)
-                                .astimezone(tz=get_timezone(self.model))
+                                .astimezone(tz=get_timezone(self.config.settings))
                             )
                             if "last_data" in cluster
                             else "",
                             str(
                                 datetime.strptime(
                                     cluster["last_data"],
                                     "%Y-%m-%dT%H:%M:%SZ",
                                 )
                                 .replace(tzinfo=timezone.utc)
-                                .astimezone(tz=get_timezone(self.model))
+                                .astimezone(tz=get_timezone(self.config.settings))
                             ),
                             cluster.get("uid", ""),
                         ]
                         for cluster in sorted(
-                            self.cache["clusters"],
+                            clusters,
                             key=lambda c: c.get("last_data", 0),
                             reverse=True,
                         )
                     ]
                     + [self.format_source(source) for source in sources],
-                    lambda row: self.set_source(row[5]) if row is not None else None,
-                    index,
-                    self.cache["source_glob"],
+                    set_source,
+                    0,
+                    self.cache.source_glob,
                     back,
                     refresh_handler,
                 )
                 return
 
         # if there is no start time, ask the user to select one
-        if not self.config.start_time:
+        if not self.state.time:
             # if we were looking for sources, we don't need to ask the user to select a start time
             # just use the currently available time
-            if self.cache["looking_for_sources"]:
+            if self.cache.looking_for_sources and self.state.org_uid:
+                assert self.recordpool is not None
+                sources = self.recordpool.sources.get(self.state.org_uid, [])
                 try:
-                    self.config.start_time = datetime.strptime(
-                        self.cache["sources"][0]["last_stored_chunk_end_time"],
+                    self.state.time = datetime.strptime(
+                        sources[0]["last_stored_chunk_end_time"],
                         "%Y-%m-%dT%H:%M:%SZ",
                     ).replace(tzinfo=timezone.utc)
                 except ValueError:
-                    self.config.start_time = datetime.now() - timedelta(0, 30)
+                    self.state.time = datetime.now() - timedelta(0, 30)
                 self._needs_build = True
                 self._screen.force_update()
                 return
 
             self.build_timepicker()
             return
 
         log.err("Reached the end of the config wizard without being complete")
-        log.debug(self.config)
+        log.debug(self.cache)
         self.build_error("An unexpected error occurred")
 
     def build_question(  # pylint: disable=too-many-arguments,too-many-locals
         self,
         question: str,
         answers: List[List[str]],
         callback: Callable[[Optional[List[str]]], None],
@@ -515,39 +524,42 @@
         for answer in answers[:100]:
             for i, cell in enumerate(answer):
                 columns[i] = max(columns[i], len(re.sub(COLOR_REGEX, "", cell)) + 1)
         columns = [Column("", min(c, 40), str) for c in columns]
         # make the last column take up the rest of the space
         columns[-1].max_width = 0
 
-        list_box = Table(self.model, None, "selection")
+        list_box = Table(self.state, self.config.settings, None, "selection")
         list_box.header_enabled = False
         list_box.value = index
-        list_box.columns = columns
-        list_box.set_rows(answers, answers)
+        list_box.columns = [Column("ID", 0, int, enabled=False)] + columns
+        list_box.set_rows(
+            [[str(i)] + row for i, row in enumerate(answers)],
+            [[i] + row for i, row in enumerate(answers)],
+        )
         text_input = None
 
         def on_search():
             if text_input is None:
                 return
-            self.model.config["filter"] = text_input.value
+            self.state.filter = text_input.value
             list_box.do_filter()
 
         text_input = Text(on_change=on_search, name="search")
         if search_string is not None:
             text_input.value = search_string
 
         def on_submit():
             if list_box.value is not None:
-                self.model.config["filter"] = None
+                self.state.filter = ""
                 row = list_box.get_selected()
-                callback([str(v) for v in row[1]] if row is not None else None)
+                callback([str(v) for v in row[1][1:]] if row is not None else None)
             else:
-                self.set_cache(notification="No option was selected, please select one")
-                self.trigger_build()
+                self.cache.notification = "No option was selected, please select one"
+                self._needs_build = True
 
         self._on_submit = on_submit
 
         self.layout.add_widget(Label(question, align="^"), 1)
         self.layout.add_widget(Label("Search:", align="<"), 1)
         self.layout.add_widget(text_input, 1)
         self.layout.add_widget(Padding(), 1)
@@ -568,15 +580,18 @@
             self.footer.add_widget(Button("Back", back_button), 2)
 
     def build_instructions(self, instructions: str, callback: Callable) -> None:
         """Construct a layout that displays instructions and waits for user to continue"""
         self.layout.add_widget(FuncLabel(lambda: instructions), 1)
         self.layout.add_widget(Padding(), 1)
         self.footer.add_widget(
-            Button("Continue", lambda: (callback(), self.trigger_build())), 1
+            Button(
+                "Continue", lambda: (callback(), setattr(self, "_needs_build", True))
+            ),
+            1,
         )
         self.footer.add_widget(Button("Quit", self.quit), 2)
 
     def build_api_key_question(self) -> None:
         """Construct a layout that asks the user to enter an api_key"""
         self.layout.add_widget(
             FuncLabel(
@@ -593,22 +608,32 @@
 
         def jwt_validator(text: str) -> bool:
             # regex reference:
             # https://stackoverflow.com/questions/61802832/regex-to-match-jwt#comment125423495_65755789
             return re.match(r"^(?:[\w-]*\.){2}[\w-]*$", text.strip()) is not None
 
         text = Text(label="API Key:", validator=jwt_validator, name="api_key")
+        api_url_input = Text(label="API URL:", name="api_url")
+        api_url_input.value = DEFAULT_API_URL
 
-        def set_api_key():
-            self.config.api_key = text.value.strip()
-            self.trigger_build()
-
-        self._on_submit = set_api_key
+        self._on_submit = lambda: self.set_api_key(
+            text.value.strip(), api_url_input.value.strip()
+        )
         self.layout.add_widget(text, 1)
-        self.footer.add_widget(Button("Continue", set_api_key), 1)
+        self.layout.add_widget(api_url_input, 1)
+
+        self.footer.add_widget(
+            Button(
+                "Continue",
+                lambda: self.set_api_key(
+                    text.value.strip(), api_url_input.value.strip()
+                ),
+            ),
+            1,
+        )
         self.footer.add_widget(Button("Quit", self.quit), 2)
 
     def build_loading(self, message: str) -> None:
         """Construct a layout that displays a loading message"""
         self.layout.add_widget(Label(message, align="^"), 1)
 
     def build_error(self, message: str) -> None:
@@ -629,15 +654,15 @@
             ),
             1,
         )
 
         time_label = Label("Start Time: 15 minutes ago")
         self.layout.add_widget(time_label, 1)
 
-        time_zone = get_timezone(self.model)
+        time_zone = get_timezone(self.config.settings)
 
         def on_change():
             selected_time = datetime.combine(date.value, time_widget.value).replace(
                 tzinfo=time_zone
             )
             # remove the color from the time label
             time_label.text = f"Start Time: {pretty_datetime(selected_time)[4:]}"
@@ -656,15 +681,21 @@
         self.layout.add_widget(time_widget, 1)
 
         default_time = datetime.now(timezone.utc) - timedelta(minutes=15)
 
         # quick time selector
 
         # get source create time
-        source_time = self.cache.get("source", {}).get("valid_from", None)
+        sources = (
+            self.recordpool.sources.get(self.state.org_uid, [])
+            if self.recordpool and self.state.org_uid
+            else []
+        )
+        source = next((s for s in sources if s["uid"] == self.state.source_uid), {})
+        source_time = source.get("valid_from", None)
         if source_time is not None:
             source_time = datetime.strptime(source_time, "%Y-%m-%dT%H:%M:%SZ")
             source_time = source_time.replace(tzinfo=timezone.utc)
             source_time_local = source_time.astimezone(time_zone)
             # offset by a bit to allow for records to come in.
             source_time_local += timedelta(minutes=1)
 
@@ -682,17 +713,15 @@
                 button_callback,
             )
             warning_label = Label("")
             self.layout.add_widget(Padding(), 1)
             self.layout.add_widget(create_time_button, 1)
             self.layout.add_widget(warning_label, 1)
 
-        last_seen_time = self.cache.get("source", {}).get(
-            "last_stored_chunk_end_time", None
-        )
+        last_seen_time = source.get("last_stored_chunk_end_time", None)
         if last_seen_time is not None:
             last_seen_time = datetime.strptime(last_seen_time, "%Y-%m-%dT%H:%M:%SZ")
 
             # ignore really old dates
             if last_seen_time.year >= 2020:
                 last_seen_time = last_seen_time.replace(tzinfo=timezone.utc)
                 last_seen_time_local = last_seen_time.astimezone(time_zone)
@@ -736,191 +765,116 @@
                     f"Duration to pre-load: +{duration.value} minutes, -5 minutes"
                 )
 
         self.layout.add_widget(Padding(), 1)
         duration = Text(
             label="Duration:", validator=num_validator, on_change=on_change2
         )
-        duration.value = str(float(self.config.start_duration.total_seconds() // 60))
+        duration.value = str(self.cache.duration.total_seconds() / 60)
 
         selected_duration = timedelta(minutes=float(duration.value))
 
         self.layout.add_widget(duration, 1)
 
+        def set_start_time():
+            self.state.time = datetime.combine(date.value, time_widget.value).replace(
+                tzinfo=time_zone
+            )
+            self.cache.duration = selected_duration
+            self._needs_build = True
+
         self.footer.add_widget(
             Button(
                 "Continue",
-                lambda: self.set_start_time(
-                    date.value, time_widget.value, selected_duration, time_zone  # type: ignore
-                ),
+                set_start_time,
             ),
             1,
         )
 
         def back():
-            self.config.source_confirmed = False
-            self.trigger_build()
+            self.state.source_uid = None
+            self._needs_build = True
 
         self.footer.add_widget(Button("Back", back), 2)
 
-    def build_config_save(self) -> None:
-        """Construct a layout that asks the user which details to save in their
-        configuration to be used again"""
-        self.layout.add_widget(
-            FuncLabel(
-                lambda: """\
-Please select which items to save in your configuration. These will be used \
-again the next time you start Spydertop, and will skip this configuration menu.
+    def load_data(self, load_type: str) -> None:
+        """Loads a type of data from the API"""
 
-These are default values, and can be overridden by passing them as command line \
-arguments (except for the API Key).\
-""",
-            ),
-            1,
-        )
-        # these values are the opposite of the default values
-        # because the CheckBox widget calls the callback when
-        # we set its value initially, toggling the value
-        to_save = {
-            "API_Key": False,
-            "Machine": True,
-            "Org": False,
-        }
-
-        def set_to_save(k):
-            to_save[k] = not to_save[k]
-
-        for key, val in to_save.items():
-            value = getattr(self.config, key.lower())
-            if key == "API_Key":
-                # Show only the first and last few characters of the API key
-                value = value[:5] + "..." + value[-5:]
-
-            checkbox = CheckBox(
-                value,
-                label=key,
-                on_change=lambda k=key: set_to_save(k),
-            )
-            checkbox.value = not val
-            self.layout.add_widget(checkbox, 1)
+        def thread_target():
+            assert self.recordpool is not None
 
-        self.footer.add_widget(
-            Button(
-                "Continue",
-                lambda: self.save_config([key for key, val in to_save.items() if val]),
-            ),
-            1,
-        )
-        self.footer.add_widget(Button("Quit", self.quit), 2)
+            try:
+                if load_type == "orgs":
+                    self.recordpool.load_orgs(force_reload=self.cache.force_reload)
+                    if len(self.recordpool.orgs) == 0:
+                        self.cache.failure_reason = (
+                            "No organizations found! This is unexpected; try"
+                            "logging into your account on the website."
+                        )
+                if load_type == "sources":
+                    assert self.state.org_uid is not None
+                    self.recordpool.load_sources(
+                        self.state.org_uid, force_reload=self.cache.force_reload
+                    )
+                    self.recordpool.load_clusters(
+                        self.state.org_uid, force_reload=self.cache.force_reload
+                    )
+                    self.cache.force_reload = False
+                    if (
+                        self.state.org_uid not in self.recordpool.sources
+                        and self.state.org_uid not in self.recordpool.clusters
+                    ):
+                        self.cache.failure_reason = (
+                            "Failed to load any machines or clusters"
+                        )
+            except APIError as exc:
+                self.cache.failure_reason = str(exc)
+
+            self._needs_build = True
+            self._screen.force_update()
+            self.cache.force_reload = False
+
+        self.thread = Thread(target=thread_target)
+        self.thread.start()
 
     def build_confirm(self, question: str, callback: Callable[[bool], None]) -> None:
         """Create a simple layout to ask a yes/no question"""
         self.layout.add_widget(Label(question, align="^"), 1)
         self.footer.add_widget(Button("Yes", lambda: callback(True)), 1)
         self.footer.add_widget(Button("No", lambda: callback(False)), 2)
 
-    def save_config(self, attributes: List[str]) -> None:
-        """Save the configuration to the config file"""
-        if len(attributes) == 0:
-            self.trigger_build()
-            return
-        try:
-            # make sure the containing folder exists
-            path = os.path.join(os.environ["HOME"], ".spyderbat-api")
-            if not os.path.exists(path):
-                os.mkdir(path)
-
-            # read the config if it exists, and update it with the new values
-            config_path = os.path.join(path, "config.yaml")
-            if os.path.exists(config_path):
-                with open(config_path, "r", encoding="utf-8") as conf_file:
-                    config = yaml.safe_load(conf_file)
-                    if config is None:
-                        config = {}
-                if "default" not in config:
-                    config["default"] = {}
-            else:
-                config = {"default": {}}
-            for attribute in attributes:
-                config["default"][attribute.lower()] = getattr(
-                    self.config, attribute.lower()
-                )
-
-            # write the config back to disk
-            with open(
-                os.path.join(path, "config.yaml"), "w", encoding="utf-8"
-            ) as conf_file:
-                yaml.dump(config, conf_file)
-        except FileNotFoundError as exc:
-            self.model.fail(f"Error saving config: {exc}")
-
-        self.set_cache(needs_saving=False)
-        self.trigger_build()
-
     def format_source(self, source) -> List[str]:
         """Format a source for display"""
         try:
             last_stored_time = (
                 datetime.strptime(
                     source["last_stored_chunk_end_time"],
                     "%Y-%m-%dT%H:%M:%SZ",
                 )
                 .replace(tzinfo=timezone.utc)
-                .astimezone(tz=get_timezone(self.model))
+                .astimezone(tz=get_timezone(self.config.settings))
             )
         except OverflowError:
             last_stored_time = datetime.fromtimestamp(0).replace(tzinfo=timezone.utc)
         return [
             "${3}Machine:",
             source.get("description", ""),
             " ",
             pretty_datetime(last_stored_time)
             if "last_stored_chunk_end_time" in source
             else "",
             str(last_stored_time),
             source.get("uid", ""),
         ]
 
-    def set_state(self, key: str, value: Any) -> None:
-        """Set a state variable"""
-        self.set_cache(**{key: value})
-        self.trigger_build()
-
-    def set_org(self, org_uid: str) -> None:
+    def set_api_key(self, key: str, api_url: str = DEFAULT_API_URL) -> None:
         """Set the organization"""
-        if org_uid != self.config.org:
-            self.set_cache(sources=None)
-            self.config.org = org_uid
-        self.config.org_confirmed = True
-        self.trigger_build()
-
-    def set_source(self, source_uid: str) -> None:
-        """Set the source"""
-        self.config.machine = source_uid
-        sources: list = self.cache["sources"]
-        source = next((s for s in sources if s["uid"] == source_uid), None)
-        if source is not None:
-            self.set_cache(source=source)
-        self.config.source_confirmed = True
-        self.trigger_build()
 
-    def set_start_time(
-        self,
-        date: datetime,
-        time_portion: time,
-        duration: timedelta,
-        time_zone: Union[timezone, tzinfo, None],
-    ) -> None:
-        """Set the start time"""
-        self.config.start_time = datetime.combine(date, time_portion).replace(
-            tzinfo=time_zone
-        )
-        self.config.start_duration = duration
-        self.trigger_build()
+        self.cache.api_key = key
+        self.recordpool = RecordPool(Secret(key, api_url), self.args.output)
 
-    def trigger_build(self) -> None:
-        """Trigger a rebuild of the layout"""
         self._needs_build = True
 
     def quit(self) -> None:
         """Quit the application"""
+        self.state.exit_reason = ExitReason.QUIT
         raise StopApplication("User quit")
```

## spydertop/screens/failure.py

```diff
@@ -12,14 +12,15 @@
 
 from asciimatics.screen import Screen
 from asciimatics.widgets import Frame, Layout, Button
 from asciimatics.exceptions import NextScene, StopApplication
 from asciimatics.event import KeyboardEvent
 
 from spydertop.model import AppModel
+from spydertop.state import ExitReason
 from spydertop.utils.types import Alignment, ExtendedParser
 from spydertop.widgets import Padding, FuncLabel
 
 
 class FailureFrame(Frame):
     """A failure screen to alert the user that data has failed to load,
     and to allow them to recover or quit."""
@@ -83,22 +84,22 @@
         )
         self._time_button = Button(
             "",
             lambda: self._recover("retry"),
         )
         layout2.add_widget(Button("Quit", self._quit))
 
-        self.set_theme(model.config["theme"])
+        self.set_theme(model.settings.theme)
         self.fix()
 
     def update(self, frame_no):
-        self.set_theme(self._model.config["theme"])
+        self.set_theme(self._model.settings.theme)
         self._time_button.text = (
-            f"Reload {self._model.time}"
-            if self._model.time is not None
+            f"Reload {self._model.state.time}"
+            if self._model.state.time is not None
             else "Retry loading"
         )
         super().update(frame_no)
 
     # pylint: disable=duplicate-code
     def process_event(self, event):
         if isinstance(event, KeyboardEvent):
@@ -106,10 +107,10 @@
                 self._quit()
         return super().process_event(event)
 
     def _recover(self, action: str) -> None:
         self._model.recover(action)
         raise NextScene("Main")
 
-    @staticmethod
-    def _quit():
+    def _quit(self):
+        self._model.state.exit_reason = ExitReason.QUIT
         raise StopApplication("User quit after failure")
```

## spydertop/screens/feedback.py

```diff
@@ -115,20 +115,20 @@
                 "Submit Feedback",
                 self._submit_feedback,
             ),
             column=1,
         )
 
         self._model = model
-        self.set_theme(model.config["theme"])
+        self.set_theme(model.settings.theme)
 
         self.fix()
 
     def update(self, frame_no):
-        self.set_theme(self._model.config["theme"])
+        self.set_theme(self._model.settings.theme)
         return super().update(frame_no)
 
     def _cancel(self):
         raise NextScene("Main")
 
     def _submit_feedback(self):
         self._model.submit_feedback(str(self._feedback_widget.value))
```

## spydertop/screens/footer.py

```diff
@@ -6,15 +6,15 @@
 #
 
 """
 The main frame's footer, handling the creation and resetting of the buttons widgets
 as well as click handlers.
 """
 
-from typing import Callable, List, Tuple
+from typing import Callable, List, Optional, Tuple
 
 from asciimatics.widgets import Button, Layout, Frame, Widget
 
 
 class Footer(Layout):
     """A footer layout to handle the creation and resetting of the buttons widgets
     as well as click handlers."""
@@ -26,27 +26,27 @@
     _widths: List[int]
 
     def __init__(
         self,
         columns: List[int],
         frame: Frame,
         buttons: List[Tuple[str, Callable]],
-        end_widget: Widget,
+        end_widget: Optional[Widget],
     ):
         super().__init__(columns)
         self._widths = columns
         self._frame = frame
         self.set_buttons(buttons, end_widget)
 
     def set_buttons(self, buttons, end_widget=None):
         """Set the buttons to be displayed in the footer."""
         self.clear_widgets()
         self._buttons = []
         self._on_clicks = []
-        for (i, (title, on_click)) in enumerate(buttons):
+        for i, (title, on_click) in enumerate(buttons):
             # strip title to fit in the width
             width = self._widths[i]
             title = title[: width - 2]
             button = Button(title, on_click, f"F{i+1}", add_box=False)
             button.custom_colour = "focus_button"
             self._on_clicks.append(on_click)
             self._buttons.append(button)
```

## spydertop/screens/help.py

```diff
@@ -177,20 +177,20 @@
                 parser=ExtendedParser(),
             )
         )
 
         single_column2.add_widget(Padding())
 
         self._model = model
-        self.set_theme(model.config["theme"])
+        self.set_theme(model.settings.theme)
 
         self.fix()
 
     def update(self, frame_no):
-        self.set_theme(self._model.config["theme"])
+        self.set_theme(self._model.settings.theme)
         return super().update(frame_no)
 
     def process_event(self, event):
         # on any keyboard event, go back to Main
         if isinstance(event, KeyboardEvent) and (
             event.key_code in {ord("q"), ord("Q"), Screen.KEY_F10, Screen.KEY_ESCAPE}
         ):
```

## spydertop/screens/loading.py

```diff
@@ -5,15 +5,17 @@
 # Copyright 2022 Spyderbat, Inc. All rights reserved.
 #
 
 """
 A loading screen to show progress toward loading a set of records
 """
 
+from datetime import timedelta
 import re
+from threading import Thread
 from asciimatics.screen import Screen
 from asciimatics.widgets import Frame, Layout, Label
 from asciimatics.exceptions import NextScene
 from asciimatics.event import KeyboardEvent
 from spydertop.model import AppModel
 
 from spydertop.constants import COLOR_REGEX
@@ -106,15 +108,15 @@
             FuncLabel(
                 lambda: "${8,1} " + log.get_last_line(log.INFO),
                 align=Alignment.CENTER,
                 parser=ExtendedParser(),
             )
         )
 
-        self.set_theme(self._model.config["theme"])
+        self.set_theme(self._model.settings.theme)
         self.fix()
 
     def update_logo(self):
         """Update the logo"""
         if self.screen.width < 80:
             header_padding = max(round(self.screen.height / 2 - 13), 0)
             return ("\n" * header_padding) + LOGO + "\n" + BIG_NAME
@@ -131,23 +133,41 @@
                 for logoline, nameline in zip(
                     LOGO.split("\n"), extended_huge_name.split("\n")
                 )
             ]
         )
 
     def update(self, frame_no):
-        self.set_theme(self._model.config["theme"])
+        self.set_theme(self._model.settings.theme)
 
+        if not self._model.thread:
+            # we just started loading
+            def guard():
+                try:
+                    self._model.load_data(
+                        self._model.state.time.timestamp()
+                        if self._model.state.time
+                        else None,
+                        timedelta(minutes=5),
+                    )
+                except Exception as exc:  # pylint: disable=broad-except
+                    self._model.fail("An exception occurred while loading data")
+                    log.traceback(exc)
+
+            self._model.thread = Thread(target=guard)
+            self._model.thread.start()
         # see if the model is done
         if self._model.thread is not None:
             if self._model.failed:
                 self._model.thread.join()
+                self._model.thread = None
                 raise NextScene("Failure")
             if self._model.loaded:
                 self._model.thread.join()
+                self._model.thread = None
                 self._quit()
         super().update(frame_no)
 
     def process_event(self, event):
         if isinstance(event, KeyboardEvent):
             if event.key_code in {ord("q"), ord("Q")}:
                 self._quit()
```

## spydertop/screens/main.py

```diff
@@ -6,48 +6,52 @@
 #
 
 """
 The main frame for the tool. This frame contains the record list and usage metrics,
 as well as showing all the menu buttons.
 """
 
+# pylint: disable=too-many-lines
+
+from copy import deepcopy
 import re
 from typing import Any, Dict, List, Optional
 import urllib.parse
 import webbrowser
 
 import pyperclip
-from asciimatics.screen import Screen
+from asciimatics.screen import Screen, StopApplication
 from asciimatics.widgets import (
     Frame,
     Layout,
     Button,
     ListBox,
 )
 from asciimatics.exceptions import NextScene
 from asciimatics.event import KeyboardEvent
 from asciimatics.strings import ColouredText
+from spydertop.config.config import Focus, Settings
 
 from spydertop.model import AppModel
 from spydertop.screens.setup import SetupFrame
 from spydertop.screens.meters import (
     update_memory,
     update_swap,
     show_disk_io,
     show_ld_avg,
     show_network,
     show_tasks,
     update_cpu,
     show_uptime,
 )
 from spydertop.screens.modals import InputModal, NotificationModal
+from spydertop.state import ExitReason
 from spydertop.widgets import Table
 from spydertop.utils import (
     align_with_overflow,
-    get_machine_short_name,
     log,
     convert_to_seconds,
     pretty_time,
     calculate_widths,
 )
 from spydertop.utils.types import Alignment, ExtendedParser
 from spydertop.constants import API_LOG_TYPES
@@ -66,51 +70,60 @@
 
 class MainFrame(Frame):  # pylint: disable=too-many-instance-attributes
     """The main frame for the application. This frame is responsible
     for taking user input and determining how much to update the screen."""
 
     # update and caching management
     _model: AppModel
-    _old_settings: Dict[str, Any]
+    _old_settings: Settings
     _last_frame: int = 0
     _widgets_initialized: bool = False
     needs_screen_refresh: bool = True
     needs_update: bool = True
     needs_recalculate: bool = True
     _cached_options: Optional[List] = None
     _cached_sortable: List = []
     _cached_displayable: List = []
     _current_columns: List[Column] = PROCESS_COLUMNS
     _old_column_val = None
     _last_effects: int = 1
+    _focuses: List[Focus] = []
 
     # widgets
     _main: Optional[Layout] = None
     _footer: Footer
     _cpus: Dict[str, List[Meter]] = {}
     _tabs: List[Button] = []
+    _tabs_layout: Layout
     _memory: Meter
     _swap: Meter
     _columns: Table
 
     # -- initialization -- #
-    def __init__(self, screen, model: AppModel) -> None:
+    def __init__(self, screen, model: AppModel, focuses: List[Focus]) -> None:
         # pylint: disable=duplicate-code
         super().__init__(
             screen,
             screen.height,
             screen.width,
             has_border=False,
             can_scroll=False,
             name="MainFrame",
         )
         self._model = model
-        self._old_settings = model.config.settings
+        self._old_settings = deepcopy(model.settings)
+        self._old_state = deepcopy(model.state)
+
+        self._focuses = focuses
+
+        for focus in self._focuses:
+            if focus.type == Focus.MACHINE:
+                self._model.selected_machine = focus.value
 
-        self.set_theme(model.config["theme"])
+        self.set_theme(model.settings.theme)
 
     def _init_widgets(self):  # pylint: disable=too-many-statements
         """Initialize the widgets for the main frame. This is separate from the
         __init__ function because the widgets require the model to be initialized."""
         ############## Header #################
         header = Layout([1, 1], fill_frame=False)
         self.add_layout(header)
@@ -121,41 +134,53 @@
                 lambda: "Machine: " if self._model.selected_machine is not None else "",
                 align=Alignment.RIGHT,
             ),
             0,
         )
         header.add_widget(
             FuncLabel(
-                lambda: get_machine_short_name(
-                    self._model.machines[self._model.selected_machine]
-                )
+                lambda: self._model.get_machine_short_name(self._model.selected_machine)
                 if self._model.selected_machine is not None
                 else ""
             ),
             1,
         )
 
         # meters
         self._cpus = {}
         cpu_count = 0
-        for machine in self._model.machines.values():
-            cpu_count = machine["machine_cores"]
-            self._cpus[machine["id"]] = []
+        machines_to_show = (
+            [self._model.selected_machine]
+            if self._model.selected_machine is not None
+            else self._model.machines.keys()
+        )
+        for machine_id in machines_to_show:
+            machine = self._model.machines.get(machine_id)
+            if machine is not None:
+                cpu_count = machine["machine_cores"]
+            else:
+                times = self._model.get_value("cpu_time", machine_id)
+                if times is None:
+                    continue
+                cpu_count = len(times.keys().filter(lambda x: x != "cpu"))
+            self._cpus[machine_id] = []
 
             for i in range(0, cpu_count):
                 if i == 0:
                     name = (
                         align_with_overflow(
-                            get_machine_short_name(machine), 20, include_padding=False
+                            self._model.get_machine_short_name(machine_id),
+                            20,
+                            include_padding=False,
                         )
                         + f" {i} "
                     )
                 else:
                     name = f"{i:<3}"
-                self._cpus[machine["id"]].append(
+                self._cpus[machine_id].append(
                     Meter(
                         name,
                         values=[0, 0, 0, 0],
                         colors=[
                             Screen.COLOUR_BLUE,
                             Screen.COLOUR_GREEN,
                             Screen.COLOUR_RED,
@@ -166,15 +191,15 @@
                         important_value=3,
                     )
                 )
                 if i < cpu_count / 2:
                     column = 0
                 else:
                     column = 1
-                header.add_widget(self._cpus[machine["id"]][i], column)
+                header.add_widget(self._cpus[machine_id][i], column)
         self._memory = Meter(
             "Mem",
             values=[0, 0, 0, 0],
             colors=[
                 Screen.COLOUR_GREEN,
                 Screen.COLOUR_BLUE,
                 Screen.COLOUR_MAGENTA,
@@ -219,100 +244,125 @@
             column=1,
         )
 
         header.add_widget(Padding(), 0)
         header.add_widget(Padding(), 1)
 
         ################# Main Table Tabs #######################
+        available_tabs = self._get_available_tabs()
+        self._tabs_layout = Layout(
+            calculate_widths(self.screen.width, [1] * len(available_tabs))
+        )
+        self.add_layout(self._tabs_layout)
+        self._init_tabs()
+
+        ################# Main Table #######################
+        self._main = Layout([1], fill_frame=True)
+        self.add_layout(self._main)
+
+        self._columns = Table(self._model.state, self._model.settings, self._model.tree)
+        self._main.add_widget(self._columns)
+
+        ################# Footer #######################
+
+        status = FuncLabel(
+            lambda: f"{self._model.status}",
+            align=Alignment.RIGHT,
+            parser=ExtendedParser(),
+            color="focus_button",
+        )
+        self._footer = Footer(
+            calculate_widths(self.screen.width, [1] * 10 + [3]), self, [], status
+        )
+        self.add_layout(self._footer)
+        self._switch_buttons("main")
+
+        self.reset()
+        self.fix()
+        self._switch_to_tab(self._model.settings.tab, force=True)
+        self.switch_focus(self._main, 0, 0)
+        self._widgets_initialized = True
+
+        # this is necessary to update the rows in Table, which is needed for _find below
+        self.update(0)
+        for focus in self._focuses:
+            if focus.type == Focus.TAB:
+                self._switch_to_tab(focus.value)
+            elif focus.type == Focus.RECORD:
+                self._columns.find(f"id: {focus.value}")
+
+    def _get_available_tabs(self):
         available_tabs = [
             "Processes",
             "Flags",
             "Sessions",
             "Connections",
             "Listening",
             "Containers",
         ]
         for tab in available_tabs.copy():
             # if there are no records for the tab, don't add it
             if len(getattr(self._model, tab.lower())) == 0:
                 available_tabs.remove(tab)
 
-        tabs_layout = Layout(
-            calculate_widths(self.screen.width, [1] * len(available_tabs))
-        )
+        return available_tabs
+
+    def _init_tabs(self):
+        available_tabs = self._get_available_tabs()
         self._tabs = []
-        self.add_layout(tabs_layout)
+        self._tabs_layout.clear_widgets()
         for i, name in enumerate(available_tabs):
 
             def wrapper(name):
                 def inner():
                     self._switch_to_tab(name.lower())
 
                 return inner
 
             button = Button(name, wrapper(name), add_box=False)
             self._tabs.append(button)
-            tabs_layout.add_widget(button, i)
+            self._tabs_layout.add_widget(button, i)
 
-        if self._model.config["tab"] not in [t.lower() for t in available_tabs]:
+        if self._model.settings.tab not in [t.lower() for t in available_tabs]:
             if len(available_tabs) == 0:
                 self._model.fail("No records of were found.")
                 raise NextScene("Failure")
-            self._model.config["tab"] = available_tabs[0].lower()
-
-        ################# Main Table #######################
-        self._main = Layout([1], fill_frame=True)
-        self.add_layout(self._main)
-
-        self._columns = Table(self._model, self._model.tree)
-        self._main.add_widget(self._columns)
-
-        ################# Footer #######################
-
-        status = FuncLabel(
-            lambda: f"{self._model.state}",
-            align=Alignment.RIGHT,
-            parser=ExtendedParser(),
-            color="focus_button",
-        )
-        self._footer = Footer(
-            calculate_widths(self.screen.width, [1] * 10 + [3]), self, [], status
-        )
-        self.add_layout(self._footer)
-        self._switch_buttons("main")
-
+            self._model.settings.tab = available_tabs[0].lower()
+        self._switch_to_tab(self._model.settings.tab, force=False)
         self.reset()
         self.fix()
-        self._switch_to_tab(self._model.config["tab"], force=True)
-        self.switch_focus(self._main, 0, 0)
-        self._widgets_initialized = True
 
     # -- overrides -- #
     def update(self, frame_no):  # pylint: disable=too-many-branches,too-many-statements
-        conf = self._model.config
+        settings = self._model.settings
+        state = self._model.state
         assert self.scene is not None, "Frame must be added to a scene before updating"
 
         # if model is in failure state, raise next scene
         if self._model.failed:
             raise NextScene("Failure")
         # early exit if model is not ready
         if not self._model.loaded:
             return
         if not self._widgets_initialized:
             self._init_widgets()
 
+        # ensure that the table is always in sync with the model
+        if self._columns.tree is not self._model.tree:
+            self._columns.tree = self._model.tree
+
         # update model (if needed, at most 4 times per second)
-        if conf["play"] and (frame_no % max(int(20 / conf["play_speed"]), 5) == 0):
+        if state.play and (frame_no % max(int(20 / settings.play_speed), 5) == 0):
             if self._last_frame != 0:
                 frames_delta = frame_no - self._last_frame
                 time_delta = frames_delta / 20
-                new_time = self._model.timestamp + time_delta * conf["play_speed"]
+                new_time = self._model.timestamp + time_delta * settings.play_speed
                 if not self._model.is_loaded(new_time):
                     # stop playing and notify user
-                    conf["play"] = False
+                    state.play = False
                     self.scene.add_effect(
                         NotificationModal(
                             self.screen,
                             "The end of loaded data has been reached. "
                             "Continue forward to load more data.",
                             self,
                             frames=40,
@@ -320,50 +370,64 @@
                     )
                 else:
                     self._model.timestamp = new_time
                     self.needs_recalculate = True
             self._last_frame = frame_no
 
         # detect changes in settings
-        if conf.settings_changed:
-            conf.settings_changed = False
+        if self._old_settings != settings:
             self.needs_update = True
-            if conf["theme"] != self._old_settings["theme"]:
-                self.set_theme(conf["theme"])
+            if settings.theme != self._old_settings.theme:
+                self.set_theme(settings.theme)
                 # update theme colors in tabs
                 for button in self._tabs:
                     if "tab" in self.palette:
                         button.custom_colour = (
                             "selected_tab"
-                            if self._model.config["tab"] == button.text.lower()
+                            if self._model.settings.tab == button.text.lower()
                             else "tab"
                         )
                     else:
                         button.custom_colour = (
                             "selected_focus_field"
-                            if self._model.config["tab"] == button.text.lower()
+                            if self._model.settings.tab == button.text.lower()
                             else "focus_field"
                         )
                 self.needs_screen_refresh = True
 
-            if conf["utc_time"] != self._old_settings["utc_time"]:
+            if settings.utc_time != self._old_settings.utc_time:
                 self.needs_recalculate = True
 
-            self._footer.change_button_text(
-                "Play" if self._model.config["play"] else "Pause",
-                "Play" if not self._model.config["play"] else "Pause",
-            )
             self.fix()
             self.needs_screen_refresh = True
             if (
-                conf["hide_threads"] != self._old_settings["hide_threads"]
-                or conf["hide_kthreads"] != self._old_settings["hide_kthreads"]
-            ) and self._model.config["tab"] == "processes":
+                settings.hide_threads != self._old_settings.hide_threads
+                or settings.hide_kthreads != self._old_settings.hide_kthreads
+            ) and self._model.settings.tab == "processes":
                 self.needs_recalculate = True
-            self._old_settings = self._model.config.settings.copy()
+            if settings.collapse_tree != self._old_settings.collapse_tree:
+                self._model.rebuild_tree()
+                self._columns.tree = self._model.tree
+            self._old_settings = deepcopy(self._model.settings)
+
+        # detect changes in state
+        if self._old_state != state:
+            if state.play != self._old_state.play:
+                self._footer.change_button_text(
+                    "Play" if self._model.state.play else "Pause",
+                    "Play" if not self._model.state.play else "Pause",
+                )
+            if (
+                state.sort_ascending != self._old_state.sort_ascending
+                or state.sort_column != self._old_state.sort_column
+            ):
+                self.needs_recalculate = True
+            if state.filter != self._old_state.filter:
+                self.needs_update = True
+            self._old_state = deepcopy(state)
 
         # update columns if needed
         if self._model.columns_changed:
             self._columns.columns = self._current_columns
             self._model.columns_changed = False
             self.needs_screen_refresh = True
 
@@ -372,15 +436,16 @@
             self._last_effects = len(self.scene.effects)
             self.needs_screen_refresh = True
 
         try:
             # work up the caching system, updating each part of the cache
             # only if necessary
             if self.needs_recalculate:
-                self._build_options(getattr(self._model, self._model.config["tab"]))
+                self._init_tabs()
+                self._build_options(getattr(self._model, self._model.settings.tab))
                 self.needs_recalculate = False
                 self.needs_update = True
 
             if self.needs_update:
                 self._update_columns()
                 self.needs_update = False
                 self.needs_screen_refresh = True
@@ -450,15 +515,15 @@
                 return None
             if event.key_code in range(Screen.KEY_F11, Screen.KEY_F1 + 1):
                 self._footer.click(-event.key_code - 2)
                 return None
             if event.key_code in {Screen.KEY_TAB, Screen.KEY_BACK_TAB}:
                 current_tab_index = 0
                 for i, tab in enumerate(self._tabs):
-                    if tab.text.lower() == self._model.config["tab"]:
+                    if tab.text.lower() == self._model.settings.tab:
                         current_tab_index = i
                         break
                 offset = 1 if event.key_code == Screen.KEY_TAB else -1
                 next_tab = self._tabs[
                     (current_tab_index + offset) % len(self._tabs)
                 ].text.lower()
                 self._switch_to_tab(next_tab)
@@ -486,14 +551,17 @@
 
         if self._model.timestamp is None:
             self._model.recover()
             self.needs_recalculate = True
             return
 
         for record in records.values():
+            # exlude records that are not in the selected_machine
+            if "muid" in record and record["muid"] != self._model.selected_machine:
+                continue
             # determine if the record is visible for this time
             if "valid_from" in record:
                 if record["valid_from"] > self._model.timestamp or (
                     "valid_to" in record
                     and "muid" in record
                     and record["valid_to"]
                     < self._model.timestamp
@@ -502,18 +570,18 @@
                     continue
             elif "time" in record:
                 # show all events only after they occur
                 if self._model.timestamp < record["time"]:
                     continue
 
             # ignore if the record is a process and it is hidden
-            if self._model.config["tab"] == "processes" and (
-                self._model.config["hide_kthreads"]
+            if self._model.settings.tab == "processes" and (
+                self._model.settings.hide_kthreads
                 and record["type"] == "kernel thread"
-                or self._model.config["hide_threads"]
+                or self._model.settings.hide_threads
                 and record["type"] == "thread"
             ):
                 continue
 
             # build the row for options
             cells = []
             sortable_cells = []
@@ -525,15 +593,15 @@
             self._cached_displayable.append(cells)
             self._cached_sortable.append(sortable_cells)
 
     # -- input handling -- #
     def _enable_disable(self):
         """find the currently selected row and enable/disable that
         branch in the model.tree"""
-        if self._model.config["tab"] != "processes":
+        if self._model.settings.tab != "processes":
             return
         row = self._columns.get_selected()
         if row is None:
             return
 
         def recursive_enable_disable(tree, id_to_ed):
             for rec_id, branch in tree.items():
@@ -598,14 +666,18 @@
             self._footer.set_buttons(modal)
 
         self.fix()
 
     def _switch_to_tab(self, tab_name: str, force: bool = False):
         """Switch to the given tab, and update the state accordingly"""
 
+        available_tabs = self._get_available_tabs()
+        if tab_name not in [s.lower() for s in available_tabs]:
+            return
+
         # update tabs colors
         for button in self._tabs:
             if "tab" in self.palette:
                 button.custom_colour = (
                     "selected_tab" if tab_name == button.text.lower() else "tab"
                 )
             else:
@@ -613,80 +685,77 @@
                     "selected_focus_field"
                     if tab_name == button.text.lower()
                     else "focus_field"
                 )
         self.needs_screen_refresh = True
 
         # update state
-        if tab_name == self._model.config["tab"] and not force:
+        if tab_name == self._model.settings.tab and not force:
             return
-        self._model.config["tab"] = tab_name
+        self._model.settings.tab = tab_name
         self._columns.value = 0
         self.needs_recalculate = True
-        self._model.config["sort_column"] = None
-        self._model.config["filter"] = None
+        self._model.state.sort_column = None
+        self._model.state.filter = ""
         self._cached_options = None
         self._cached_sortable = []
 
         self._model.log_api(API_LOG_TYPES["navigation"], {"tab": tab_name})
 
         # update columns and sort
         if tab_name == "processes":
             self._current_columns = PROCESS_COLUMNS
-            self._model.config["sort_column"] = "CPU%"
-            self._model.config["sort_ascending"] = False
-            self._model.config["tree"] = self._model.config["tree_enabled"]
-        else:
-            self._model.config["tree"] = False
+            self._model.state.sort_column = "CPU%"
+            self._model.state.sort_ascending = False
 
         if tab_name == "sessions":
             self._current_columns = SESSION_COLUMNS
-            self._model.config["sort_column"] = "I"
-            self._model.config["sort_ascending"] = False
+            self._model.state.sort_column = "I"
+            self._model.state.sort_ascending = False
 
         if tab_name == "flags":
             self._current_columns = FLAG_COLUMNS
-            self._model.config["sort_column"] = "AGE"
-            self._model.config["sort_ascending"] = True
+            self._model.state.sort_column = "AGE"
+            self._model.state.sort_ascending = True
 
         if tab_name == "connections":
             self._current_columns = CONNECTION_COLUMNS
-            self._model.config["sort_column"] = "DURATION"
-            self._model.config["sort_ascending"] = True
+            self._model.state.sort_column = "DURATION"
+            self._model.state.sort_ascending = True
 
         if tab_name == "listening":
             self._current_columns = LISTENING_SOCKET_COLUMNS
-            self._model.config["sort_column"] = "DURATION"
-            self._model.config["sort_ascending"] = True
+            self._model.state.sort_column = "DURATION"
+            self._model.state.sort_ascending = True
 
         if tab_name == "containers":
             self._current_columns = CONTAINER_COLUMNS
-            self._model.config["sort_column"] = "CREATED"
-            self._model.config["sort_ascending"] = False
+            self._model.state.sort_column = "CREATED"
+            self._model.state.sort_ascending = False
 
     def _show_sort_menu(self):
         """show the sort menu"""
         self._model.log_api(API_LOG_TYPES["navigation"], {"menu": "sort"})
         self._switch_buttons("modal")
 
         def set_sort(title):
             log.info(f"Switching sort to: {title}")
-            self._model.config["sort_column"] = title
+            self._model.state.sort_column = title
 
         menu = InputModal(
             self.screen,
             label="Sort By:",
             options=[
                 (row.header_name, row.header_name) for row in self._current_columns
             ],
             on_submit=set_sort,
             widget=ListBox,
-            theme=self._model.config["theme"],
+            theme=self._model.settings.theme,
             height=len(self._current_columns),
-            value=self._model.config["sort_column"],
+            value=self._model.state.sort_column,
             on_death=lambda: self._switch_buttons("main"),
         )
         assert self.scene is not None, "A scene must be set in the frame before use"
         self.scene.add_effect(menu)
 
     def _show_search(self):
         """show the search input modal"""
@@ -700,15 +769,15 @@
             self.needs_screen_refresh = True
 
         assert self.scene is not None, "A scene must be set in the frame before use"
         self.scene.add_effect(
             InputModal(
                 self.screen,
                 label="Search:",
-                theme=self._model.config["theme"],
+                theme=self._model.settings.theme,
                 on_change=run_search,
                 on_death=lambda: self._switch_buttons("main"),
                 validator=self._columns.find,
             )
         )
 
     def _show_time_entry(self):
@@ -724,36 +793,36 @@
                 return False
 
         assert self.scene is not None, "A scene must be set in the frame before use"
         self.scene.add_effect(
             InputModal(
                 self.screen,
                 label="Custom Time Offset:",
-                theme=self._model.config["theme"],
+                theme=self._model.settings.theme,
                 on_submit=lambda value: self._shift_time(convert_to_seconds(value)),
                 validator=validator,
                 on_death=lambda: self._switch_buttons("time"),
             )
         )
 
     def _show_filter(self):
         """Show a filter menu"""
         self._model.log_api(API_LOG_TYPES["navigation"], {"menu": "filter"})
         self._switch_buttons("modal")
 
         def set_filter(value):
-            self._model.config["filter"] = value
+            self._model.state.filter = value
 
         assert self.scene is not None, "A scene must be set in the frame before use"
         self.scene.add_effect(
             InputModal(
                 self.screen,
-                self._model.config["filter"],
+                self._model.state.filter,
                 label="Filter:",
-                theme=self._model.config["theme"],
+                theme=self._model.settings.theme,
                 on_change=set_filter,
                 on_death=lambda: self._switch_buttons("main"),
             )
         )
 
     def _show_url(self, open_in_browser: bool = False):
         """Show a url menu with full width"""
@@ -764,29 +833,29 @@
 
         if self._model.selected_machine is not None:
             source = self._model.selected_machine
         elif row is not None:
             record = self._model.get_record_by_id(row[1][0]) or {}
             source = record.get("muid", None)
 
-        if not row or not self._model.config.org or not source:
+        if not row or not self._model.state.org_uid or not source:
             log.info("No row selected or no org/machine/input. Skipping URL")
             assert self.scene is not None, "A scene must be set in the frame before use"
             self.scene.add_effect(
                 NotificationModal(
                     self.screen,
                     text="${1,1}Error:${-1,2} Cannot create URL. "
                     "This is likely because you are loading from a file.",
                     parent=self,
                     frames=30,
                 )
             )
             return
 
-        url = f"https://app.spyderbat.com/app/org/{self._model.config.org}\
+        url = f"https://app.spyderbat.com/app/org/{self._model.state.org_uid}\
 /source/{source}/spyder-console?ids={urllib.parse.quote(str(row[1][0]))}"
 
         # try to open the url in the browser and copy it to the clipboard
         browser_label = "URL not opened in browser"
         if open_in_browser:
             try:
                 webbrowser.open(url)
@@ -854,15 +923,15 @@
                 on_death=lambda: self._switch_buttons("main"),
             )
         )
 
     def _play(self):
         """Update the model to play"""
         self._model.log_api(API_LOG_TYPES["navigation"], {"button": "play"})
-        self._model.config["play"] = not self._model.config["play"]
+        self._model.state.play = not self._model.state.play
 
     def _shift_time(self, offset: float):
         """Shift the time in Model by a given amount."""
         assert self.scene is not None, "A scene must be set in the frame before use"
         if self._model.timestamp is None:
             self._model.recover()
             return
@@ -904,52 +973,47 @@
 
         # load new data, if necessary
         if not self._model.loaded:
             raise NextScene("Loading")
 
     def _config(self, name: str, value=None):
         """Change a config value, and handle any effects"""
-        if name == "tree":
-            self._model.config["tree_enabled"] = (
-                value or not self._model.config["tree_enabled"]
-            )
-            self._model.config[name] = (
-                self._model.config["tree_enabled"]
-                and self._model.config["tab"] == "processes"
+        if hasattr(self._model.state, name):
+            setattr(
+                self._model.state, name, value or not getattr(self._model.state, name)
+            )
+        elif hasattr(self._model.settings, name):
+            setattr(
+                self._model.settings,
+                name,
+                value or not getattr(self._model.settings, name),
             )
-            return
-
-        value = value or not self._model.config[name]
-        self._model.config[name] = value
-
-        if name == "collapse_tree":
-            self._model.rebuild_tree()
-            self._columns.tree = self._model.tree
 
     # -- moving to other frames -- #
     def _back(self):
         """Move back to configuring sources"""
         # don't go back if the input is from a file
-        if not isinstance(self._model.config.input, str):
+        if not self._model.is_loading_from_api():
             assert self.scene is not None, "A scene must be set in the frame before use"
             self.scene.add_effect(
                 NotificationModal(
                     self.screen,
                     "There's no going back! Input is from a file.",
                     self,
                     frames=40,
                 )
             )
             return
         self._model.log_api(API_LOG_TYPES["navigation"], {"button": "back"})
-        self._model.config.source_confirmed = False
-        self._model.config.start_time = None
-        self._model.config["play"] = False
+        self._model.state.source_uid = None
+        self._model.state.time = None
+        self._model.state.play = False
+        self._model.state.exit_reason = ExitReason.BACK_TO_CONFIG
         self._switch_to_tab("processes")
-        raise NextScene("Config")
+        raise StopApplication("User is going back to the config screen")
 
     def _help(self):
         """Show the help screen"""
         self._model.log_api(API_LOG_TYPES["navigation"], {"button": "help"})
         raise NextScene("Help")
 
     def _quit(self):
```

## spydertop/screens/meters.py

```diff
@@ -146,15 +146,15 @@
     tx_bytes = header_bytes(values["tx_bytes"])
     if not (tx_bytes[-1]).isdigit():
         tx_bytes += "i"
     if not (rx_bytes[-1]).isdigit():
         rx_bytes += "i"
     return add_palette(
         "  ${{{meter_label}}}Network: rx: ${{2}}{rx}b/s ${{{meter_label}}}\
-write: ${{4}}{tx}b/s ${{{meter_label}}}({reads}/{writes} reads/writes)",
+tx: ${{4}}{tx}b/s ${{{meter_label}}}({reads}/{writes} reads/writes)",
         model,
         rx=rx_bytes,
         tx=tx_bytes,
         reads=values["reads"],
         writes=values["writes"],
     )
 
@@ -178,21 +178,19 @@
         task_count = "${1,1}Not Available"
     else:
         task_count = processes - tasks["kernel_threads"]
     running = tasks.get("running", 0)
     kthreads = tasks.get("kernel_threads", 0)
     threads = tasks.get("total_threads", 0) - kthreads
 
-    thread_style = "${8,1}" if model.config["hide_threads"] else "${2,1}"
-    thread_lbl_style = (
-        "${{8}}" if model.config["hide_threads"] else "${{{meter_label}}}"
-    )
-    kthread_style = "${8,1}" if model.config["hide_kthreads"] else "${2,1}"
+    thread_style = "${8,1}" if model.settings.hide_threads else "${2,1}"
+    thread_lbl_style = "${{8}}" if model.settings.hide_threads else "${{{meter_label}}}"
+    kthread_style = "${8,1}" if model.settings.hide_kthreads else "${2,1}"
     kthread_lbl_style = (
-        "${{8}}" if model.config["hide_kthreads"] else "${{{meter_label}}}"
+        "${{8}}" if model.settings.hide_kthreads else "${{{meter_label}}}"
     )
     return add_palette(
         "  ${{{meter_label}}}Tasks: ${{{meter_label},1}}{task_count}"
         + thread_lbl_style
         + ", {thread_style}{threads} "
         + thread_lbl_style
         + "thr"
```

## spydertop/screens/quit.py

```diff
@@ -6,21 +6,23 @@
 #
 
 """
 This screen is started when the user decides to quit the application.
 It handles any before-quit events.
 """
 
-import os
 from typing import Any, Callable, Dict
 from asciimatics.screen import Screen
 from asciimatics.widgets import Frame, Layout, TextBox, Button
 from asciimatics.exceptions import StopApplication
+from spydertop.config.cache import get_user_cache
 
 from spydertop.model import AppModel
+from spydertop.state import ExitReason
+from spydertop.utils import is_docker
 from spydertop.widgets import FuncLabel, Padding
 from spydertop.utils.types import ExtendedParser
 
 
 class QuitFrame(Frame):
     """A quitting screen that provides a last chance to submit feedback for new users"""
 
@@ -41,37 +43,34 @@
             {
                 "feedback_text": "",
                 "enjoyed_spydertop": None,
             },
         )
 
     def update(self, frame_no):
-        self.set_theme(self._model.config["theme"])
+        self.set_theme(self._model.settings.theme)
         if self._needs_update:
             self.build_feedback_widget()
             self.reset()
             self.fix()
             self._needs_update = False
         return super().update(frame_no)
 
     def build_feedback_widget(self):
         """Construct the current view of the feedback widget"""
         self._single_column.clear_widgets()
         self._double_column.clear_widgets()
 
         # quit early if the user has already submitted feedback
-        # or do not have a settings file (i.e. they have not yet installed)
+        # or we are running in docker
         if (
-            self._model.config["has_submitted_feedback"]
+            get_user_cache().get("has_submitted_feedback", False)
             and self._state["enjoyed_spydertop"] is None
-        ) or not os.path.exists(
-            os.path.join(
-                os.environ.get("HOME"), ".spyderbat-api/.spydertop-settings.yaml"  # type: ignore
-            )
-        ):
+        ) or is_docker():
+            self._model.state.exit_reason = ExitReason.QUIT
             raise StopApplication("User Quit and does not need feedback")
 
         self._single_column.add_widget(
             FuncLabel(
                 lambda: """\
         
          
@@ -132,12 +131,14 @@
                 "Quit",
                 self._quit,
             ),
             column=0,
         )
 
     def _quit(self):
+        self._model.state.exit_reason = ExitReason.QUIT
         raise StopApplication("User Quit without submitting feedback")
 
     def _submit_feedback(self):
+        self._model.state.exit_reason = ExitReason.QUIT
         self._model.submit_feedback(self._state["feedback_text"])
         raise StopApplication("User Quit after submitting feedback")
```

## spydertop/screens/setup.py

```diff
@@ -24,31 +24,30 @@
 
 from typing import Callable, List, Optional
 from asciimatics.screen import Screen
 from asciimatics.widgets import (
     Frame,
     Layout,
     ListBox,
-    CheckBox,
-    RadioButtons,
     Text,
 )
 from asciimatics.event import KeyboardEvent, MouseEvent
 
 from spydertop.constants.columns import (
     CONTAINER_COLUMNS,
     PROCESS_COLUMNS,
     FLAG_COLUMNS,
     SESSION_COLUMNS,
     CONNECTION_COLUMNS,
     LISTENING_SOCKET_COLUMNS,
     Column,
 )
 from spydertop.model import AppModel
-from ..utils import is_event_in_widget
+from spydertop.utils import is_event_in_widget
+from spydertop.widgets.form import value_to_widget
 
 # the following are a set of functions that are used to fill in the options
 # some of these are only necessary due to python's lambda behavior
 
 
 def change_columns(columns: List[Column], name):
     """Create a lambda to enable/disable a column"""
@@ -59,42 +58,45 @@
                 model.columns_changed = True
                 col.enabled = enabled
                 return
 
     return inner
 
 
-def set_config(name):
-    """Create a lambda to set a config value"""
+def set_setting(name):
+    """Create a lambda to set a config value in the settings"""
 
     if name == "play_speed":
 
-        def set_play(val, model):
+        def set_play(val, model: AppModel):
             if val != 0.0:
-                model.config[name] = val
+                setattr(model.settings, name, val)
 
         return set_play
 
-    def inner(val, model):
-        model.config[name] = val
+    def inner(val, model: AppModel):
+        setattr(model.settings, name, val)
+
+    return inner
+
+
+def set_state(name):
+    """Create a lambda to set a config value in the state"""
+
+    def inner(val, model: AppModel):
+        setattr(model.state, name, val)
 
     return inner
 
 
 def get_enabled(columns: List[Column], index: int):
     """Get the enabled status of a column"""
     return lambda _: columns[index].enabled
 
 
-def collapse_tree(val, model):
-    """Create a lambda to set the collapse tree value"""
-    model.config["collapse_tree"] = val
-    model.rebuild_tree()
-
-
 # the options dict is structured the same way
 # as the ui would be, where the key(s) is the name of the option
 # in the list box, and the value is a tuple of:
 #     name: the name of the option
 #     values: a tuple of (possible values, default value lambda)
 #     change_func: a function that takes the value and the model
 
@@ -151,71 +153,76 @@
     },
     # there is currently no mechanism to enable/disable meters
     # "Meters": {"Column 1": [], "Column 2": []},
     "Other": {
         "Settings": [
             (
                 "Hide Threads",
-                (True, lambda model: model.config["hide_threads"]),
-                set_config("hide_threads"),
+                (True, lambda model: model.settings.hide_threads),
+                set_setting("hide_threads"),
             ),
             (
                 "Hide Kernel Threads",
-                (True, lambda model: model.config["hide_kthreads"]),
-                set_config("hide_kthreads"),
+                (True, lambda model: model.settings.hide_kthreads),
+                set_setting("hide_kthreads"),
             ),
             (
                 "Sort Ascending",
-                (True, lambda model: model.config["sort_ascending"]),
-                set_config("sort_ascending"),
+                (True, lambda model: model.state.sort_ascending),
+                set_state("sort_ascending"),
             ),
             (
                 "Cursor Follows Record",
-                (False, lambda model: model.config["follow_record"]),
-                set_config("follow_record"),
+                (False, lambda model: model.settings.follow_record),
+                set_setting("follow_record"),
             ),
             (
                 "Use UTC Time",
-                (False, lambda model: model.config["utc_time"]),
-                set_config("utc_time"),
+                (False, lambda model: model.settings.utc_time),
+                set_setting("utc_time"),
             ),
             (
                 "Play",
-                (False, lambda model: model.config["play"]),
-                set_config("play"),
+                (False, lambda model: model.state.play),
+                set_state("play"),
             ),
             (
                 "Play Speed",
-                (1.0, lambda model: model.config["play_speed"]),
-                set_config("play_speed"),
+                (1.0, lambda model: model.settings.play_speed),
+                set_setting("play_speed"),
             ),
             (
                 "Tree",
-                (False, lambda model: model.config["tree"]),
-                set_config("tree"),
+                (False, lambda model: model.settings.tree),
+                set_setting("tree"),
             ),
             (
                 "Collapse All",
-                (False, lambda model: model.config["collapse_tree"]),
-                collapse_tree,
+                (False, lambda model: model.settings.collapse_tree),
+                set_setting("collapse_tree"),
             ),
             (
                 "Filter",
-                ("", lambda model: model.config["filter"]),
-                set_config("filter"),
+                ("", lambda model: model.state.filter),
+                set_state("filter"),
+            ),
+            (
+                "Default Loading Duration (min)",
+                (15, lambda model: model.settings.default_duration_minutes),
+                set_setting("default_duration_minutes"),
             ),
         ],
         "Colors": [
             (
                 "Select Color Scheme:",
                 (
                     {"htop", "spyderbat", "monochrome", "green", "bright", "tlj256"},
-                    lambda model: model.config["theme"],
+                    lambda model: model.settings.theme,
                 ),
-                set_config("theme"),
+                set_setting("theme"),
             ),
         ],
     },
 }
 
 
 class SetupFrame(Frame):
@@ -263,15 +270,15 @@
             name="setup secondary column",
             add_scroll_bar=True,
             on_change=self._on_change,
         )
 
         self._main_column.value = "Columns"
 
-        self.set_theme(self._model.config["theme"])
+        self.set_theme(self._model.settings.theme)
 
         self.rebuild()
 
     def process_event(self, event):
         assert self.scene is not None
         if isinstance(event, KeyboardEvent):
             if (
@@ -286,78 +293,38 @@
             if is_event_in_widget(event, self) and (event.buttons != 0):
                 # when a click is outside the modal, close it
                 self.scene.remove_effect(self)
                 if self._on_death is not None:
                     self._on_death()
 
         super().process_event(event)
-        if self._model.config.settings_changed:
-            self.set_theme(self._model.config["theme"])
+        if self._model.settings.theme != self._theme:
+            self.set_theme(self._model.settings.theme)
 
     def make_widget(self, row):
         """Construct a widget for the given row based on its type."""
         label, values, on_change = row
         default_getter = None
 
         # unpack the values tuple if there is a default getter
         if isinstance(values, tuple):
             values, default_getter = values
 
-        if isinstance(values, bool):
-            # make checkbox
-            checkbox = CheckBox(
-                label, on_change=lambda: on_change(checkbox.value, self._model)
-            )
-            checkbox.value = default_getter(self._model) if default_getter else values
-            return checkbox
-
-        if isinstance(values, set):
-            # make radio
-            radio = RadioButtons(
-                [(x, x) for x in values],
-                label=label,
-                on_change=lambda: on_change(radio.value, self._model),
-            )
-            if default_getter:
-                radio.value = default_getter(self._model)
-            return radio
-
-        if isinstance(values, str):
-            # make textbox
+        widget = value_to_widget(
+            label, values, lambda _, val: on_change(val, self._model)
+        )
+        if isinstance(widget, Text):
             self._has_textbox = True
-            textbox = Text(
-                label=label, on_change=lambda: on_change(textbox.value, self._model)
-            )
-            textbox.value = default_getter(self._model) if default_getter else values
-            return textbox
-
-        if isinstance(values, float):
-            # make numerical input
-            def validate(value):
-                try:
-                    _ = float(value)
-                    return True
-                except ValueError:
-                    return False
-
-            textbox = Text(
-                label=label,
-                validator=validate,
-                on_change=(
-                    lambda: on_change(float(textbox.value), self._model)
-                    if validate(textbox.value)
-                    else None
-                ),
-            )
-            textbox.value = str(
-                default_getter(self._model) if default_getter else values
-            )
-            return textbox
+        if default_getter:
+            if isinstance(widget, Text):
+                widget.value = str(default_getter(self._model))
+            else:
+                widget.value = default_getter(self._model)
 
-        raise ValueError(f"Unknown type for widget {type(values)}")
+        return widget
 
     # The only way to remove and re-add widgets in Asciimatics is to use
     # Layout.clear_widgets(). Therefore, we need to be able to easily rebuild the entire
     # UI on each selection change
 
     # the idea is to build all of the widgets based off of the OPTIONS dict
     # and then render them by clearing and re-adding dynamically when the
```

## spydertop/utils/__init__.py

```diff
@@ -6,22 +6,40 @@
 #
 
 """
 Various utilities for spydertop
 """
 
 from datetime import datetime, timezone
+import os
+from pathlib import Path
 import re
-from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple, TypeVar, Union
+from typing import (
+    Any,
+    Callable,
+    Dict,
+    Iterable,
+    List,
+    Optional,
+    Tuple,
+    TypeVar,
+    Union,
+    TYPE_CHECKING,
+)
 
 from asciimatics.widgets.utilities import THEMES
-from spydertop.constants import COLOR_REGEX
 
+from spydertop.constants import COLOR_REGEX
 from spydertop.utils.types import Alignment, DelayedLog, Record
 
+if TYPE_CHECKING:
+    from spydertop.config.config import Settings
+else:
+    Settings = Any
+
 global log  # pylint: disable=global-at-module-level,invalid-name
 # the global log object, used everywhere
 log = DelayedLog()
 
 
 T = TypeVar("T")
 U = TypeVar("U")
@@ -89,15 +107,17 @@
         time_type = value[-1]
         timestamp = float(value[:-1])
         # convert to seconds
         switch = {"s": 1, "m": 60, "h": 3600, "d": 3600 * 24, "y": 3600 * 24 * 365}
         if time_type in switch:
             timestamp *= switch[time_type]
         else:
-            raise ValueError(f"Invalid time type {time_type}") # pylint: disable=raise-missing-from
+            raise ValueError(  # pylint: disable=raise-missing-from
+                f"Invalid time type {time_type}"
+            )
     return timestamp
 
 
 def header_bytes(n_bytes: int) -> str:
     """Format a number of bytes in a human readable format, without coloring for the header"""
     for suffix in ["", "K", "M", "G", "T"]:
         if n_bytes < 100:
@@ -105,32 +125,30 @@
             return f"{n_bytes}{suffix}"
         n_bytes = int(n_bytes / 1024)
     return f"{n_bytes}P"
 
 
 def add_palette(text, model, **kwargs) -> str:
     """formats the text with a few keys from the palette"""
-    palette = THEMES[model.config["theme"]]
+    palette = THEMES[model.settings.theme]
     # this is necessary because the palette may be a defaultdict
     concrete_palette = {
         "background": palette["background"][0],
         "borders": palette["borders"][0],
         "button": palette["button"][0],
         "button_bg": palette["button"][2],
         "label": palette["label"][0],
         "meter_label": (palette.get("meter_label", palette["label"]))[0],
     }
     return text.format(**concrete_palette, **kwargs)
 
 
-def get_timezone(model):
+def get_timezone(settings: Settings):
     """Get the timezone based on the config"""
-    return (
-        timezone.utc if model.config["utc_time"] else datetime.now().astimezone().tzinfo
-    )
+    return timezone.utc if settings.utc_time else datetime.now().astimezone().tzinfo
 
 
 def is_event_in_widget(event, widget):
     """Determine if the event is in the area of the widget"""
     return (
         widget.rebase_event(event).x < 0
         or widget.rebase_event(event).x > widget.canvas.width
@@ -217,14 +235,41 @@
     spaces = " " * left_space
     right_spaces = " " * (extra_space - left_space + 1) if include_padding else ""
     text = f"{spaces}{text}{right_spaces}"
 
     return text
 
 
+def get_source_name(source: dict) -> str:
+    """Returns the name of a source"""
+    if "description" in source:
+        return source["description"]
+    if "runtime_description" in source:
+        return source["runtime_description"]
+    if "uid" in source:
+        return source["uid"]
+    return "Unknown"
+
+
 def get_machine_short_name(machine: Record) -> str:
     """Get a short name for a machine"""
     if "cloud_tags" in machine and "Name" in machine["cloud_tags"]:
         if "k8s" in "".join(list(machine["cloud_tags"].keys())):
             return "node:" + machine["hostname"]
         return machine["cloud_tags"]["Name"]
     return machine["hostname"]
+
+
+def obscure_key(key: str) -> str:
+    """Obscure a key by only showing the first and last 4 characters"""
+    return key[:4] + "..." + key[-4:]
+
+
+def is_docker():
+    """Determine if we are running in a docker container"""
+    # https://stackoverflow.com/a/48710609/1072212
+    cgroup = Path("/proc/self/cgroup")
+    return (
+        Path("/.dockerenv").is_file()
+        or cgroup.is_file()
+        and "docker" in cgroup.read_text("utf-8")
+    )
```

## spydertop/utils/types.py

```diff
@@ -6,33 +6,46 @@
 #
 
 """
 Custom or modified types for use in the application.
 """
 
 import bisect
-from datetime import datetime
+from dataclasses import dataclass
+from datetime import datetime, timedelta
 from enum import Enum
 import re
 from textwrap import TextWrapper
 import traceback
-from typing import Dict, List, NewType, Optional, Tuple, Union, Any
+from typing import Dict, List, NewType, Optional, TextIO, Tuple, Union, Any
 import logging
 
 import click
 from asciimatics.parsers import Parser
 
 from spydertop.constants import COLOR_REGEX
 
 # custom types for data held in the model
 Tree = NewType("Tree", Dict[str, Optional[Tuple[bool, "Tree"]]])
 RecordInternal = NewType("RecordInternal", Any)
 Record = NewType("Record", Dict[str, RecordInternal])
 
 
+@dataclass
+class LoadArgs:
+    """A container for the arguments passed to the load function"""
+
+    organization: Optional[str]
+    source: Optional[str]
+    duration: Optional[timedelta]
+    input: Optional[TextIO]
+    output: Optional[TextIO]
+    timestamp: Optional[datetime]
+
+
 class APIError(Exception):
     """
     An error that occurs when communicating with the API
     """
 
 
 # custom types for adding context to values and formatting
@@ -122,14 +135,15 @@
     STOPPED = "T"
     TRACING_STOP = "t"
     PAGING = "W"
     DEAD = "X"
     WAKE_KILL = "K"
     WAKING = "W"
     PARKED = "P"
+    IDLE = "I"
     UNKNOWN = "?"
 
     def __lt__(self, other: "Status") -> bool:
         return self.value < other.value
 
     def __gt__(self, other: "Status") -> bool:
         return self.value > other.value
```

## spydertop/widgets/table.py

```diff
@@ -6,107 +6,115 @@
 #
 
 """
 This module contains a table widget which displays data in a tabular format.
 It extends the functionality of the asciimatics.widgets.MultiColumnListBox
 """
 
+from dataclasses import dataclass
 import re
 from typing import Any, Dict, List, NewType, Optional, Tuple, Union
 
 from asciimatics.screen import Screen
 from asciimatics.event import KeyboardEvent, MouseEvent
 from asciimatics.widgets import Widget
 from asciimatics.parsers import Parser
 from asciimatics.strings import ColouredText
+from spydertop.config.config import Settings
 from spydertop.constants.columns import Column
+from spydertop.state import State
 from spydertop.utils import align_with_overflow
 
 from spydertop.utils.types import ExtendedParser
-from spydertop.model import AppModel, Tree
-from spydertop.config import Config
+from spydertop.model import Tree
 
 InternalRow = NewType("InternalRow", Tuple[List[Union[ColouredText, str]], List[Any]])
 
 
+@dataclass
+class TableState:
+    """State for the table widget"""
+
+    id_to_follow: Optional[str] = None
+    selected_row: int = 0
+
+
 class Table(Widget):  # pylint: disable=too-many-instance-attributes
     """
     The main record table for the application. This table
     handles the sorting, filtering, and display of the records.
     """
 
     tree: Optional[Tree]
 
     header_enabled: bool = True
     columns: List[Column] = []
     _rows: List[InternalRow] = []
     _filtered_rows: List[InternalRow] = []
     _tree_rows: Optional[List[InternalRow]] = None
 
-    _config: Config
+    _app_state: State
+    _state: TableState
+    _settings: Settings
     _parser: Parser
 
     _vertical_offset: int = 0
     _horizontal_offset: int = 0
 
-    def __init__(
+    def __init__(  # pylint: disable=too-many-arguments
         self,
-        model: AppModel,
+        state: State,
+        settings: Settings,
         tree: Optional[Tree],
         name="Table",
         parser=ExtendedParser(),
     ):
         super().__init__(
             name, tab_stop=True, disabled=False, on_focus=None, on_blur=None
         )
 
-        self._state, self._set_state = model.use_state(
-            name,
-            {
-                "id_to_follow": None,
-                "selected_row": 0,
-            },
-        )
+        self._app_state = state
+        self._state = state.use_state(name, TableState())
         self._parser = parser
-        self._config = model.config
+        self._settings = settings
         self.tree = tree
 
     def update(
         self, frame_no
     ):  # pylint: disable=too-many-branches,too-many-locals,too-many-statements
         assert self._frame is not None
         # select the followed id
-        if self._state["id_to_follow"] is not None and self._config["follow_record"]:
+        if self._state.id_to_follow is not None and self._settings.follow_record:
             for i, row in enumerate(self._filtered_rows):
-                if row[1][0] == self._state["id_to_follow"]:
+                if row[1][0] == self._state.id_to_follow:
                     self.value = i
                     break
         else:
             if len(self._filtered_rows) > 0 and 0 <= self.value < len(
                 self._filtered_rows
             ):
-                self._set_state(id_to_follow=self._filtered_rows[self.value][1][0])
+                self._state.id_to_follow = self._filtered_rows[self.value][1][0]
 
         # validate the selected row
         if (
-            self._state["selected_row"] >= len(self._filtered_rows)
+            self._state.selected_row >= len(self._filtered_rows)
             and len(self._filtered_rows) != 0
         ):
             self.value = len(self._filtered_rows) - 1
 
         # first, print the header
         if self.header_enabled:
             offset = -self._horizontal_offset
             for col in self.columns:
-                if col.header_name == self._config["sort_column"]:
+                if col.header_name == self._app_state.sort_column:
                     color, attr, background = self._frame.palette.get(
                         "table_header_selected",
                         self._frame.palette["selected_focus_field"],
                     )
-                    arrow = "" if self._config["sort_ascending"] else ""
+                    arrow = "" if self._app_state.sort_ascending else ""
                 else:
                     color, attr, background = self._frame.palette.get(
                         "table_header", self._frame.palette["title"]
                     )
                     arrow = ""
                 width = col.max_width
                 if width == 0:
@@ -130,15 +138,15 @@
 
         # then, print the rows
         for i in range(self._vertical_offset, self._vertical_offset + self._h - 1):
             if i >= len(self._filtered_rows) or i < 0:
                 break
             displayable_row, _ = self._filtered_rows[i]
             x_offset = -self._horizontal_offset
-            if self._state["selected_row"] == i:
+            if self._state.selected_row == i:
                 color, attr, background = self._frame.palette.get(
                     "table_selected", self._frame.palette["selected_focus_field"]
                 )
                 has_color = False
             else:
                 color, attr, background = self._frame.palette.get(
                     "table", self._frame.palette["focus_field"]
@@ -177,48 +185,48 @@
             y_offset += 1
 
     def process_event(  # pylint: disable=too-many-return-statements,too-many-branches
         self, event
     ):
         if isinstance(event, KeyboardEvent):
             if event.key_code == Screen.KEY_UP:
-                self.value = max(0, self._state["selected_row"] - 1)
+                self.value = max(0, self._state.selected_row - 1)
                 return None
             if event.key_code == Screen.KEY_DOWN:
                 self.value = min(
-                    len(self._filtered_rows) - 1, self._state["selected_row"] + 1
+                    len(self._filtered_rows) - 1, self._state.selected_row + 1
                 )
                 return None
             if event.key_code == Screen.KEY_LEFT:
                 self._horizontal_offset = max(0, self._horizontal_offset - 1)
                 return None
             if event.key_code == Screen.KEY_RIGHT:
                 self._horizontal_offset += 1
                 return None
             if event.key_code == 337:
-                self.value = max(0, self._state["selected_row"] - 5)
+                self.value = max(0, self._state.selected_row - 5)
                 return None
             if event.key_code == 336:
                 self.value = min(
-                    len(self._filtered_rows) - 1, self._state["selected_row"] + 5
+                    len(self._filtered_rows) - 1, self._state.selected_row + 5
                 )
                 return None
             if event.key_code == 393:
                 self._horizontal_offset = max(0, self._horizontal_offset - 5)
                 return None
             if event.key_code == 402:
                 self._horizontal_offset += 5
                 return None
             if event.key_code == Screen.KEY_PAGE_UP:
-                self.value = max(0, self._state["selected_row"] - self._h + 1)
+                self.value = max(0, self._state.selected_row - self._h + 1)
                 return None
             if event.key_code == Screen.KEY_PAGE_DOWN:
                 self.value = min(
                     len(self._filtered_rows) - 1,
-                    self._state["selected_row"] + self._h - 1,
+                    self._state.selected_row + self._h - 1,
                 )
                 return None
             if event.key_code == Screen.KEY_HOME:
                 self.value = 0
                 return None
             if event.key_code == Screen.KEY_END:
                 self.value = len(self._filtered_rows) - 1
@@ -235,25 +243,26 @@
                 if relative_y == 0:
                     # this is the header
                     relative_x += self._horizontal_offset
                     for col in self.columns:
                         if not col.enabled:
                             continue
                         if relative_x - col.max_width - 1 < 0 or col.max_width == 0:
-                            if self._config["sort_column"] == col.header_name:
-                                self._config["sort_ascending"] = not self._config[
-                                    "sort_ascending"
-                                ]
+                            if self._app_state.sort_column == col.header_name:
+                                self._app_state.sort_ascending = (
+                                    not self._app_state.sort_ascending
+                                )
                             else:
-                                self._config["sort_column"] = col.header_name
+                                self._app_state.sort_column = col.header_name
                             break
                         relative_x -= col.max_width + 1
                 else:
                     # select the clicked row
-                    self.value = relative_y - 1 + self._vertical_offset
+                    header_offset = 1 if self.header_enabled else 0
+                    self.value = relative_y - header_offset + self._vertical_offset
                 return None
         return event
 
     def required_height(self, offset, width):
         return Widget.FILL_FRAME
 
     def reset(self):
@@ -280,16 +289,16 @@
         """
         Sort the rows according to the configured sort order.
         """
 
         # if we are displaying a tree, we need to use the tree to sort
         # first, and to modify the command
         if (
-            self._config["tree"]
-            and self._config["tab"] == "processes"
+            self._settings.tree
+            and self._settings.tab == "processes"
             and self.tree is not None
         ):
             # we need the columns to have an ID
             assert self.columns[0].header_name == "ID"
             # refactor cached sortable data to be indexed by id
             sortable = {}
             for row in self._rows:
@@ -300,32 +309,32 @@
             self._rows = self._simple_sort(self._rows)
         self.do_filter()
 
     def do_filter(self) -> None:
         """
         Filter the rows by the configured value.
         """
-        value = self._config["filter"]
+        value = self._app_state.filter
         rows = (
             self._tree_rows
-            if self._config["tree"]
-            and self._config["tab"] == "processes"
+            if self._settings.tree
+            and self._settings.tab == "processes"
             and self._tree_rows is not None
             else self._rows
         )
         if value is None:
             self._filtered_rows = rows
             return
 
         column_matches, rest = self._parse_filter(value)
 
         self._filtered_rows = [
             row for row in rows if self._filter_predicate(row, column_matches, rest)
         ]
-        if self._state["selected_row"] >= len(self._filtered_rows):
+        if self._state.selected_row >= len(self._filtered_rows):
             self.value = 0
 
     def _filter_predicate(  # pylint: disable=too-many-return-statements
         self, row: InternalRow, column_matches: List[str], rest: str
     ) -> bool:
         # filter by specific columns
         for column_match in column_matches:
@@ -383,36 +392,36 @@
     def fix_vert_offset(self):
         """Fix the vertical offset to keep the selected row
         within the range of the table."""
         if self._h == 0:
             # the screen is resizing, so don't do anything
             self._vertical_offset = 0
             return
-        if self._state["selected_row"] < self._vertical_offset:
-            self._vertical_offset = self._state["selected_row"]
-        if self._state["selected_row"] >= self._vertical_offset + self._h - 1:
-            self._vertical_offset = self._state["selected_row"] - self._h + 2
+        if self._state.selected_row < self._vertical_offset:
+            self._vertical_offset = self._state.selected_row
+        if self._state.selected_row >= self._vertical_offset + self._h - 1:
+            self._vertical_offset = self._state.selected_row - self._h + 2
 
     def find(self, search: str) -> bool:
         """Finds the first row that contains the given search string."""
         column_matches, rest = self._parse_filter(search)
         for i, row in enumerate(self._filtered_rows):
             if self._filter_predicate(row, column_matches, rest):
                 self.value = i
                 return True
         return False
 
     def get_selected(self) -> Optional[InternalRow]:
         """Returns the selected row"""
         if (
-            self._state["selected_row"] >= len(self._filtered_rows)
-            or self._state["selected_row"] < 0
+            self._state.selected_row >= len(self._filtered_rows)
+            or self._state.selected_row < 0
         ):
             return None
-        return self._filtered_rows[self._state["selected_row"]]
+        return self._filtered_rows[self._state.selected_row]
 
     def _sort_level(
         self,
         tree: Dict[str, Any],
         rows: Dict[str, Tuple],
         depth: int,
         parents_end: List[bool],
@@ -464,16 +473,16 @@
 
         return sorted_rows
 
     def _simple_sort(self, rows: List[InternalRow]) -> List[InternalRow]:
         """Sort a list of rows by a key, putting all Nones at the end."""
         if len(rows) == 0:
             return []
-        key = self._config["sort_column"]
-        ascending = self._config["sort_ascending"]
+        key = self._app_state.sort_column
+        ascending = self._app_state.sort_ascending
         # sort by PID by default
         col_names = [_.header_name for _ in self.columns]
         if "PID" in col_names:
             pid_index = col_names.index("PID")
             rows.sort(key=lambda x: x[1][pid_index])
 
         if key is None or key not in col_names:
@@ -505,19 +514,19 @@
             + ("" if not_expandable else "+")
             + " "
         )
 
     @property
     def value(self) -> int:
         """The selected row"""
-        return self._state["selected_row"]
+        return self._state.selected_row
 
     @value.setter
     def value(self, value: int):
         if len(self._filtered_rows) == 0:
             return
         value = max(value, 0)
         if value >= len(self._filtered_rows):
             value = len(self._filtered_rows) - 1
-        self._set_state(selected_row=value)
-        self._set_state(id_to_follow=self._filtered_rows[value][1][0])
+        self._state.selected_row = value
+        self._state.id_to_follow = self._filtered_rows[value][1][0]
         self.fix_vert_offset()
```

## Comparing `spydertop/utils/cache.py` & `spydertop/config/cache.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,17 +1,27 @@
+#
+# cache.py
+#
+# Author: Griffith Thomas
+# Copyright 2023 Spyderbat, Inc. All rights reserved.
+#
+
 """
 A module for handling caching of data from expensive operations
 """
 
 from datetime import timedelta, datetime
 import hashlib
-from typing import Callable, Optional, Union
+from pathlib import Path
+from typing import Any, Callable, Dict, Optional, Union
 import gzip
 
-from spydertop.config import get_config_dir
+import yaml
+
+from spydertop.config import DIRS
 from spydertop.utils import log
 
 DEFAULT_TIMEOUT = timedelta(minutes=5)
 
 
 def cache_block(
     key: Union[str, bytes],
@@ -29,50 +39,61 @@
     result = _cache_get(hashed_key, timeout)
     if result is None:
         result = func()
         _cache_set(hashed_key, result)
     return result
 
 
+def get_user_cache() -> Dict[str, Any]:
+    """Get the user cache"""
+    cache_file = Path(DIRS.user_cache_dir) / "user_cache.yaml"
+    if cache_file.exists():
+        cache = yaml.safe_load(cache_file.read_text(encoding="utf-8"))
+    else:
+        cache = {}
+    return cache
+
+
+def set_user_cache(key: str, value: Any):
+    """Set a value in the user cache"""
+    # this is used infrequently for now, so we are not going to worry about
+    # the performance of this
+    cache = get_user_cache()
+    cache[key] = value
+    cache_file = Path(DIRS.user_cache_dir) / "user_cache.yaml"
+    cache_file.write_text(yaml.safe_dump(cache), encoding="utf-8")
+
+
 def _cache_get(key: str, timeout: timedelta):
     """Get the cached value for a key, or None if it doesn't exist"""
     return _disk_cache_get(key, timeout)
 
 
 def _cache_set(key: str, value):
     """Set the cached value for a key"""
     _disk_cache_set(key, value)
 
 
 def _disk_cache_get(key: str, timeout: timedelta) -> Optional[bytes]:
     """Get the cached value for a key from the cache directory"""
-    cache_dir = _get_cache_dir()
-
+    cache_dir = Path(DIRS.user_cache_dir)
     cache_file = cache_dir / key
+
     if not cache_file.exists():
         log.debug("cache miss;reason=nonexistent", key)
         return None
 
     if cache_file.stat().st_mtime < (datetime.now() - timeout).timestamp():
         log.debug("cache miss;reason=expired", key)
         return None
 
     with gzip.open(cache_file, "rb") as open_file:
         return open_file.read()
 
 
 def _disk_cache_set(key: str, value: bytes):
     """Set the cached value for a key in the cache directory"""
-    cache_dir = _get_cache_dir()
+    cache_dir = Path(DIRS.user_cache_dir)
     cache_file = cache_dir / key
 
     with gzip.open(cache_file, "wb") as open_file:
         open_file.write(value)
-
-
-def _get_cache_dir():
-    """Get the cache directory"""
-    config_dir = get_config_dir()
-    cache_dir = config_dir / "cache"
-    if not cache_dir.exists():
-        cache_dir.mkdir()
-    return cache_dir
```

## Comparing `spydertop-1.2.3.dist-info/LICENSE` & `spydertop-1.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `spydertop-1.2.3.dist-info/METADATA` & `spydertop-1.3.0.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: spydertop
-Version: 1.2.3
+Version: 1.3.0
 Summary: A tool that provides htop-like functionality for any point in time.
 Author-email: Griffith Thomas <dev@spyderbat.com>
 Maintainer-email: Spyderbat <dev@spyderbat.com>
 License: The MIT License (MIT)
         
         Copyright (c) 2022 Spyderbat
         
@@ -24,14 +24,16 @@
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: asciimatics
 Requires-Dist: click
 Requires-Dist: pyyaml
 Requires-Dist: pyperclip
+Requires-Dist: dateparser
+Requires-Dist: platformdirs
 Requires-Dist: urllib3
 Requires-Dist: orjson
 Requires-Dist: importlib-metadata (>=1.0) ; python_version < "3.8"
 
 # Spydertop
 
 Spydertop is a tool that provides htop-like functionality for any point in time, on any of your Spyderbat-enabled machines. Utilizing Spyderbats kernel-level system monitoring and public APIs, Spydertop allows analysts to look into system anomalies days or even months after they occur.
@@ -48,20 +50,22 @@
 # to run without arguments
 docker run -it spyderbat/spydertop
 
 # to run on an example
 docker run -it spyderbat/spydertop -i examples/minikube-sock-shop.json.gz
 
 # to persist settings, or to use a pre-configured Spyderbat API
-docker run -it -v $HOME/.spyderbat-api:/root/.spyderbat-api spyderbat/spydertop [ARGS]
+docker run -it -v $HOME/.config/spydertop:/root/.config/spydertop spyderbat/spydertop [ARGS]
 
 # to run docker with the host's timezone settings
 docker run -it -v /etc/localtime:/etc/localtime spyderbat/spydertop [ARGS]
 ```
 
+You can also download the bundled executable from the [releases page](https://github.com/spyderbat/spydertop/releases), which includes everything necessary to run spydertop, including a compatible python version!
+
 ## Installation
 
 Spydertop can be installed from [PyPi](https://pypi.org/project/spydertop/) with pip:
 
 ```sh
 pip install spydertop
 ```
@@ -72,60 +76,71 @@
 
 ```sh
 # note: requires setuptools >= 45
 pip install .
 # pip install . -e # for editable install
 ```
 
-On your first run of `spydertop`, it will guide you through setting up a configuration if you do not have one already. If you prefer to set it up yourself, see [Configuration](#configuration). Your organization id can be found in the url for the dashboard, and many other pages:
-
-```url
-https://api.spyderbat.com/app/org/{ORG_ID_HERE}/dashboard
-```
-
-Similarly, the machine id can be located in the url of an investigation, or by enabling the id column in the sources list.
+On your first run of `spydertop`, it will guide you through setting up a basic configuration if you do not have one already. If you prefer to set it up yourself, see [Configuration](#configuration).
 
 ## Usage
 
 Spydertop is called with options specifying the machine to pull from and how that data is collected, and a timestamp. Records will be loaded from the specified machine around that time, and an htop-like view will start at the exact requested time. The relative time selection bar at the bottom or bracket keys (`[` or `]`) can be used to move forward and backward in time, and the arrow keys, tab key, or mouse can be used to navigate the interface. More usage information is available on the help page (`h` or `<F1>`).
 
 As this tool emulates much of HTOP's functionality, more information is also available on the HTOP man page.
 
 ## Examples
 
 ```sh
 spydertop --help # print usage information
 
 # starts spydertop with the specified machine
 # at a point in time 5 days ago
-spydertop -g ORGUID -m MACHINEUID -- -5d
+spydertop load -g ORGUID -m MACHINEUID -- -5d
 
 # full example
-spydertop \
+spydertop load \
         --organization ORGUID \
         --machine MACHINEUID \
         --duration 3m \
         --input cached_input_records.json.gz \
         --output file_to_save_to.json.gz \
-        --log-level WARN \
-        --no-confirm \
         -- 1654303663.600901
 ```
 
 ## Configuration
 
-Spydertop uses the Spyderbat APIs, so it must have access to a valid API key, usually stored in a configuration file, as shown below. This configuration file is automatically created the first time you run spydertop, but can be edited manually at any time. API keys can be obtained from the API keys page under your Spyderbat account.
+The current configuration, and it's location on disk, can be viewed with
+
+```bash
+spydertop config get
+```
+
+Spydertop uses the Spyderbat APIs, so it must have access to a valid API key. API keys can be obtained from the API keys page under your Spyderbat account, and configured in spydertop using the `spydertop config set-secret` command:
+
+```bash
+spydertop config set-secret --name mysecret --api-key $(cat ./apikey.txt)
+```
+
+When using the `load` command, spydertop uses a *context* to determine how to load data. By default, you will ahve to specify the organization and source every time you start spydertop. However, you can update or create a new context to configure default values:
+
+```bash
+spydertop config set-context --name mycontext --secret mysecret --organization ORG_ID --source SOURCE_ID
+```
+
+Your organization id can be found in the url for the dashboard, and many other pages. Similarly, the machine id can be located in the url of an investigation, or by enabling the id column in the sources list.
+
+```url
+https://api.spyderbat.com/app/org/{ORG_ID_HERE}/dashboard
+```
+
+After creating a context, you can enable it with:
 
-```yaml
-# File: ~/.spyderbat-api/config.yaml
-default:
-    api_key: API_KEY
-    org:     DEFAULT_ORG_ID     # optional
-    machine: DEFAULT_MACHINE_ID # optional
-    api_url: api.spyderbat.com  # optional
+```bash
+spydertop config use-context mycontext
 ```
 
 ## Development
 
 For development, Spydertop can be installed with the `--editable` flag in `pip`. Spydertop works well inside of a Python virtual environment, so using one is recommended.
 
 ```sh
```

## Comparing `spydertop-1.2.3.dist-info/RECORD` & `spydertop-1.3.0.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,33 +1,37 @@
-spydertop/__init__.py,sha256=C6BcVXNaXHru7k0ADa3i_Y9anCdtQrkuo-VK6XN2gaA,698
-spydertop/cli.py,sha256=iWdMxezi3YhYipQSpHzmrPN4jfmq74ysUexHM8bEZjs,6718
-spydertop/config.py,sha256=6yARI-9q18XvnhgAxas_-Rcpevka1X7B3Bi121YKTwU,10227
-spydertop/model.py,sha256=A5X6ot47GtFDWJeJnAIcKhpG4skZSB7gWPOQRunVSTI,25655
-spydertop/recordpool.py,sha256=ShhdNI8FpsJGzxHSBoiZuDFa2GZNCDs2MTze9jczIlo,13234
+spydertop/__init__.py,sha256=Z1-aupfb6M2gpXahtvU08skmbX3KEPZr2p8IaH-HbS0,706
+spydertop/cli.py,sha256=yfPb76xR3bGejO_sWUMhMfZVP6Or1nUYMSCVLWAsxYA,18803
+spydertop/model.py,sha256=G-DYS5wR-bp4X05UCMkl8pKu97nAowSO62GrfS2i-Ug,27339
+spydertop/recordpool.py,sha256=aUAQGMh48Rss26UYO3GsPnGeHC6rOni2PV8n1J5xZNA,13747
+spydertop/state.py,sha256=otWbUBr8-supD2vBVY2cO6G7l7y13BNLU1XgZvw-xl8,1512
+spydertop/config/__init__.py,sha256=Wwis3r8Yp4L-iMv-M5ssTqEdB0u5W24DusUSp4L-EKo,381
+spydertop/config/cache.py,sha256=LgyTREG-P9FGhTB_lEBEgugNfkHLzx3qEs9cRYBTR3o,2841
+spydertop/config/config.py,sha256=VK8fgX-qF5gJiwl4KR_mAeObrlLyPxVUudbppljVWkU,9498
+spydertop/config/secrets.py,sha256=ae0Gh-Aa30dlH_bEFcQiwmJT-OxpjpxjSETnSPmmtzU,2230
 spydertop/constants/__init__.py,sha256=ZYWrXqAcuJ_ZYotK0bUyKzTUORNPfxSBkwX1Y3zKfi8,823
-spydertop/constants/columns.py,sha256=SfMEB_y-vpCyc3PmMYvTCZs_nOe-sOGzySWYHNqXILc,19877
+spydertop/constants/columns.py,sha256=mqmdzyggmLUrtMMmjJzN6FG_LnWmALe-MmYIwLaAOOM,20064
 spydertop/constants/palettes.py,sha256=q0rni42hgp_IdcWx-MNnJxBO40AzRk_QvrlmTuJ7h0c,3902
-spydertop/screens/__init__.py,sha256=7gMUft0RbG0yIt-SuaLYg8HLOvKnDNhNNzUtjV4wUWw,2742
-spydertop/screens/config.py,sha256=vqCJZHgeKFRuBux-KqcOAcVIdIB1CKdAe4yfZZ3NJiU,35201
-spydertop/screens/failure.py,sha256=Z1s69pbacGrO2UxFx5koIvShXToGSc_nBufI30bcAlc,3315
-spydertop/screens/feedback.py,sha256=nIOYrs0ZDBeBLqCpH5CdAIOfYqWcuZxjNLgCXGIPqbQ,4121
-spydertop/screens/footer.py,sha256=xnJiXzSmeu3MSArzIRxCiYkG-JZBY-g9aqToN94aDv4,2056
-spydertop/screens/help.py,sha256=bcjvDLekS7-RR5OcGbGIT28G4kMmHlNL_Oa7e4Sl5-I,7578
-spydertop/screens/loading.py,sha256=w8cAdbEDWYbDHmaKhAG5AYehDXnAxuJjEhrO9VhyYeo,7753
-spydertop/screens/main.py,sha256=4ZRoxLudbqGm5EXdvLa9qKOEZ9Q9p8t137Ssfj5Xf10,34957
-spydertop/screens/meters.py,sha256=XjL4HTFdyTlBezqoe43w_BWilmZJKqrbj7LJqtXAO8Q,11199
+spydertop/screens/__init__.py,sha256=O8q7lrGaNRX3qIEBdgfkOHTtLkWO5wPTeM2krwb5GQg,5033
+spydertop/screens/config.py,sha256=PtMiqwTwDXQr3OR04va2MyXLHgpxMwuuHxcZsR83G0E,32896
+spydertop/screens/failure.py,sha256=HZKHjxJ3PbcVxX2b72_kJliUNfJewj_q8yTYgNrhXts,3406
+spydertop/screens/feedback.py,sha256=wDm1NBB66XgsByXPKUxVY06jXHMof6f_GLsiUz3J4W4,4119
+spydertop/screens/footer.py,sha256=QRkqD9JUaq_7W7xmWijxPmyJ2bfKCBPmaD_tr-7cWfI,2074
+spydertop/screens/help.py,sha256=QP_QL7hJ49Gk05uxySo-C6Lj9H7FsvIBNiVvNqR_X7Y,7576
+spydertop/screens/loading.py,sha256=OuTrKXJH0mvhTzXOsT4YFr13ihdXERMtbtWnt8ml52o,8556
+spydertop/screens/main.py,sha256=c1F6S8hzs8OwCyOnqqhKwexuNss87CG4V4Euw5KAB_s,37497
+spydertop/screens/meters.py,sha256=s-fsjXaoClY4OvApmtAJLCWg3z9yTu0H1_uPNcy_KA8,11176
 spydertop/screens/modals.py,sha256=fdw79OLAQDrj2dWj_cIsFYLQwUANIVJtKhOncdS-aRM,5855
-spydertop/screens/quit.py,sha256=6qG6Qcbd8ALkz2raxs1Q9MU-xGukySlyxL3lT8BZL5Q,4472
-spydertop/screens/setup.py,sha256=l8E24r5yzXjWomSNr3x8sf09R95wzJqgEO6bMjl3Lfo,12680
-spydertop/utils/__init__.py,sha256=2AADA-JHGWWlpVecBygZbXLwGQ80RnFW2lnNGDtSrdU,7892
-spydertop/utils/cache.py,sha256=rlrVV8vf0j0sjRebQPHTFirVY4DNSr9fmeBrcbIsW3E,2242
+spydertop/screens/quit.py,sha256=8lcSjBf0nriu3vH_sXj9Byci2UhnrbMAb86CIeyeAek,4575
+spydertop/screens/setup.py,sha256=4vgn7u_N6RiRjT6G4zuIgD42U59ARWLJ3dRjKwbowAw,11624
+spydertop/utils/__init__.py,sha256=OICuGUA5TQArAueEGa1nl_KaQJ7zreK_eUfZXbTfafU,8861
 spydertop/utils/cursorlist.py,sha256=TvHZ09XxlRxn8a2MQoIFtbsNyGn2h72-4sQnuo2Bl9M,4462
-spydertop/utils/types.py,sha256=v7WQsS9IRSQg5hOOjxsx0f1jSfyaFAICGtLdYQrYYfc,16961
+spydertop/utils/types.py,sha256=ue7RkMtHjLETYprLGPumPbZs_oCeYqUrfLuIB_OKOe8,17310
 spydertop/widgets/__init__.py,sha256=MvQmVlCiIZ-XjXr0cbraxhHTnYOUFZr1tPstaSVMvZY,4754
+spydertop/widgets/form.py,sha256=d2knRP2EXAu2NeLmeRf5HzxcZd7uXRBGj1RWvK6xOW4,4539
 spydertop/widgets/meter.py,sha256=2wHE3fbnrOdM3ikdo7R0PNl_vgSUutRCIlXBuVe96Uc,6246
-spydertop/widgets/table.py,sha256=F1xy4bRSx0eEeKRWBCedIsOWWWK8QVDiuVWgnsSQmXY,19510
-spydertop-1.2.3.dist-info/LICENSE,sha256=xmP7T9G2YrKaTOdjtd2HaImbTgbI-9GEONF282CMhVs,1083
-spydertop-1.2.3.dist-info/METADATA,sha256=s5_GyuGTSFEn4J9SwsOk-CYD_qc9M4x_rtYc1OUmH2Y,6719
-spydertop-1.2.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-spydertop-1.2.3.dist-info/entry_points.txt,sha256=Yh0fjEsILGmJuSZNMyv5vTT5exChKirpkanM_HRtFpg,44
-spydertop-1.2.3.dist-info/top_level.txt,sha256=bCfL1jl5w76jalLAi5O-Qfzt6NEwTcyz7hb4uYWRPIU,10
-spydertop-1.2.3.dist-info/RECORD,,
+spydertop/widgets/table.py,sha256=lX2jSRPX2h_H7dt2xAbQE2pIOPygR0B_eq74vtoKhNs,19736
+spydertop-1.3.0.dist-info/LICENSE,sha256=xmP7T9G2YrKaTOdjtd2HaImbTgbI-9GEONF282CMhVs,1083
+spydertop-1.3.0.dist-info/METADATA,sha256=a-Gksgt7_Zs5mFO4IWtglzvezn4xPC7oZHWH_91U7TQ,7328
+spydertop-1.3.0.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+spydertop-1.3.0.dist-info/entry_points.txt,sha256=Yh0fjEsILGmJuSZNMyv5vTT5exChKirpkanM_HRtFpg,44
+spydertop-1.3.0.dist-info/top_level.txt,sha256=bCfL1jl5w76jalLAi5O-Qfzt6NEwTcyz7hb4uYWRPIU,10
+spydertop-1.3.0.dist-info/RECORD,,
```

